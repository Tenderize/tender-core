{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function __Ownable_init() internal initializer {\n        __Context_init_unchained();\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable_init_unchained() internal initializer {\n        _setOwner(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _setOwner(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _setOwner(newOwner);\n    }\n\n    function _setOwner(address newOwner) private {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    bool private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Modifier to protect an initializer function from being invoked twice.\n     */\n    modifier initializer() {\n        require(_initializing || !_initialized, \"Initializable: contract is already initialized\");\n\n        bool isTopLevelCall = !_initializing;\n        if (isTopLevelCall) {\n            _initializing = true;\n            _initialized = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            _initializing = false;\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuardUpgradeable is Initializable {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    function __ReentrancyGuard_init() internal initializer {\n        __ReentrancyGuard_init_unchained();\n    }\n\n    function __ReentrancyGuard_init_unchained() internal initializer {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20Upgradeable.sol\";\nimport \"./extensions/IERC20MetadataUpgradeable.sol\";\nimport \"../../utils/ContextUpgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20Upgradeable is Initializable, ContextUpgradeable, IERC20Upgradeable, IERC20MetadataUpgradeable {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    function __ERC20_init(string memory name_, string memory symbol_) internal initializer {\n        __Context_init_unchained();\n        __ERC20_init_unchained(name_, symbol_);\n    }\n\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal initializer {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\n        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\n        unchecked {\n            _approve(sender, _msgSender(), currentAllowance - amount);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        uint256 senderBalance = _balances[sender];\n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[sender] = senderBalance - amount;\n        }\n        _balances[recipient] += amount;\n\n        emit Transfer(sender, recipient, amount);\n\n        _afterTokenTransfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n    uint256[45] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/draft-ERC20PermitUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./draft-IERC20PermitUpgradeable.sol\";\nimport \"../ERC20Upgradeable.sol\";\nimport \"../../../utils/cryptography/draft-EIP712Upgradeable.sol\";\nimport \"../../../utils/cryptography/ECDSAUpgradeable.sol\";\nimport \"../../../utils/CountersUpgradeable.sol\";\nimport \"../../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on `{IERC20-approve}`, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * _Available since v3.4._\n */\nabstract contract ERC20PermitUpgradeable is Initializable, ERC20Upgradeable, IERC20PermitUpgradeable, EIP712Upgradeable {\n    using CountersUpgradeable for CountersUpgradeable.Counter;\n\n    mapping(address => CountersUpgradeable.Counter) private _nonces;\n\n    // solhint-disable-next-line var-name-mixedcase\n    bytes32 private _PERMIT_TYPEHASH;\n\n    /**\n     * @dev Initializes the {EIP712} domain separator using the `name` parameter, and setting `version` to `\"1\"`.\n     *\n     * It's a good idea to use the same `name` that is defined as the ERC20 token name.\n     */\n    function __ERC20Permit_init(string memory name) internal initializer {\n        __Context_init_unchained();\n        __EIP712_init_unchained(name, \"1\");\n        __ERC20Permit_init_unchained(name);\n    }\n\n    function __ERC20Permit_init_unchained(string memory name) internal initializer {\n        _PERMIT_TYPEHASH = keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");}\n\n    /**\n     * @dev See {IERC20Permit-permit}.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual override {\n        require(block.timestamp <= deadline, \"ERC20Permit: expired deadline\");\n\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\n\n        bytes32 hash = _hashTypedDataV4(structHash);\n\n        address signer = ECDSAUpgradeable.recover(hash, v, r, s);\n        require(signer == owner, \"ERC20Permit: invalid signature\");\n\n        _approve(owner, spender, value);\n    }\n\n    /**\n     * @dev See {IERC20Permit-nonces}.\n     */\n    function nonces(address owner) public view virtual override returns (uint256) {\n        return _nonces[owner].current();\n    }\n\n    /**\n     * @dev See {IERC20Permit-DOMAIN_SEPARATOR}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view override returns (bytes32) {\n        return _domainSeparatorV4();\n    }\n\n    /**\n     * @dev \"Consume a nonce\": return the current value and increment.\n     *\n     * _Available since v4.1._\n     */\n    function _useNonce(address owner) internal virtual returns (uint256 current) {\n        CountersUpgradeable.Counter storage nonce = _nonces[owner];\n        current = nonce.current();\n        nonce.increment();\n    }\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/draft-IERC20PermitUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20PermitUpgradeable {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20BurnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../ERC20Upgradeable.sol\";\nimport \"../../../utils/ContextUpgradeable.sol\";\nimport \"../../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Extension of {ERC20} that allows token holders to destroy both their own\n * tokens and those that they have an allowance for, in a way that can be\n * recognized off-chain (via event analysis).\n */\nabstract contract ERC20BurnableUpgradeable is Initializable, ContextUpgradeable, ERC20Upgradeable {\n    function __ERC20Burnable_init() internal initializer {\n        __Context_init_unchained();\n        __ERC20Burnable_init_unchained();\n    }\n\n    function __ERC20Burnable_init_unchained() internal initializer {\n    }\n    /**\n     * @dev Destroys `amount` tokens from the caller.\n     *\n     * See {ERC20-_burn}.\n     */\n    function burn(uint256 amount) public virtual {\n        _burn(_msgSender(), amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, deducting from the caller's\n     * allowance.\n     *\n     * See {ERC20-_burn} and {ERC20-allowance}.\n     *\n     * Requirements:\n     *\n     * - the caller must have allowance for ``accounts``'s tokens of at least\n     * `amount`.\n     */\n    function burnFrom(address account, uint256 amount) public virtual {\n        uint256 currentAllowance = allowance(account, _msgSender());\n        require(currentAllowance >= amount, \"ERC20: burn amount exceeds allowance\");\n        unchecked {\n            _approve(account, _msgSender(), currentAllowance - amount);\n        }\n        _burn(account, amount);\n    }\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20Upgradeable.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20MetadataUpgradeable is IERC20Upgradeable {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20Upgradeable {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal initializer {\n        __Context_init_unchained();\n    }\n\n    function __Context_init_unchained() internal initializer {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/CountersUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n */\nlibrary CountersUpgradeable {\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        unchecked {\n            counter._value += 1;\n        }\n    }\n\n    function decrement(Counter storage counter) internal {\n        uint256 value = counter._value;\n        require(value > 0, \"Counter: decrement overflow\");\n        unchecked {\n            counter._value = value - 1;\n        }\n    }\n\n    function reset(Counter storage counter) internal {\n        counter._value = 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/cryptography/draft-EIP712Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./ECDSAUpgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\n *\n * The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,\n * thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding\n * they need in their contracts using a combination of `abi.encode` and `keccak256`.\n *\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\n * ({_hashTypedDataV4}).\n *\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\n * the chain id to protect against replay attacks on an eventual fork of the chain.\n *\n * NOTE: This contract implements the version of the encoding known as \"v4\", as implemented by the JSON RPC method\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\n *\n * _Available since v3.4._\n */\nabstract contract EIP712Upgradeable is Initializable {\n    /* solhint-disable var-name-mixedcase */\n    bytes32 private _HASHED_NAME;\n    bytes32 private _HASHED_VERSION;\n    bytes32 private constant _TYPE_HASH = keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\");\n\n    /* solhint-enable var-name-mixedcase */\n\n    /**\n     * @dev Initializes the domain separator and parameter caches.\n     *\n     * The meaning of `name` and `version` is specified in\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\n     *\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\n     * - `version`: the current major version of the signing domain.\n     *\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\n     * contract upgrade].\n     */\n    function __EIP712_init(string memory name, string memory version) internal initializer {\n        __EIP712_init_unchained(name, version);\n    }\n\n    function __EIP712_init_unchained(string memory name, string memory version) internal initializer {\n        bytes32 hashedName = keccak256(bytes(name));\n        bytes32 hashedVersion = keccak256(bytes(version));\n        _HASHED_NAME = hashedName;\n        _HASHED_VERSION = hashedVersion;\n    }\n\n    /**\n     * @dev Returns the domain separator for the current chain.\n     */\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        return _buildDomainSeparator(_TYPE_HASH, _EIP712NameHash(), _EIP712VersionHash());\n    }\n\n    function _buildDomainSeparator(\n        bytes32 typeHash,\n        bytes32 nameHash,\n        bytes32 versionHash\n    ) private view returns (bytes32) {\n        return keccak256(abi.encode(typeHash, nameHash, versionHash, block.chainid, address(this)));\n    }\n\n    /**\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\n     * function returns the hash of the fully encoded EIP712 message for this domain.\n     *\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\n     *\n     * ```solidity\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\n     *     keccak256(\"Mail(address to,string contents)\"),\n     *     mailTo,\n     *     keccak256(bytes(mailContents))\n     * )));\n     * address signer = ECDSA.recover(digest, signature);\n     * ```\n     */\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return ECDSAUpgradeable.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n\n    /**\n     * @dev The hash of the name parameter for the EIP712 domain.\n     *\n     * NOTE: This function reads from storage by default, but can be redefined to return a constant value if gas costs\n     * are a concern.\n     */\n    function _EIP712NameHash() internal virtual view returns (bytes32) {\n        return _HASHED_NAME;\n    }\n\n    /**\n     * @dev The hash of the version parameter for the EIP712 domain.\n     *\n     * NOTE: This function reads from storage by default, but can be redefined to return a constant value if gas costs\n     * are a concern.\n     */\n    function _EIP712VersionHash() internal virtual view returns (bytes32) {\n        return _HASHED_VERSION;\n    }\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/cryptography/ECDSAUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSAUpgradeable {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV\n    }\n\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert(\"ECDSA: invalid signature\");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert(\"ECDSA: invalid signature length\");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert(\"ECDSA: invalid signature 's' value\");\n        } else if (error == RecoverError.InvalidSignatureV) {\n            revert(\"ECDSA: invalid signature 'v' value\");\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature` or error string. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        // Check the signature length\n        // - case 65: r,s,v signature (standard)\n        // - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else if (signature.length == 64) {\n            bytes32 r;\n            bytes32 vs;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            assembly {\n                r := mload(add(signature, 0x20))\n                vs := mload(add(signature, 0x40))\n            }\n            return tryRecover(hash, r, vs);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address, RecoverError) {\n        bytes32 s;\n        uint8 v;\n        assembly {\n            s := and(vs, 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\n            v := add(shr(255, vs), 27)\n        }\n        return tryRecover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     *\n     * _Available since v4.2._\n     */\n    function recover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n        if (v != 27 && v != 28) {\n            return (address(0), RecoverError.InvalidSignatureV);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n\n        return (signer, RecoverError.NoError);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Typed Data, created from a\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\n     * to the one signed with the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _setOwner(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _setOwner(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _setOwner(newOwner);\n    }\n\n    function _setOwner(address newOwner) private {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/Clones.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\n * deploying minimal proxy contracts, also known as \"clones\".\n *\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\n *\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\n * deterministic method.\n *\n * _Available since v3.4._\n */\nlibrary Clones {\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create opcode, which should never revert.\n     */\n    function clone(address implementation) internal returns (address instance) {\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            instance := create(0, ptr, 0x37)\n        }\n        require(instance != address(0), \"ERC1167: create failed\");\n    }\n\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\n     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\n     * the clones cannot be deployed twice at the same address.\n     */\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            instance := create2(0, ptr, 0x37, salt)\n        }\n        require(instance != address(0), \"ERC1167: create2 failed\");\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(\n        address implementation,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf3ff00000000000000000000000000000000)\n            mstore(add(ptr, 0x38), shl(0x60, deployer))\n            mstore(add(ptr, 0x4c), salt)\n            mstore(add(ptr, 0x6c), keccak256(ptr, 0x37))\n            predicted := keccak256(add(ptr, 0x37), 0x55)\n        }\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(address implementation, bytes32 salt)\n        internal\n        view\n        returns (address predicted)\n    {\n        return predictDeterministicAddress(implementation, salt, address(this));\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    bool private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Modifier to protect an initializer function from being invoked twice.\n     */\n    modifier initializer() {\n        require(_initializing || !_initialized, \"Initializable: contract is already initialized\");\n\n        bool isTopLevelCall = !_initializing;\n        if (isTopLevelCall) {\n            _initializing = true;\n            _initialized = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            _initializing = false;\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\n        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\n        unchecked {\n            _approve(sender, _msgSender(), currentAllowance - amount);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        uint256 senderBalance = _balances[sender];\n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[sender] = senderBalance - amount;\n        }\n        _balances[recipient] += amount;\n\n        emit Transfer(sender, recipient, amount);\n\n        _afterTokenTransfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/draft-ERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./draft-IERC20Permit.sol\";\nimport \"../ERC20.sol\";\nimport \"../../../utils/cryptography/draft-EIP712.sol\";\nimport \"../../../utils/cryptography/ECDSA.sol\";\nimport \"../../../utils/Counters.sol\";\n\n/**\n * @dev Implementation of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on `{IERC20-approve}`, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * _Available since v3.4._\n */\nabstract contract ERC20Permit is ERC20, IERC20Permit, EIP712 {\n    using Counters for Counters.Counter;\n\n    mapping(address => Counters.Counter) private _nonces;\n\n    // solhint-disable-next-line var-name-mixedcase\n    bytes32 private immutable _PERMIT_TYPEHASH =\n        keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n\n    /**\n     * @dev Initializes the {EIP712} domain separator using the `name` parameter, and setting `version` to `\"1\"`.\n     *\n     * It's a good idea to use the same `name` that is defined as the ERC20 token name.\n     */\n    constructor(string memory name) EIP712(name, \"1\") {}\n\n    /**\n     * @dev See {IERC20Permit-permit}.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual override {\n        require(block.timestamp <= deadline, \"ERC20Permit: expired deadline\");\n\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\n\n        bytes32 hash = _hashTypedDataV4(structHash);\n\n        address signer = ECDSA.recover(hash, v, r, s);\n        require(signer == owner, \"ERC20Permit: invalid signature\");\n\n        _approve(owner, spender, value);\n    }\n\n    /**\n     * @dev See {IERC20Permit-nonces}.\n     */\n    function nonces(address owner) public view virtual override returns (uint256) {\n        return _nonces[owner].current();\n    }\n\n    /**\n     * @dev See {IERC20Permit-DOMAIN_SEPARATOR}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view override returns (bytes32) {\n        return _domainSeparatorV4();\n    }\n\n    /**\n     * @dev \"Consume a nonce\": return the current value and increment.\n     *\n     * _Available since v4.1._\n     */\n    function _useNonce(address owner) internal virtual returns (uint256 current) {\n        Counters.Counter storage nonce = _nonces[owner];\n        current = nonce.current();\n        nonce.increment();\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Counters.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n */\nlibrary Counters {\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        unchecked {\n            counter._value += 1;\n        }\n    }\n\n    function decrement(Counter storage counter) internal {\n        uint256 value = counter._value;\n        require(value > 0, \"Counter: decrement overflow\");\n        unchecked {\n            counter._value = value - 1;\n        }\n    }\n\n    function reset(Counter storage counter) internal {\n        counter._value = 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/draft-EIP712.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./ECDSA.sol\";\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\n *\n * The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,\n * thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding\n * they need in their contracts using a combination of `abi.encode` and `keccak256`.\n *\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\n * ({_hashTypedDataV4}).\n *\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\n * the chain id to protect against replay attacks on an eventual fork of the chain.\n *\n * NOTE: This contract implements the version of the encoding known as \"v4\", as implemented by the JSON RPC method\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\n *\n * _Available since v3.4._\n */\nabstract contract EIP712 {\n    /* solhint-disable var-name-mixedcase */\n    // Cache the domain separator as an immutable value, but also store the chain id that it corresponds to, in order to\n    // invalidate the cached domain separator if the chain id changes.\n    bytes32 private immutable _CACHED_DOMAIN_SEPARATOR;\n    uint256 private immutable _CACHED_CHAIN_ID;\n\n    bytes32 private immutable _HASHED_NAME;\n    bytes32 private immutable _HASHED_VERSION;\n    bytes32 private immutable _TYPE_HASH;\n\n    /* solhint-enable var-name-mixedcase */\n\n    /**\n     * @dev Initializes the domain separator and parameter caches.\n     *\n     * The meaning of `name` and `version` is specified in\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\n     *\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\n     * - `version`: the current major version of the signing domain.\n     *\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\n     * contract upgrade].\n     */\n    constructor(string memory name, string memory version) {\n        bytes32 hashedName = keccak256(bytes(name));\n        bytes32 hashedVersion = keccak256(bytes(version));\n        bytes32 typeHash = keccak256(\n            \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n        );\n        _HASHED_NAME = hashedName;\n        _HASHED_VERSION = hashedVersion;\n        _CACHED_CHAIN_ID = block.chainid;\n        _CACHED_DOMAIN_SEPARATOR = _buildDomainSeparator(typeHash, hashedName, hashedVersion);\n        _TYPE_HASH = typeHash;\n    }\n\n    /**\n     * @dev Returns the domain separator for the current chain.\n     */\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        if (block.chainid == _CACHED_CHAIN_ID) {\n            return _CACHED_DOMAIN_SEPARATOR;\n        } else {\n            return _buildDomainSeparator(_TYPE_HASH, _HASHED_NAME, _HASHED_VERSION);\n        }\n    }\n\n    function _buildDomainSeparator(\n        bytes32 typeHash,\n        bytes32 nameHash,\n        bytes32 versionHash\n    ) private view returns (bytes32) {\n        return keccak256(abi.encode(typeHash, nameHash, versionHash, block.chainid, address(this)));\n    }\n\n    /**\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\n     * function returns the hash of the fully encoded EIP712 message for this domain.\n     *\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\n     *\n     * ```solidity\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\n     *     keccak256(\"Mail(address to,string contents)\"),\n     *     mailTo,\n     *     keccak256(bytes(mailContents))\n     * )));\n     * address signer = ECDSA.recover(digest, signature);\n     * ```\n     */\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return ECDSA.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/ECDSA.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV\n    }\n\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert(\"ECDSA: invalid signature\");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert(\"ECDSA: invalid signature length\");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert(\"ECDSA: invalid signature 's' value\");\n        } else if (error == RecoverError.InvalidSignatureV) {\n            revert(\"ECDSA: invalid signature 'v' value\");\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature` or error string. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        // Check the signature length\n        // - case 65: r,s,v signature (standard)\n        // - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else if (signature.length == 64) {\n            bytes32 r;\n            bytes32 vs;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            assembly {\n                r := mload(add(signature, 0x20))\n                vs := mload(add(signature, 0x40))\n            }\n            return tryRecover(hash, r, vs);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address, RecoverError) {\n        bytes32 s;\n        uint8 v;\n        assembly {\n            s := and(vs, 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\n            v := add(shr(255, vs), 27)\n        }\n        return tryRecover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     *\n     * _Available since v4.2._\n     */\n    function recover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n        if (v != 27 && v != 28) {\n            return (address(0), RecoverError.InvalidSignatureV);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n\n        return (signer, RecoverError.NoError);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Typed Data, created from a\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\n     * to the one signed with the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n    }\n}\n"
    },
    "@uniswap/v3-core/contracts/interfaces/callback/IUniswapV3SwapCallback.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Callback for IUniswapV3PoolActions#swap\n/// @notice Any contract that calls IUniswapV3PoolActions#swap must implement this interface\ninterface IUniswapV3SwapCallback {\n    /// @notice Called to `msg.sender` after executing a swap via IUniswapV3Pool#swap.\n    /// @dev In the implementation you must pay the pool tokens owed for the swap.\n    /// The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory.\n    /// amount0Delta and amount1Delta can both be 0 if no tokens were swapped.\n    /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by\n    /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.\n    /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by\n    /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.\n    /// @param data Any data passed through by the caller via the IUniswapV3PoolActions#swap call\n    function uniswapV3SwapCallback(\n        int256 amount0Delta,\n        int256 amount1Delta,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@uniswap/v3-periphery/contracts/interfaces/ISwapRouter.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.7.5;\npragma abicoder v2;\n\nimport '@uniswap/v3-core/contracts/interfaces/callback/IUniswapV3SwapCallback.sol';\n\n/// @title Router token swapping functionality\n/// @notice Functions for swapping tokens via Uniswap V3\ninterface ISwapRouter is IUniswapV3SwapCallback {\n    struct ExactInputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    /// @notice Swaps `amountIn` of one token for as much as possible of another token\n    /// @param params The parameters necessary for the swap, encoded as `ExactInputSingleParams` in calldata\n    /// @return amountOut The amount of the received token\n    function exactInputSingle(ExactInputSingleParams calldata params) external payable returns (uint256 amountOut);\n\n    struct ExactInputParams {\n        bytes path;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n    }\n\n    /// @notice Swaps `amountIn` of one token for as much as possible of another along the specified path\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactInputParams` in calldata\n    /// @return amountOut The amount of the received token\n    function exactInput(ExactInputParams calldata params) external payable returns (uint256 amountOut);\n\n    struct ExactOutputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    /// @notice Swaps as little as possible of one token for `amountOut` of another token\n    /// @param params The parameters necessary for the swap, encoded as `ExactOutputSingleParams` in calldata\n    /// @return amountIn The amount of the input token\n    function exactOutputSingle(ExactOutputSingleParams calldata params) external payable returns (uint256 amountIn);\n\n    struct ExactOutputParams {\n        bytes path;\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n    }\n\n    /// @notice Swaps as little as possible of one token for `amountOut` of another along the specified path (reversed)\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactOutputParams` in calldata\n    /// @return amountIn The amount of the input token\n    function exactOutput(ExactOutputParams calldata params) external payable returns (uint256 amountIn);\n}\n"
    },
    "contracts/helpers/Faucet.sol": {
      "content": "// SPDX-FileCopyrightText: 2021 Tenderize <info@tenderize.me>\n\n// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/**\n * @title Faucet for the Tokens\n */\ncontract TokenFaucet is Ownable {\n    // Token\n    ERC20 public token;\n\n    // Amount of token sent to sender for a request\n    uint256 public requestAmount;\n\n    // Amount of time a sender must wait between requests\n    uint256 public requestWait;\n\n    // sender => timestamp at which sender can make another request\n    mapping(address => uint256) public nextValidRequest;\n\n    // Whitelist addresses that can bypass faucet request rate limit\n    mapping(address => bool) public isWhitelisted;\n\n    // Checks if a request is valid (sender is whitelisted or has waited the rate limit time)\n    modifier validRequest() {\n        require(isWhitelisted[msg.sender] || block.timestamp >= nextValidRequest[msg.sender]);\n        _;\n    }\n\n    event Request(address indexed to, uint256 amount);\n\n    /**\n     * @notice Facuet constructor\n     * @param _token Address of Token\n     * @param _requestAmount Amount of token sent to sender for a request\n     * @param _requestWait Amount of time a sender must wait between request (denominated in hours)\n     */\n    constructor(\n        address _token,\n        uint256 _requestAmount,\n        uint256 _requestWait\n    ) public {\n        token = ERC20(_token);\n        requestAmount = _requestAmount;\n        requestWait = _requestWait;\n    }\n\n    /**\n     * @notice Add an address to the whitelist\n     * @param _addr Address to be whitelisted\n     */\n    function addToWhitelist(address _addr) external onlyOwner {\n        isWhitelisted[_addr] = true;\n    }\n\n    /**\n     * @notice Remove an address from the whitelist\n     * @param _addr Address to be removed from whitelist\n     */\n    function removeFromWhitelist(address _addr) external onlyOwner {\n        isWhitelisted[_addr] = false;\n    }\n\n    /**\n     * @notice Request an amount of token to be sent to sender\n     */\n    function request() external validRequest {\n        if (!isWhitelisted[msg.sender]) {\n            nextValidRequest[msg.sender] = block.timestamp + requestWait * 1 hours;\n        }\n\n        token.transfer(msg.sender, requestAmount);\n\n        emit Request(msg.sender, requestAmount);\n    }\n}\n"
    },
    "contracts/helpers/Multicall.sol": {
      "content": "// SPDX-FileCopyrightText: 2021 Tenderize <info@tenderize.me>\n\n// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\ninterface IMulticall {\n    /// @notice Call multiple functions in the current contract and return the data from all of them if they all succeed\n    /// @dev The `msg.value` should not be trusted for any method callable from multicall.\n    /// @param _data The encoded function data for each of the calls to make to this contract\n    /// @return results The results from each of the calls passed in via data\n    function multicall(bytes[] calldata _data) external payable returns (bytes[] memory results);\n}\n\n/// @title Multicall\n/// @notice Enables calling multiple methods in a single call to the contract\nabstract contract Multicall is IMulticall {\n    /// @inheritdoc IMulticall\n    function multicall(bytes[] calldata _data) external payable override returns (bytes[] memory results) {\n        results = new bytes[](_data.length);\n        for (uint256 i = 0; i < _data.length; i++) {\n            (bool success, bytes memory result) = address(this).delegatecall(_data[i]);\n\n            if (!success) {\n                // Next 5 lines from https://ethereum.stackexchange.com/a/83577\n                if (result.length < 68) revert();\n                assembly {\n                    result := add(result, 0x04)\n                }\n                revert(abi.decode(result, (string)));\n            }\n\n            results[i] = result;\n        }\n    }\n}\n"
    },
    "contracts/helpers/Registry.sol": {
      "content": "// SPDX-FileCopyrightText: 2021 Tenderize <info@tenderize.me>\n\n// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/**\n * @title Registry for regsitering contracts on Subgraph\n * @notice Event emiited is used to register contracts on the subgraph,\n * after deployment from which events can be tracked.\n */\ncontract Registry is Ownable {\n    struct TenderizerConfig {\n        string name; // Same name to be used while configuring frontend\n        address steak;\n        address tenderizer;\n        address tenderToken;\n        address tenderSwap;\n        address tenderFarm;\n    }\n\n    event TenderizerCreated(TenderizerConfig config);\n\n    /**\n     * @param config contract addresses of deployment\n     * @dev This is not called from a contract/factory but directly from the deployment script.\n     */\n    function addTenderizer(TenderizerConfig calldata config) external onlyOwner {\n        emit TenderizerCreated(config);\n    }\n}\n"
    },
    "contracts/helpers/SelfPermit.sol": {
      "content": "// SPDX-FileCopyrightText: 2021 Tenderize <info@tenderize.me>\n\n// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol\";\n\n/// @title Self Permit\n/// @notice Functionality to call permit on any EIP-2612-compliant token for use in the route\ninterface ISelfPermit {\n    /// @notice Permits this contract to spend a given token from `msg.sender`\n    /// @dev The `owner` is always msg.sender and the `spender` is always address(this).\n    /// @param _token The address of the token spent\n    /// @param _value The amount that can be spent of token\n    /// @param _deadline A timestamp, the current blocktime must be less than or equal to this timestamp\n    /// @param _v Must produce valid secp256k1 signature from the holder along with `r` and `s`\n    /// @param _r Must produce valid secp256k1 signature from the holder along with `v` and `s`\n    /// @param _s Must produce valid secp256k1 signature from the holder along with `r` and `v`\n    function selfPermit(\n        address _token,\n        uint256 _value,\n        uint256 _deadline,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    ) external payable;\n\n    /// @notice Permits this contract to spend a given token from `msg.sender`\n    /// @dev The `owner` is always msg.sender and the `spender` is always address(this).\n    /// Can be used instead of #selfPermit to prevent calls from failing due to a frontrun of a call to #selfPermit\n    /// @param _token The address of the token spent\n    /// @param _value The amount that can be spent of token\n    /// @param _deadline A timestamp, the current blocktime must be less than or equal to this timestamp\n    /// @param _v Must produce valid secp256k1 signature from the holder along with `r` and `s`\n    /// @param _r Must produce valid secp256k1 signature from the holder along with `v` and `s`\n    /// @param _s Must produce valid secp256k1 signature from the holder along with `r` and `v`\n    function selfPermitIfNecessary(\n        address _token,\n        uint256 _value,\n        uint256 _deadline,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    ) external payable;\n}\n\nabstract contract SelfPermit is ISelfPermit {\n    /// @inheritdoc ISelfPermit\n    function selfPermit(\n        address _token,\n        uint256 _value,\n        uint256 _deadline,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    ) public payable override {\n        IERC20Permit(_token).permit(msg.sender, address(this), _value, _deadline, _v, _r, _s);\n    }\n\n    /// @inheritdoc ISelfPermit\n    function selfPermitIfNecessary(\n        address _token,\n        uint256 _value,\n        uint256 _deadline,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    ) external payable override {\n        uint256 allowance = IERC20(_token).allowance(msg.sender, address(this));\n        if (allowance < _value) selfPermit(_token, _value - allowance, _deadline, _v, _r, _s);\n    }\n}\n"
    },
    "contracts/interfaces/ISwapRouter.sol": {
      "content": "// SPDX-FileCopyrightText: 2021 Tenderize <info@tenderize.me>\n\n// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport \"@uniswap/v3-periphery/contracts/interfaces/ISwapRouter.sol\";\n\ninterface ISwapRouterWithWETH is ISwapRouter {\n    function WETH9() external returns (address);\n}\n"
    },
    "contracts/interfaces/IWETH.sol": {
      "content": "// SPDX-FileCopyrightText: 2021 Tenderize <info@tenderize.me>\n\n// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IWETH is IERC20 {\n    function deposit() external payable;\n}\n"
    },
    "contracts/libs/MathUtils.sol": {
      "content": "// SPDX-FileCopyrightText: 2021 Tenderize <info@tenderize.me>\n\n// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nlibrary MathUtils {\n    // Divisor used for representing percentages\n    uint256 public constant PERC_DIVISOR = 10**21;\n\n    /**\n     * @dev Returns whether an amount is a valid percentage out of PERC_DIVISOR\n     * @param _amount Amount that is supposed to be a percentage\n     */\n    function validPerc(uint256 _amount) internal pure returns (bool) {\n        return _amount <= PERC_DIVISOR;\n    }\n\n    /**\n     * @dev Compute percentage of a value with the percentage represented by a fraction\n     * @param _amount Amount to take the percentage of\n     * @param _fracNum Numerator of fraction representing the percentage\n     * @param _fracDenom Denominator of fraction representing the percentage\n     */\n    function percOf(\n        uint256 _amount,\n        uint256 _fracNum,\n        uint256 _fracDenom\n    ) internal pure returns (uint256) {\n        return (_amount * percPoints(_fracNum, _fracDenom)) / PERC_DIVISOR;\n    }\n\n    /**\n     * @dev Compute percentage of a value with the percentage represented by a fraction over PERC_DIVISOR\n     * @param _amount Amount to take the percentage of\n     * @param _fracNum Numerator of fraction representing the percentage with PERC_DIVISOR as the denominator\n     */\n    function percOf(uint256 _amount, uint256 _fracNum) internal pure returns (uint256) {\n        return (_amount * _fracNum) / PERC_DIVISOR;\n    }\n\n    /**\n     * @dev Compute percentage representation of a fraction\n     * @param _fracNum Numerator of fraction represeting the percentage\n     * @param _fracDenom Denominator of fraction represeting the percentage\n     */\n    function percPoints(uint256 _fracNum, uint256 _fracDenom) internal pure returns (uint256) {\n        return (_fracNum * PERC_DIVISOR) / _fracDenom;\n    }\n\n    /**\n     * @notice Compares a and b and returns true if the difference between a and b\n     *         is less than 1 or equal to each other.\n     * @param a uint256 to compare with\n     * @param b uint256 to compare with\n     * @return True if the difference between a and b is less than 1 or equal,\n     *         otherwise return false\n     */\n    function within1(uint256 a, uint256 b) internal pure returns (bool) {\n        return (difference(a, b) <= 1);\n    }\n\n    /**\n     * @notice Calculates absolute difference between a and b\n     * @param a uint256 to compare with\n     * @param b uint256 to compare with\n     * @return Difference between a and b\n     */\n    function difference(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a > b) {\n            return a - b;\n        }\n        return b - a;\n    }\n}\n"
    },
    "contracts/tenderfarm/ITenderFarm.sol": {
      "content": "// SPDX-FileCopyrightText: 2021 Tenderize <info@tenderize.me>\n\n// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"../token/ITenderToken.sol\";\nimport \"../tenderizer/ITenderizer.sol\";\n\n/**\n * @title TenderFarm\n * @notice TenderFarm is responsible for incetivizing liquidity providers, by accepting LP Tokens\n * and a proportionaly rewarding them with TenderTokens over time.\n */\ninterface ITenderFarm {\n    /**\n     * @notice Farm gets emitted when an account stakes LP tokens.\n     * @param account the account for which LP tokens were staked\n     * @param amount the amount of LP tokens staked\n     */\n    event Farm(address indexed account, uint256 amount);\n\n    /**\n     * @notice Unfarm gets emitted when an account unstakes LP tokens.\n     * @param account the account for which LP tokens were unstaked\n     * @param amount the amount of LP tokens unstaked\n     */\n    event Unfarm(address indexed account, uint256 amount);\n\n    /**\n     * @notice Harvest gets emitted when an accounts harvests outstanding\n     * rewards.\n     * @param account the account which harvested rewards\n     * @param amount the amount of rewards harvested\n     */\n    event Harvest(address indexed account, uint256 amount);\n\n    /**\n     * @notice RewardsAdded gets emitted when new rewards are added\n     * and a new epoch begins\n     * @param amount amount of rewards that were addedd\n     */\n    event RewardsAdded(uint256 amount);\n\n    function initialize(\n        IERC20 _stakeToken,\n        ITenderToken _rewardToken,\n        ITenderizer _tenderizer\n    ) external returns (bool);\n\n    /**\n     * @notice stake liquidity pool tokens to receive rewards\n     * @dev '_amount' needs to be approved for the 'TenderFarm' to transfer.\n     * @dev harvests current rewards before accounting updates are made.\n     * @param _amount amount of liquidity pool tokens to stake\n     */\n    function farm(uint256 _amount) external;\n\n    /**\n     * @notice allow spending token and stake liquidity pool tokens to receive rewards\n     * @dev '_amount' needs to be approved for the 'TenderFarm' to transfer.\n     * @dev harvests current rewards before accounting updates are made.\n     * @dev calls permit on LP Token.\n     * @param _amount amount of liquidity pool tokens to stake\n     * @param _deadline deadline of the permit\n     * @param _v v of signed Permit message\n     * @param _r r of signed Permit message\n     * @param _s s of signed Permit message\n     */\n    function farmWithPermit(\n        uint256 _amount,\n        uint256 _deadline,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    ) external;\n\n    /**\n     * @notice stake liquidity pool tokens for a specific account so that it receives rewards\n     * @dev '_amount' needs to be approved for the 'TenderFarm' to transfer.\n     * @dev staked tokens will belong to the account they are staked for.\n     * @dev harvests current rewards before accounting updates are made.\n     * @param _for account to stake for\n     * @param _amount amount of liquidity pool tokens to stake\n     */\n    function farmFor(address _for, uint256 _amount) external;\n\n    /**\n     * @notice unstake liquidity pool tokens\n     * @dev '_amount' needs to be approved for the 'TenderFarm' to transfer.\n     * @dev harvests current rewards before accounting updates are made.\n     * @param amount amount of liquidity pool tokens to stake\n     */\n    function unfarm(uint256 amount) external;\n\n    /**\n     * @notice harvest outstanding rewards\n     * @dev reverts when trying to harvest multiple times if no new rewards have been added.\n     * @dev emits an event with how many reward tokens have been harvested.\n     */\n    function harvest() external;\n\n    /**\n     * @notice add new rewards\n     * @dev will 'start' a new 'epoch'.\n     * @dev only callable by owner.\n     * @param _amount amount of reward tokens to add\n     */\n    function addRewards(uint256 _amount) external;\n\n    /**\n     * @notice Check available rewards for an account.\n     * @param _for address address of the account to check rewards for.\n     * @return amount rewards for the provided account address.\n     */\n    function availableRewards(address _for) external view returns (uint256 amount);\n\n    /**\n     * @notice Check stake for an account.\n     * @param _of address address of the account to check stake for.\n     * @return amount LP tokens deposited for address\n     */\n    function stakeOf(address _of) external view returns (uint256 amount);\n\n    /**\n     * @notice Return the total amount of LP tokens staked in this farm.\n     * @return stake total amount of LP tokens staked\n     */\n    function totalStake() external view returns (uint256 stake);\n\n    /**\n     * @notice Return the total amount of LP tokens staked\n     * for the next reward epoch.\n     * @return nextStake LP Tokens staked for next round\n     */\n    function nextTotalStake() external view returns (uint256 nextStake);\n\n    /**\n     * @notice Changes the tenderizer of the contract\n     * @param _tenderizer address of the new tenderizer\n     */\n    function setTenderizer(ITenderizer _tenderizer) external;\n}\n"
    },
    "contracts/tenderfarm/TenderFarm.sol": {
      "content": "// SPDX-FileCopyrightText: 2021 Tenderize <info@tenderize.me>\n\n// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n\nimport \"../libs/MathUtils.sol\";\nimport \"../token/ITenderToken.sol\";\nimport \"./ITenderFarm.sol\";\nimport \"../tenderizer/ITenderizer.sol\";\nimport \"../helpers/SelfPermit.sol\";\n\n/**\n * @title TenderFarm\n * @notice TenderFarm is responsible for incetivizing liquidity providers, by accepting LP Tokens\n * and a proportionaly rewarding them with TenderTokens over time.\n */\ncontract TenderFarm is Initializable, ITenderFarm, SelfPermit {\n    /**\n     * @dev LP token.\n     */\n    IERC20 public token;\n\n    /**\n     * @dev Tender token.\n     */\n    ITenderToken public rewardToken;\n\n    /**\n     * @dev tenderizer.\n     */\n    ITenderizer public tenderizer;\n\n    /// @inheritdoc ITenderFarm\n    uint256 public override totalStake;\n\n    /// @inheritdoc ITenderFarm\n    uint256 public override nextTotalStake;\n\n    /**\n     * @dev Cumulative reward factor\n     */\n    uint256 public CRF;\n\n    struct Stake {\n        uint256 stake;\n        uint256 lastCRF;\n    }\n\n    /**\n     * @dev stake mapping of each address\n     */\n    mapping(address => Stake) public stakes;\n\n    function initialize(\n        IERC20 _stakeToken,\n        ITenderToken _rewardToken,\n        ITenderizer _tenderizer\n    ) external override initializer returns (bool) {\n        token = _stakeToken;\n        rewardToken = _rewardToken;\n        tenderizer = _tenderizer;\n\n        return true;\n    }\n\n    modifier onlyTenderizer() {\n        require(msg.sender == address(tenderizer));\n        _;\n    }\n\n    /// @inheritdoc ITenderFarm\n    function farm(uint256 _amount) external override {\n        _farmFor(msg.sender, _amount);\n    }\n\n    /// @inheritdoc ITenderFarm\n    function farmWithPermit(\n        uint256 _amount,\n        uint256 _deadline,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    ) external override {\n        selfPermit(address(token), _amount, _deadline, _v, _r, _s);\n        _farmFor(msg.sender, _amount);\n    }\n\n    /// @inheritdoc ITenderFarm\n    function farmFor(address _for, uint256 _amount) external override {\n        _farmFor(_for, _amount);\n    }\n\n    /// @inheritdoc ITenderFarm\n    function unfarm(uint256 _amount) external override {\n        _unfarm(msg.sender, _amount);\n    }\n\n    /// @inheritdoc ITenderFarm\n    function harvest() external override {\n        _harvest(msg.sender);\n    }\n\n    /// @inheritdoc ITenderFarm\n    function addRewards(uint256 _amount) external override onlyTenderizer {\n        uint256 _nextStake = nextTotalStake;\n        require(_nextStake > 0, \"NO_STAKE\");\n        totalStake = _nextStake;\n        uint256 shares = rewardToken.tokensToShares(_amount);\n        CRF += MathUtils.percPoints(shares, _nextStake);\n        require(rewardToken.transferFrom(msg.sender, address(this), _amount), \"TRANSFER_FAILED\");\n        emit RewardsAdded(_amount);\n    }\n\n    /// @inheritdoc ITenderFarm\n    function availableRewards(address _for) external view override returns (uint256) {\n        return rewardToken.sharesToTokens(_availableRewardShares(_for));\n    }\n\n    /// @inheritdoc ITenderFarm\n    function stakeOf(address _of) external view override returns (uint256) {\n        return _stakeOf(_of);\n    }\n\n    // INTERNAL FUNCTIONS\n\n    function _farmFor(address _for, uint256 _amount) internal {\n        _harvest(_for);\n\n        stakes[_for].stake += _amount;\n        nextTotalStake += _amount;\n\n        require(token.transferFrom(msg.sender, address(this), _amount), \"TRANSFERFROM_FAIL\");\n\n        emit Farm(_for, _amount);\n    }\n\n    function _unfarm(address _for, uint256 _amount) internal {\n        Stake storage _stake = stakes[_for];\n        require(_amount <= _stake.stake, \"AMOUNT_EXCEEDS_STAKE\");\n\n        _harvest(_for);\n\n        _stake.stake -= _amount;\n        nextTotalStake -= _amount;\n\n        require(token.transfer(_for, _amount), \"TRANSFER_FAIL\");\n        emit Unfarm(_for, _amount);\n    }\n\n    function _harvest(address _for) internal {\n        Stake storage _stake = stakes[_for];\n\n        // Calculate available rewards\n        uint256 rewards = _availableRewardShares(_for);\n\n        // Checkpoint CRF\n        _stake.lastCRF = CRF;\n\n        if (rewards > 0) {\n            uint256 rewardTokens = rewardToken.sharesToTokens(rewards);\n            require(rewardToken.transfer(_for, rewardTokens), \"TRANSFER_FAIL\");\n            emit Harvest(_for, rewardTokens);\n        }\n    }\n\n    function _availableRewardShares(address _for) internal view returns (uint256) {\n        Stake storage _stake = stakes[_for];\n\n        if (CRF == 0) return 0;\n\n        return MathUtils.percOf(_stake.stake, CRF - _stake.lastCRF);\n    }\n\n    function _stakeOf(address _of) internal view returns (uint256) {\n        return stakes[_of].stake;\n    }\n\n    function setTenderizer(ITenderizer _tenderizer) external override onlyTenderizer {\n        tenderizer = _tenderizer;\n    }\n}\n"
    },
    "contracts/tenderfarm/TenderFarmFactory.sol": {
      "content": "// SPDX-FileCopyrightText: 2021 Tenderize <info@tenderize.me>\n\n// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport \"./ITenderFarm.sol\";\nimport \"../token/ITenderToken.sol\";\nimport \"../tenderizer/ITenderizer.sol\";\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/proxy/Clones.sol\";\n\ncontract TenderFarmFactory {\n    ITenderFarm immutable farmTarget;\n\n    constructor(ITenderFarm _farm) {\n        farmTarget = _farm;\n    }\n\n    event NewTenderFarm(ITenderFarm farm, IERC20 stakeToken, ITenderToken rewardToken, ITenderizer tenderizer);\n\n    function deploy(\n        IERC20 _stakeToken,\n        ITenderToken _rewardToken,\n        ITenderizer _tenderizer\n    ) external returns (ITenderFarm farm) {\n        farm = ITenderFarm(Clones.clone(address(farmTarget)));\n\n        require(farm.initialize(_stakeToken, _rewardToken, _tenderizer), \"FAIL_INIT_TENDERFARM\");\n\n        emit NewTenderFarm(farm, _stakeToken, _rewardToken, _tenderizer);\n    }\n}\n"
    },
    "contracts/tenderizer/integrations/audius/Audius.sol": {
      "content": "// SPDX-FileCopyrightText: 2021 Tenderize <info@tenderize.me>\n\n// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"../../../libs/MathUtils.sol\";\nimport \"../../Tenderizer.sol\";\nimport \"../../WithdrawalPools.sol\";\nimport \"./IAudius.sol\";\n\nimport { ITenderSwapFactory } from \"../../../tenderswap/TenderSwapFactory.sol\";\n\ncontract Audius is Tenderizer {\n    using WithdrawalPools for WithdrawalPools.Pool;\n    using SafeERC20 for IERC20;\n    // Eventws for WithdrawalPool\n    event ProcessUnstakes(address indexed from, address indexed node, uint256 amount);\n    event ProcessWithdraws(address indexed from, uint256 amount);\n\n    IAudius audius;\n\n    address audiusStaking;\n\n    WithdrawalPools.Pool withdrawPool;\n\n    function initialize(\n        IERC20 _steak,\n        string calldata _symbol,\n        IAudius _audius,\n        address _node,\n        uint256 _protocolFee,\n        uint256 _liquidityFee,\n        ITenderToken _tenderTokenTarget,\n        TenderFarmFactory _tenderFarmFactory,\n        ITenderSwapFactory _tenderSwapFactory\n    ) external {\n        Tenderizer._initialize(\n            _steak,\n            _symbol,\n            _node,\n            _protocolFee,\n            _liquidityFee,\n            _tenderTokenTarget,\n            _tenderFarmFactory,\n            _tenderSwapFactory\n        );\n        audius = _audius;\n        audiusStaking = audius.getStakingAddress();\n    }\n\n    function _deposit(address _from, uint256 _amount) internal override {\n        currentPrincipal += _amount;\n\n        emit Deposit(_from, _amount);\n    }\n\n    function _stake(uint256 _amount) internal override {\n        // Only stake available tokens that are not pending withdrawal\n        uint256 amount = _amount;\n        uint256 pendingWithdrawals = withdrawPool.getAmount();\n\n        if (amount <= pendingWithdrawals) {\n            return;\n        }\n\n        amount -= pendingWithdrawals;\n\n        // Approve amount to Audius protocol\n        steak.safeIncreaseAllowance(audiusStaking, amount);\n\n        // stake tokens\n        uint256 totalNewStake = audius.delegateStake(node, amount);\n        assert(totalNewStake >= amount);\n\n        emit Stake(node, amount);\n    }\n\n    function _unstake(\n        address _account,\n        address _node,\n        uint256 _amount\n    ) internal override returns (uint256 unstakeLockID) {\n        uint256 amount = _amount;\n\n        unstakeLockID = withdrawPool.unlock(_account, amount);\n\n        emit Unstake(_account, _node, amount, unstakeLockID);\n    }\n\n    function processUnstake() external onlyGov {\n        uint256 amount = withdrawPool.processUnlocks();\n\n        address node_ = node;\n\n        // Undelegate from audius\n        audius.requestUndelegateStake(node_, amount);\n\n        emit ProcessUnstakes(msg.sender, node_, amount);\n    }\n\n    function _withdraw(address _account, uint256 _withdrawalID) internal override {\n        uint256 amount = withdrawPool.withdraw(_withdrawalID, _account);\n        // Transfer amount from unbondingLock to _account\n        steak.safeTransfer(_account, amount);\n\n        emit Withdraw(_account, amount, _withdrawalID);\n    }\n\n    function processWithdraw(address /*_node*/) external onlyGov {\n        uint256 balBefore = steak.balanceOf(address(this));\n\n        audius.undelegateStake();\n\n        uint256 balAfter = steak.balanceOf(address(this));\n        uint256 amount = balAfter - balBefore;\n\n        withdrawPool.processWihdrawal(amount);\n\n        emit ProcessWithdraws(msg.sender, amount);\n    }\n\n    function _claimRewards() internal override {\n        // Process the rewards for the nodes that we have staked to\n        try audius.claimRewards(node) {} catch {}\n\n        Tenderizer._claimRewards();\n    }\n\n    function _claimSecondaryRewards() internal override {}\n\n    function _processNewStake() internal override returns (int256 rewards) {\n        uint256 currentPrincipal_ = currentPrincipal;\n\n        // adjust current token balance for potential protocol specific taxes or staking fees\n        uint256 currentBal = _calcDepositOut(steak.balanceOf(address(this)));\n\n        // Get the new total delegator stake\n        uint256 stake = audius.getTotalDelegatorStake(address(this));\n\n        // calculate what the new currentPrinciple would be excluding\n        // pending unlocks and pending user withdrawals\n        stake = stake + currentBal - withdrawPool.amount - withdrawPool.pendingUnlock;\n\n        rewards = int256(stake) - int256(currentPrincipal_);\n\n        // Difference is negative, slash withdrawalpool\n        if (rewards < 0) {\n            // calculate amount to subtract relative to current principal\n            uint256 unstakePoolTokens = withdrawPool.totalTokens();\n            uint256 totalTokens = unstakePoolTokens + currentPrincipal_;\n            if (totalTokens > 0) {\n                uint256 unstakePoolSlash = ((currentPrincipal_ - stake) * unstakePoolTokens) / totalTokens;\n                withdrawPool.updateTotalTokens(unstakePoolTokens - unstakePoolSlash);\n            }\n        }\n\n        emit RewardsClaimed(rewards, stake, currentPrincipal_);\n    }\n\n    function _setStakingContract(address _stakingContract) internal override {\n        emit GovernanceUpdate(GovernanceParameter.STAKING_CONTRACT, abi.encode(audius), abi.encode(_stakingContract));\n        audius = IAudius(_stakingContract);\n        audiusStaking = audius.getStakingAddress();\n    }\n}\n"
    },
    "contracts/tenderizer/integrations/audius/IAudius.sol": {
      "content": "// SPDX-FileCopyrightText: 2021 Tenderize <info@tenderize.me>\n\n// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\ninterface IAudius {\n    /**\n     * @notice Get total delegation from a given address\n     * @param _delegator - delegator address\n     */\n    function getTotalDelegatorStake(address _delegator) external view returns (uint256);\n\n    /**\n     * @notice Allow a delegator to delegate stake to a service provider\n     * @param _targetSP - address of service provider to delegate to\n     * @param _amount - amount in wei to delegate\n     * @return Updated total amount delegated to the service provider by delegator\n     */\n    function delegateStake(address _targetSP, uint256 _amount) external returns (uint256);\n\n    /**\n     * @notice Submit request for undelegation\n     * @param _target - address of service provider to undelegate stake from\n     * @param _amount - amount in wei to undelegate\n     * @return Updated total amount delegated to the service provider by delegator\n     */\n    function requestUndelegateStake(address _target, uint256 _amount) external returns (uint256);\n\n    /**\n     * @notice Cancel undelegation request\n     */\n    function cancelUndelegateStakeRequest() external;\n\n    /**\n     * @notice Finalize undelegation request and withdraw stake\n     * @return New total amount currently staked after stake has been undelegated\n     */\n    function undelegateStake() external returns (uint256);\n\n    /**\n     * @notice Claim and distribute rewards to delegators and service provider as necessary\n     * @param _serviceProvider - Provider for which rewards are being distributed\n     * @dev Factors in service provider rewards from delegator and transfers deployer cut\n     */\n    function claimRewards(address _serviceProvider) external;\n\n    /// @notice Get the Staking address\n    function getStakingAddress() external view returns (address);\n}\n"
    },
    "contracts/tenderizer/integrations/graph/Graph.sol": {
      "content": "// SPDX-FileCopyrightText: 2021 Tenderize <info@tenderize.me>\n\n// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"../../../libs/MathUtils.sol\";\n\nimport \"../../Tenderizer.sol\";\nimport \"../../WithdrawalPools.sol\";\nimport \"./IGraph.sol\";\n\nimport { ITenderSwapFactory } from \"../../../tenderswap/TenderSwapFactory.sol\";\n\ncontract Graph is Tenderizer {\n    using WithdrawalPools for WithdrawalPools.Pool;\n    using SafeERC20 for IERC20;\n\n    // Eventws for WithdrawalPool\n    event ProcessUnstakes(address indexed from, address indexed node, uint256 amount);\n    event ProcessWithdraws(address indexed from, uint256 amount);\n\n    // 100% in parts per million\n    uint32 private constant MAX_PPM = 1000000;\n\n    IGraph graph;\n\n    WithdrawalPools.Pool withdrawPool;\n\n    uint256 pendingMigration;\n\n    address newNode;\n\n    function initialize(\n        IERC20 _steak,\n        string calldata _symbol,\n        IGraph _graph,\n        address _node,\n        uint256 _protocolFee,\n        uint256 _liquidityFee,\n        ITenderToken _tenderTokenTarget,\n        TenderFarmFactory _tenderFarmFactory,\n        ITenderSwapFactory _tenderSwapFactory\n    ) external {\n        Tenderizer._initialize(\n            _steak,\n            _symbol,\n            _node,\n            _protocolFee,\n            _liquidityFee,\n            _tenderTokenTarget,\n            _tenderFarmFactory,\n            _tenderSwapFactory\n        );\n        graph = _graph;\n    }\n\n    function migrateUnlock(address _newNode) external virtual onlyGov returns (uint256 lockID) {\n        uint256 amount = _tokensToMigrate(node);\n\n        // Check that there's no pending migration\n        require(pendingMigration == 0, \"PENDING_MIGRATION\");\n\n        // store penging migration amount & new node\n        pendingMigration = amount;\n        newNode = _newNode;\n\n        // set new node\n        lockID = _unstake(address(this), node, amount);\n    }\n\n    function migrateWithdraw(uint256 _unstakeLockID) external virtual onlyGov {\n        // reset pending migration amount\n        pendingMigration = 0;\n        _withdraw(address(this), _unstakeLockID);\n        _claimRewards();\n    }\n\n    function _calcDepositOut(uint256 _amountIn) internal view override returns (uint256) {\n        return _amountIn - ((uint256(graph.delegationTaxPercentage()) * _amountIn) / MAX_PPM);\n    }\n\n    function _deposit(address _from, uint256 _amount) internal override {\n        currentPrincipal += _calcDepositOut(_amount);\n\n        emit Deposit(_from, _amount);\n    }\n\n    function _stake(uint256 _amount) internal override {\n        // Only stake available tokens that are not pending withdrawal\n        uint256 amount = _amount;\n        uint256 pendingWithdrawals = withdrawPool.getAmount();\n\n        // This check also validates 'amount - pendingWithdrawals' > 0\n        if (amount <= pendingWithdrawals) {\n            return;\n        }\n\n        amount -= pendingWithdrawals;\n\n        // approve amount to Graph protocol\n        steak.safeIncreaseAllowance(address(graph), amount);\n\n        // stake tokens\n        uint256 delegatedShares = graph.delegate(node, amount);\n        assert(delegatedShares > 0);\n\n        emit Stake(node, amount);\n    }\n\n    function _unstake(\n        address _account,\n        address _node,\n        uint256 _amount\n    ) internal override returns (uint256 unstakeLockID) {\n        uint256 amount = _amount;\n        unstakeLockID = withdrawPool.unlock(_account, amount);\n        emit Unstake(_account, _node, amount, unstakeLockID);\n    }\n\n    function processUnstake() external onlyGov {\n        uint256 amount = withdrawPool.processUnlocks();\n\n        // Calculate the amount of shares to undelegate\n        IGraph.DelegationPool memory delPool = graph.delegationPools(node);\n        uint256 totalShares = delPool.shares;\n        uint256 totalTokens = delPool.tokens;\n\n        uint256 shares = (amount * totalShares) / totalTokens;\n\n        // Check that calculated shares doesn't exceed actual shares owned\n        // account of round-off error resulting in calculating 1 share less\n        IGraph.Delegation memory delegation = graph.getDelegation(node, address(this));\n        if (shares >= delegation.shares - 1) {\n            shares = delegation.shares;\n        }\n\n        // Shares =  amount * totalShares / totalTokens\n        // undelegate shares\n        graph.undelegate(node, shares);\n\n        emit ProcessUnstakes(msg.sender, node, amount);\n\n        if(newNode != address(0)){\n            node = newNode;\n            newNode = address(0);\n        }\n    }\n\n    function _withdraw(address _account, uint256 _withdrawalID) internal override {\n        uint256 amount = withdrawPool.withdraw(_withdrawalID, _account);\n\n        // Transfer amount from unbondingLock to _account\n        try steak.transfer(_account, amount) {} catch {\n            // Account for roundoff errors in shares calculations\n            uint256 steakBal = steak.balanceOf(address(this));\n            if (amount > steakBal) {\n                steak.safeTransfer(_account, steakBal);\n            }\n        }\n\n        emit Withdraw(_account, amount, _withdrawalID);\n    }\n\n    function processWithdraw(address _node) external onlyGov {\n        uint256 balBefore = steak.balanceOf(address(this));\n\n        graph.withdrawDelegated(_node, address(0));\n\n        uint256 balAfter = steak.balanceOf(address(this));\n        uint256 amount = balAfter - balBefore;\n\n        withdrawPool.processWihdrawal(amount);\n\n        emit ProcessWithdraws(msg.sender, amount);\n    }\n\n    function _claimSecondaryRewards() internal override {}\n\n    function _processNewStake() internal override returns (int256 rewards) {\n        uint256 stake = _tokensDelegated(node);\n\n        uint256 currentPrincipal_ = currentPrincipal;\n\n        // exclude tokens to be withdrawn from balance\n        // add pendingMigration amount\n        uint256 stakeRemainder = _calcDepositOut(\n            steak.balanceOf(address(this)) - withdrawPool.amount + pendingMigration\n        );\n\n        // calculate what the new currentPrinciple would be\n        // exclude pendingUnlocks from stake\n        stake = (stake - withdrawPool.pendingUnlock) + stakeRemainder;\n\n        rewards = int256(stake) - int256(currentPrincipal_);\n\n        // Difference is negative, slash withdrawalpool\n        if (rewards < 0) {\n            // calculate amount to subtract relative to current principal\n            uint256 unstakePoolTokens = withdrawPool.totalTokens();\n            uint256 totalTokens = unstakePoolTokens + currentPrincipal_;\n            if (totalTokens > 0) {\n                uint256 unstakePoolSlash = ((currentPrincipal_ - stake) * unstakePoolTokens) / totalTokens;\n                withdrawPool.updateTotalTokens(unstakePoolTokens - unstakePoolSlash);\n            }\n        }\n\n        emit RewardsClaimed(rewards, stake, currentPrincipal_);\n    }\n\n    function _tokensDelegated(address _node) internal view returns (uint256) {\n        IGraph.Delegation memory delegation = graph.getDelegation(_node, address(this));\n        IGraph.DelegationPool memory delPool = graph.delegationPools(_node);\n\n        uint256 delShares = delegation.shares;\n        uint256 totalShares = delPool.shares;\n        uint256 totalTokens = delPool.tokens;\n\n        if (totalShares == 0) return 0;\n\n        return (delShares * totalTokens) / totalShares;\n    }\n\n    function _tokensToMigrate(address _node) internal view override returns (uint256) {\n        return _tokensDelegated(_node) - withdrawPool.pendingUnlock;\n    }\n\n    function _setStakingContract(address _stakingContract) internal override {\n        emit GovernanceUpdate(GovernanceParameter.STAKING_CONTRACT, abi.encode(graph), abi.encode(_stakingContract));\n        graph = IGraph(_stakingContract);\n    }\n}\n"
    },
    "contracts/tenderizer/integrations/graph/IGraph.sol": {
      "content": "// SPDX-FileCopyrightText: 2021 Tenderize <info@tenderize.me>\n\n// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\ninterface IGraph {\n    // -- Delegation Data --\n\n    /**\n     * @dev Delegation pool information. One per indexer.\n     */\n    struct DelegationPool {\n        uint32 cooldownBlocks; // Blocks to wait before updating parameters\n        uint32 indexingRewardCut; // in PPM\n        uint32 queryFeeCut; // in PPM\n        uint256 updatedAtBlock; // Block when the pool was last updated\n        uint256 tokens; // Total tokens as pool reserves\n        uint256 shares; // Total shares minted in the pool\n        // mapping(address => Delegation) delegators; // Mapping of delegator => Delegation\n    }\n\n    /**\n     * @dev Individual delegation data of a delegator in a pool.\n     */\n    struct Delegation {\n        uint256 shares; // Shares owned by a delegator in the pool\n        uint256 tokensLocked; // Tokens locked for undelegation\n        uint256 tokensLockedUntil; // Block when locked tokens can be withdrawn\n    }\n\n    function delegate(address _indexer, uint256 _tokens) external returns (uint256);\n\n    function undelegate(address _indexer, uint256 _shares) external returns (uint256);\n\n    function withdrawDelegated(address _indexer, address _newIndexer) external returns (uint256);\n\n    function getDelegation(address _indexer, address _delegator) external view returns (Delegation memory);\n\n    function delegationPools(address _indexer) external view returns (DelegationPool memory);\n\n    function getWithdraweableDelegatedTokens(Delegation memory _delegation) external view returns (uint256);\n\n    function thawingPeriod() external view returns (uint256);\n\n    function delegationTaxPercentage() external view returns (uint32);\n}\n"
    },
    "contracts/tenderizer/integrations/livepeer/ILivepeer.sol": {
      "content": "// SPDX-FileCopyrightText: 2021 Tenderize <info@tenderize.me>\n\n// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\ninterface ILivepeer {\n    function bond(uint256 _amount, address _to) external;\n\n    function unbond(uint256 _amount) external;\n\n    function withdrawStake(uint256 _unbondingLockId) external;\n\n    function withdrawFees(address payable, uint256) external;\n\n    function pendingFees(address _delegator, uint256 _endRound) external view returns (uint256);\n\n    function pendingStake(address _delegator, uint256 _endRound) external view returns (uint256);\n\n    function getDelegator(address _delegator)\n        external\n        view\n        returns (\n            uint256 bondedAmount,\n            uint256 fees,\n            address delegateAddress,\n            uint256 delegatedAmount,\n            uint256 startRound,\n            uint256 lastClaimRound,\n            uint256 nextUnbondingLockId\n        );\n}\n"
    },
    "contracts/tenderizer/integrations/livepeer/Livepeer.sol": {
      "content": "// SPDX-FileCopyrightText: 2021 Tenderize <info@tenderize.me>\n\n// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"../../../libs/MathUtils.sol\";\n\nimport \"../../Tenderizer.sol\";\nimport \"./ILivepeer.sol\";\n\nimport \"../../WithdrawalLocks.sol\";\n\nimport \"../../../interfaces/IWETH.sol\";\nimport \"../../../interfaces/ISwapRouter.sol\";\n\nimport { ITenderSwapFactory } from \"../../../tenderswap/TenderSwapFactory.sol\";\n\ncontract Livepeer is Tenderizer {\n    using WithdrawalLocks for WithdrawalLocks.Locks;\n    using SafeERC20 for IERC20;\n    using SafeERC20 for IWETH;\n\n    uint256 private constant MAX_ROUND = 2**256 - 1;\n\n    IWETH private WETH;\n    ISwapRouterWithWETH public uniswapRouter;\n    uint24 private constant UNISWAP_POOL_FEE = 10000;\n\n    ILivepeer livepeer;\n\n    WithdrawalLocks.Locks withdrawLocks;\n\n    function initialize(\n        IERC20 _steak,\n        string calldata _symbol,\n        ILivepeer _livepeer,\n        address _node,\n        uint256 _protocolFee,\n        uint256 _liquidityFee,\n        ITenderToken _tenderTokenTarget,\n        TenderFarmFactory _tenderFarmFactory,\n        ITenderSwapFactory _tenderSwapFactory\n    ) external {\n        Tenderizer._initialize(\n            _steak,\n            _symbol,\n            _node,\n            _protocolFee,\n            _liquidityFee,\n            _tenderTokenTarget,\n            _tenderFarmFactory,\n            _tenderSwapFactory\n        );\n        livepeer = _livepeer;\n    }\n\n    function migrateStake(address _newNode) external onlyGov {\n        node = _newNode;\n        livepeer.bond(0, _newNode);\n        _claimRewards();\n    }\n\n    function _deposit(address _from, uint256 _amount) internal override {\n        currentPrincipal += _amount;\n\n        emit Deposit(_from, _amount);\n    }\n\n    function _stake(uint256 _amount) internal override {\n        uint256 amount = _amount;\n\n        if (amount == 0) {\n            return;\n        }\n\n        // approve amount to Livepeer protocol\n        steak.safeIncreaseAllowance(address(livepeer), amount);\n\n        // stake tokens\n        livepeer.bond(amount, node);\n\n        emit Stake(node, amount);\n    }\n\n    function _unstake(\n        address _account,\n        address _node,\n        uint256 _amount\n    ) internal override returns (uint256 withdrawalLockID) {\n        uint256 amount = _amount;\n\n        // Unbond tokens\n        livepeer.unbond(amount);\n\n        // Manage Livepeer unbonding locks\n        withdrawalLockID = withdrawLocks.unlock(_account, amount);\n\n        emit Unstake(_account, _node, amount, withdrawalLockID);\n    }\n\n    function _withdraw(address _account, uint256 _withdrawalID) internal override {\n        uint256 amount = withdrawLocks.withdraw(_account, _withdrawalID);\n\n        // Withdraw stake, transfers steak tokens to address(this)\n        livepeer.withdrawStake(_withdrawalID);\n\n        // Transfer amount from unbondingLock to _account\n        steak.safeTransfer(_account, amount);\n\n        emit Withdraw(_account, amount, _withdrawalID);\n    }\n\n    function _processNewStake() internal override returns (int256 rewards) {\n        uint256 stake = livepeer.pendingStake(address(this), MAX_ROUND);\n        uint256 currentPrincipal_ = currentPrincipal;\n        // adjust current token balance for potential protocol specific taxes or staking fees\n        uint256 currentBal = _calcDepositOut(steak.balanceOf(address(this)));\n\n        // calculate the new total stake\n        stake += currentBal;\n\n        rewards = int256(stake) - int256(currentPrincipal_);\n\n        emit RewardsClaimed(rewards, stake, currentPrincipal_);\n    }\n\n    /**\n     * @notice claims secondary rewards\n     * these are rewards that are not from staking\n     * but from fees that do not directly accumulate\n     * towards stake. These could either be liquid\n     * underlying tokens, or other tokens that then\n     * need to be swapped using a DEX.\n     * Secondary claimed fees will be immeadiatly\n     * added to the balance of this contract\n     * @dev this is implementation specific\n     */\n    function _claimSecondaryRewards() internal override {\n        uint256 ethFees = livepeer.pendingFees(address(this), MAX_ROUND);\n        // First claim any fees that are not underlying tokens\n        // withdraw fees\n        if (ethFees > 0) {\n            livepeer.withdrawFees(payable(address(this)), ethFees);\n\n            // Wrap ETH\n            uint256 bal = address(this).balance;\n            WETH.deposit{ value: bal }();\n            WETH.safeIncreaseAllowance(address(uniswapRouter), bal);\n\n            // swap ETH fees for LPT\n            if (address(uniswapRouter) != address(0)) {\n                uint256 amountOutMin = 0; // TODO: set slippage tolerance\n                ISwapRouter.ExactInputSingleParams memory params = ISwapRouter.ExactInputSingleParams({\n                    tokenIn: address(WETH),\n                    tokenOut: address(steak),\n                    fee: UNISWAP_POOL_FEE,\n                    recipient: address(this),\n                    deadline: block.timestamp,\n                    amountIn: bal,\n                    amountOutMinimum: amountOutMin, // TODO: Set5% max slippage\n                    sqrtPriceLimitX96: 0\n                });\n                try uniswapRouter.exactInputSingle(params) returns (uint256 _swappedLPT) {\n                    assert(_swappedLPT > amountOutMin);\n                } catch {\n                    // fail silently so claiming secondary rewards doesn't block compounding primary rewards\n                }\n            }\n        }\n    }\n\n    function _setStakingContract(address _stakingContract) internal override {\n        emit GovernanceUpdate(GovernanceParameter.STAKING_CONTRACT, abi.encode(livepeer), abi.encode(_stakingContract));\n        livepeer = ILivepeer(_stakingContract);\n    }\n\n    function setUniswapRouter(address _uniswapRouter) external onlyGov {\n        uniswapRouter = ISwapRouterWithWETH(_uniswapRouter);\n        WETH = IWETH(uniswapRouter.WETH9());\n    }\n}\n"
    },
    "contracts/tenderizer/integrations/matic/IMatic.sol": {
      "content": "// SPDX-FileCopyrightText: 2021 Tenderize <info@tenderize.me>\n\n// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nstruct DelegatorUnbond {\n    uint256 shares;\n    uint256 withdrawEpoch;\n}\n\n// note this contract interface is only for stakeManager use\ninterface IMatic {\n    function owner() external view returns (address);\n\n    function restake() external;\n\n    function buyVoucher(uint256 _amount, uint256 _minSharesToMint) external;\n\n    function sellVoucher_new(uint256 claimAmount, uint256 maximumSharesToBurn) external;\n\n    function unstakeClaimTokens_new(uint256 unbondNonce) external;\n\n    function exchangeRate() external view returns (uint256);\n\n    function validatorId() external view returns (uint256);\n\n    function balanceOf(address) external view returns (uint256);\n\n    function unbondNonces(address) external view returns (uint256);\n\n    function withdrawExchangeRate() external view returns (uint256);\n\n    function unbonds_new(address, uint256) external view returns (DelegatorUnbond memory);\n}\n"
    },
    "contracts/tenderizer/integrations/matic/Matic.sol": {
      "content": "// SPDX-FileCopyrightText: 2021 Tenderize <info@tenderize.me>\n\n// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"../../../libs/MathUtils.sol\";\n\nimport \"../../Tenderizer.sol\";\nimport \"./IMatic.sol\";\n\nimport \"../../WithdrawalLocks.sol\";\n\nimport { ITenderSwapFactory } from \"../../../tenderswap/TenderSwapFactory.sol\";\n\nuint256 constant WITHDRAW_LOCK_START = 2; // Starting point for withdraw lock IDs\n\ncontract Matic is Tenderizer {\n    using WithdrawalLocks for WithdrawalLocks.Locks;\n    using SafeERC20 for IERC20;\n\n    // Matic exchange rate precision\n    uint256 constant EXCHANGE_RATE_PRECISION = 100; // For Validator ID < 8\n    uint256 constant EXCHANGE_RATE_PRECISION_HIGH = 10**29; // For Validator ID >= 8\n\n    // Matic stakeManager address\n    address maticStakeManager;\n\n    // Matic ValidatorShare\n    IMatic matic;\n\n    WithdrawalLocks.Locks withdrawLocks;\n\n    function initialize(\n        IERC20 _steak,\n        string calldata _symbol,\n        address _matic,\n        address _node,\n        uint256 _protocolFee,\n        uint256 _liquidityFee,\n        ITenderToken _tenderTokenTarget,\n        TenderFarmFactory _tenderFarmFactory,\n        ITenderSwapFactory _tenderSwapFactory\n    ) external {\n        Tenderizer._initialize(\n            _steak,\n            _symbol,\n            _node,\n            _protocolFee,\n            _liquidityFee,\n            _tenderTokenTarget,\n            _tenderFarmFactory,\n            _tenderSwapFactory\n        );\n        maticStakeManager = _matic;\n        matic = IMatic(_node);\n        withdrawLocks.initialize(WITHDRAW_LOCK_START);\n    }\n\n    function setNode(address _node) external override onlyGov {\n        require(_node != address(0), \"ZERO_ADDRESS\");\n        emit GovernanceUpdate(GovernanceParameter.NODE, abi.encode(node), abi.encode(_node));\n        node = _node;\n        matic = IMatic(_node);\n    }\n\n    function setWithdrawLockStart(uint256 _startID) external onlyGov {\n        withdrawLocks.initialize(_startID);\n    }\n\n    function _deposit(address _from, uint256 _amount) internal override {\n        currentPrincipal += _amount;\n\n        emit Deposit(_from, _amount);\n    }\n\n    function _stake(uint256 _amount) internal override {\n        uint256 amount = _amount;\n\n        if (amount == 0) {\n            return;\n        }\n\n        // approve tokens\n        steak.safeIncreaseAllowance(maticStakeManager, amount);\n\n        // stake tokens\n        uint256 min = ((amount * _getExchangeRatePrecision(matic)) / _getExchangeRate(matic)) - 1;\n        matic.buyVoucher(amount, min);\n\n        emit Stake(address(matic), amount);\n    }\n\n    function _unstake(\n        address _account,\n        address _node,\n        uint256 _amount\n    ) internal override returns (uint256 withdrawalLockID) {\n        uint256 amount = _amount;\n\n        // use validator share contract for matic\n        IMatic matic_ = IMatic(_node);\n\n        uint256 exhangeRatePrecision = _getExchangeRatePrecision(matic_);\n        uint256 fxRate = _getExchangeRate(matic_);\n\n        // Unbond tokens\n        uint256 max = ((amount * exhangeRatePrecision) / fxRate) + 1;\n        matic_.sellVoucher_new(amount, max);\n\n        // Manage Matic unbonding locks\n        withdrawalLockID = withdrawLocks.unlock(_account, amount);\n\n        emit Unstake(_account, address(matic_), amount, withdrawalLockID);\n    }\n\n    function _withdraw(address _account, uint256 _withdrawalID) internal override {\n        withdrawLocks.withdraw(_account, _withdrawalID);\n\n        // Check for any slashes during undelegation\n        uint256 balBefore = steak.balanceOf(address(this));\n        // Matic locks start at one, see commit 31f410a3feb63ce58a617356185a332e50504402\n        // This change allows one outstanding lock to still be claimed after this commit\n        matic.unstakeClaimTokens_new(_withdrawalID == 0 ? 1 : _withdrawalID);\n        uint256 balAfter = steak.balanceOf(address(this));\n        require(balAfter >= balBefore, \"ZERO_AMOUNT\");\n        uint256 amount = balAfter - balBefore;\n\n        // Transfer undelegated amount to _account\n        steak.safeTransfer(_account, amount);\n\n        emit Withdraw(_account, amount, _withdrawalID);\n    }\n\n    function _claimRewards() internal override {\n        // restake to compound rewards\n        try matic.restake() {} catch {}\n\n        Tenderizer._claimRewards();\n    }\n\n    function _claimSecondaryRewards() internal override {}\n\n    function _processNewStake() internal override returns (int256 rewards) {\n        uint256 shares = matic.balanceOf(address(this));\n        uint256 stake = (shares * _getExchangeRate(matic)) / _getExchangeRatePrecision(matic);\n\n        uint256 currentPrincipal_ = currentPrincipal;\n        // adjust current token balance for potential protocol specific taxes or staking fees\n        uint256 currentBal = _calcDepositOut(steak.balanceOf(address(this)));\n\n        // calculate the new total stake\n        stake += currentBal;\n\n        rewards = int256(stake) - int256(currentPrincipal_);\n\n        emit RewardsClaimed(rewards, stake, currentPrincipal_);\n    }\n\n    function _setStakingContract(address _stakingContract) internal override {\n        emit GovernanceUpdate(\n            GovernanceParameter.STAKING_CONTRACT,\n            abi.encode(maticStakeManager),\n            abi.encode(_stakingContract)\n        );\n        maticStakeManager = _stakingContract;\n    }\n\n    function _getExchangeRatePrecision(IMatic _matic) internal view returns (uint256) {\n        return _matic.validatorId() < 8 ? EXCHANGE_RATE_PRECISION : EXCHANGE_RATE_PRECISION_HIGH;\n    }\n\n    function _getExchangeRate(IMatic _matic) internal view returns (uint256) {\n        uint256 rate = _matic.exchangeRate();\n        return rate == 0 ? 1 : rate;\n    }\n}\n"
    },
    "contracts/tenderizer/ITenderizer.sol": {
      "content": "// SPDX-FileCopyrightText: 2021 Tenderize <info@tenderize.me>\n\n// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"../tenderfarm/ITenderFarm.sol\";\n\nenum GovernanceParameter {\n    GOV,\n    NODE,\n    STEAK,\n    PROTOCOL_FEE,\n    LIQUIDITY_FEE,\n    TENDERFARM,\n    STAKING_CONTRACT\n}\n\n/**\n * @title Tenderizer is the base contract to be implemented.\n * @notice Tenderizer is responsible for all Protocol interactions (staking, unstaking, claiming rewards)\n * while also keeping track of user depsotis/withdrawals and protocol fees.\n * @dev New implementations are required to inherit this contract and override any required internal functions.\n */\ninterface ITenderizer {\n    // Events\n\n    /**\n     * @notice Deposit gets emitted when an accounts deposits underlying tokens.\n     * @param from the account that deposited\n     * @param amount the amount of tokens deposited\n     */\n    event Deposit(address indexed from, uint256 amount);\n\n    /**\n     * @notice Stake gets emitted when funds are staked/delegated from the Tenderizer contract\n     * into the underlying protocol.\n     * @param node the address the funds are staked to\n     * @param amount the amount staked\n     */\n    event Stake(address indexed node, uint256 amount);\n\n    /**\n     * @notice Unstake gets emitted when an account burns TenderTokens to unlock\n     * tokens staked through the Tenderizer\n     * @param from the account that unstaked\n     * @param node the node in the underlying token from which tokens are unstaked\n     * @param amount the amount unstaked\n     */\n    event Unstake(address indexed from, address indexed node, uint256 amount, uint256 unstakeLockID);\n\n    /**\n     * @notice Withdraw gets emitted when an account withdraws tokens that have been\n     * succesfully unstaked and thus unlocked for withdrawal.\n     * @param from the account withdrawing tokens\n     * @param amount the amount being withdrawn\n     * @param unstakeLockID the unstake lock ID being consumed\n     */\n    event Withdraw(address indexed from, uint256 amount, uint256 unstakeLockID);\n\n    /**\n     * @notice RewardsClaimed gets emitted when the Tenderizer processes staking rewards (or slashing)\n     * from the underlying protocol.\n     * @param stakeDiff the stake difference since the last event, can be negative in case slashing occured\n     * @param currentPrincipal TVL after claiming rewards\n     * @param oldPrincipal TVL before claiming rewards\n     */\n    event RewardsClaimed(int256 stakeDiff, uint256 currentPrincipal, uint256 oldPrincipal);\n\n    /**\n     * @notice ProtocolFeeCollected gets emitted when the treasury claims its outstanding\n     * protocol fees.\n     * @param amount the amount of fees claimed (in TenderTokens)\n     */\n    event ProtocolFeeCollected(uint256 amount);\n\n    /**\n     * @notice LiquidityFeeCollected gets emitted when liquidity provider fees are moved to the TenderFarm.\n     * @param amount the amount of fees moved for farming\n     */\n    event LiquidityFeeCollected(uint256 amount);\n\n    /**\n     * @notice GovernanceUpdate gets emitted when a parameter on the Tenderizer gets updated.\n     * @param param the parameter that got updated\n     * @param oldValue oldValue of the parameter\n      @param newValue newValue of the parameter\n     */\n    event GovernanceUpdate(GovernanceParameter param, bytes oldValue, bytes newValue);\n\n    /**\n     * @notice Deposit tokens in Tenderizer.\n     * @param _amount amount deposited\n     * @dev doesn't actually stakes the tokens but aggregates the balance in the tenderizer\n     * awaiting to be staked.\n     * @dev requires '_amount' to be approved by '_from'.\n     */\n    function deposit(uint256 _amount) external;\n\n    /**\n     * @notice Deposit tokens in Tenderizer with permit.\n     * @param _amount amount deposited\n     * @param _deadline deadline for the permit\n     * @param _v from ECDSA signature\n     * @param _r from ECDSA signature\n     * @param _s from ECDSA signature\n     * @dev doesn't actually stakes the tokens but aggregates the balance in the tenderizer\n     * awaiting to be staked.\n     * @dev requires '_amount' to be approved by '_from'.\n     */\n    function depositWithPermit(\n        uint256 _amount,\n        uint256 _deadline,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    ) external;\n\n    /**\n     * @notice Stake '_amount' of tokens.\n     * @param _amount amount to stake\n     * @dev Only callable by Gov.\n     */\n    function stake(uint256 _amount) external;\n\n    /**\n     * @notice Unstake '_amount' of tokens from '_account'.\n     * @param _amount amount to unstake\n     * @return unstakeLockID unstake lockID generated for unstake\n     * @dev unstake from the default address.\n     * @dev If '_amount' is 0, unstake the entire amount staked towards _account.\n     */\n    function unstake(uint256 _amount) external returns (uint256 unstakeLockID);\n\n    /**\n     * @notice RescueUnstake unstakes all tokens from underlying protocol\n     * @return unstakeLockID unstake lockID generated for unstake\n     * @dev Used to rescue all staked funds.\n     */\n    function rescueUnlock() external returns (uint256 unstakeLockID);\n\n    /**\n     * @notice Withdraw '_amount' of tokens previously unstaked by '_account'.\n     * @param _unstakeLockID ID for the lock to request the withdraw for\n     * @dev If '_amount' isn't specified all unstake tokens by '_account' will be withdrawn.\n     * @dev Requires '_account' to have unstaked prior to calling withdraw.\n     */\n    function withdraw(uint256 _unstakeLockID) external;\n\n    /**\n     * @notice RescueWithdraw withdraws all tokens into the Tenderizer from the underlying protocol\n     * after the unlock period ends\n     * @dev To be called after rescueUnlock() with the unstakeLockID returned there.\n     * @dev Process unlocks/withdrawals before rescueWithdraw for integrations with WithdrawPools.\n     */\n    function rescueWithdraw(uint256 _unstakeLockID) external;\n\n    /**\n     * @notice Compound all the rewards and new deposits.\n     * Claim staking rewards and earned fees for the underlying protocol and stake\n     * any leftover token balance. Process Tender protocol fees if revenue is positive.\n     */\n    function claimRewards() external;\n\n    /**\n     * @notice Total Staked Tokens returns the total amount of underlying tokens staked by this Tenderizer.\n     * @return totalStaked total amount staked by this Tenderizer\n     */\n    function totalStakedTokens() external view returns (uint256 totalStaked);\n\n    /**\n     * @notice Returns the number of tenderTokens to be minted for amountIn deposit.\n     * @return depositOut number of tokens staked for `amountIn`.\n     * @dev used by controller to calculate tokens to be minted before depositing.\n     * @dev to be used when there a delegation tax is deducted, for eg. in Graph.\n     */\n    function calcDepositOut(uint256 _amountIn) external returns (uint256 depositOut);\n\n    // Governance setter funtions\n\n    function setGov(address _gov) external;\n\n    function setNode(address _node) external;\n\n    function setSteak(IERC20 _steak) external;\n\n    function setProtocolFee(uint256 _protocolFee) external;\n\n    function setLiquidityFee(uint256 _liquidityFee) external;\n\n    function setStakingContract(address _stakingContract) external;\n\n    function setTenderFarm(ITenderFarm _tenderFarm) external;\n}\n"
    },
    "contracts/tenderizer/ITotalStakedReader.sol": {
      "content": "// SPDX-FileCopyrightText: 2021 Tenderize <info@tenderize.me>\n\n// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\ninterface ITotalStakedReader {\n    /**\n     * @notice Total Staked Tokens returns the total amount of underlying tokens staked by this Tenderizer.\n     * @return _totalStakedTokens total amount staked by this Tenderizer\n     */\n    function totalStakedTokens() external view returns (uint256 _totalStakedTokens);\n}\n"
    },
    "contracts/tenderizer/Tenderizer.sol": {
      "content": "// SPDX-FileCopyrightText: 2021 Tenderize <info@tenderize.me>\n\n// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport \"@openzeppelin/contracts/proxy/Clones.sol\";\nimport \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport { GovernanceParameter, ITenderizer } from \"./ITenderizer.sol\";\nimport \"../token/ITenderToken.sol\";\nimport { ITenderSwapFactory, ITenderSwap } from \"../tenderswap/TenderSwapFactory.sol\";\nimport \"../tenderfarm/TenderFarmFactory.sol\";\nimport \"../libs/MathUtils.sol\";\nimport \"../helpers/SelfPermit.sol\";\n\n/**\n * @title Tenderizer is the base contract to be implemented.\n * @notice Tenderizer is responsible for all Protocol interactions (staking, unstaking, claiming rewards)\n * while also keeping track of user depsotis/withdrawals and protocol fees.\n * @dev New implementations are required to inherit this contract and override any required internal functions.\n */\nabstract contract Tenderizer is Initializable, ITenderizer, SelfPermit {\n    using SafeERC20 for IERC20;\n\n    uint256 private constant MAX_FEE = 5 * 10**20;\n\n    IERC20 public steak;\n    ITenderToken public tenderToken;\n    ITenderFarm public tenderFarm;\n    ITenderSwap public tenderSwap;\n\n    address public node;\n\n    uint256 public protocolFee;\n    uint256 public liquidityFee;\n    uint256 public currentPrincipal; // Principal since last claiming earnings\n\n    address public gov;\n\n    modifier onlyGov() {\n        _onlyGov();\n        _;\n    }\n\n    function _initialize(\n        IERC20 _steak,\n        string memory _symbol,\n        address _node,\n        uint256 _protocolFee,\n        uint256 _liquidityFee,\n        ITenderToken _tenderTokenTarget,\n        TenderFarmFactory _tenderFarmFactory,\n        ITenderSwapFactory _tenderSwapFactory\n    ) internal initializer {\n        steak = _steak;\n        node = _node;\n        protocolFee = _protocolFee;\n        liquidityFee = _liquidityFee;\n\n        gov = msg.sender;\n\n        // Clone TenderToken\n        ITenderToken tenderToken_ = ITenderToken(Clones.clone(address(_tenderTokenTarget)));\n        string memory tenderTokenSymbol = string(abi.encodePacked(\"t\", _symbol));\n        require(tenderToken_.initialize(_symbol, _symbol, ITotalStakedReader(address(this))), \"FAIL_INIT_TENDERTOKEN\");\n        tenderToken = tenderToken_;\n\n        tenderSwap = _tenderSwapFactory.deploy(\n            ITenderSwapFactory.Config({\n                token0: IERC20(address(tenderToken_)),\n                token1: _steak,\n                lpTokenName: string(abi.encodePacked(tenderTokenSymbol, \"-\", _symbol, \" Swap Token\")),\n                lpTokenSymbol: string(abi.encodePacked(tenderTokenSymbol, \"-\", _symbol, \"-SWAP\"))\n            })\n        );\n\n        // Transfer ownership from tenderizer to deployer so params an be changed directly\n        // and no additional functions are needed on the tenderizer\n        tenderSwap.transferOwnership(msg.sender);\n\n        tenderFarm = _tenderFarmFactory.deploy(\n            IERC20(address(tenderSwap.lpToken())),\n            tenderToken_,\n            ITenderizer(address(this))\n        );\n    }\n\n    /// @inheritdoc ITenderizer\n    function deposit(uint256 _amount) external override {\n        _depositHook(msg.sender, _amount);\n    }\n\n    /// @inheritdoc ITenderizer\n    function depositWithPermit(\n        uint256 _amount,\n        uint256 _deadline,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    ) external override {\n        selfPermit(address(steak), _amount, _deadline, _v, _r, _s);\n\n        _depositHook(msg.sender, _amount);\n    }\n\n    /// @inheritdoc ITenderizer\n    function unstake(uint256 _amount) external override returns (uint256) {\n        require(_amount > 0, \"ZERO_AMOUNT\");\n\n        require(tenderToken.burn(msg.sender, _amount), \"TENDER_BURN_FAILED\");\n        // Execute state updates to pending withdrawals\n        // Unstake tokens\n        uint256 id = _unstake(msg.sender, node, _amount);\n        currentPrincipal -= _amount;\n        return id;\n    }\n\n    /// @inheritdoc ITenderizer\n    function rescueUnlock() external override onlyGov returns (uint256) {\n        return _unstake(address(this), node, _tokensToMigrate(node));\n    }\n\n    /// @inheritdoc ITenderizer\n    function withdraw(uint256 _unstakeLockID) external override {\n        // Execute state updates to pending withdrawals\n        // Transfer tokens to _account\n        _withdraw(msg.sender, _unstakeLockID);\n    }\n\n    /// @inheritdoc ITenderizer\n    function rescueWithdraw(uint256 _unstakeLockID) external override onlyGov {\n        _withdraw(address(this), _unstakeLockID);\n    }\n\n    /// @inheritdoc ITenderizer\n    function claimRewards() external override {\n        _claimRewards();\n    }\n\n    /// @inheritdoc ITenderizer\n    function totalStakedTokens() external view override returns (uint256) {\n        return _totalStakedTokens();\n    }\n\n    function _tokensToMigrate(\n        address /*_node*/\n    ) internal view virtual returns (uint256) {\n        return currentPrincipal;\n    }\n\n    /// @inheritdoc ITenderizer\n    function stake(uint256 _amount) external override onlyGov {\n        // Execute state updates\n        // approve pendingTokens for staking\n        // Stake tokens\n        _stake(_amount);\n    }\n\n    function setGov(address _gov) external virtual override onlyGov {\n        emit GovernanceUpdate(GovernanceParameter.GOV, abi.encode(gov), abi.encode(_gov));\n        gov = _gov;\n    }\n\n    function setNode(address _node) external virtual override onlyGov {\n        emit GovernanceUpdate(GovernanceParameter.NODE, abi.encode(node), abi.encode(_node));\n        node = _node;\n    }\n\n    function setSteak(IERC20 _steak) external virtual override onlyGov {\n        emit GovernanceUpdate(GovernanceParameter.STEAK, abi.encode(steak), abi.encode(_steak));\n        steak = _steak;\n    }\n\n    function setProtocolFee(uint256 _protocolFee) external virtual override onlyGov {\n        require(_protocolFee <= MAX_FEE, \"FEE_EXCEEDS_MAX\");\n        emit GovernanceUpdate(GovernanceParameter.PROTOCOL_FEE, abi.encode(protocolFee), abi.encode(_protocolFee));\n        protocolFee = _protocolFee;\n    }\n\n    function setLiquidityFee(uint256 _liquidityFee) external virtual override onlyGov {\n        require(_liquidityFee <= MAX_FEE, \"FEE_EXCEEDS_MAX\");\n        emit GovernanceUpdate(GovernanceParameter.LIQUIDITY_FEE, abi.encode(liquidityFee), abi.encode(_liquidityFee));\n        liquidityFee = _liquidityFee;\n    }\n\n    function setStakingContract(address _stakingContract) external override onlyGov {\n        _setStakingContract(_stakingContract);\n    }\n\n    function setTenderFarm(ITenderFarm _tenderFarm) external override onlyGov {\n        emit GovernanceUpdate(GovernanceParameter.TENDERFARM, abi.encode(tenderFarm), abi.encode(_tenderFarm));\n        tenderFarm = _tenderFarm;\n    }\n\n    /// @inheritdoc ITenderizer\n    function calcDepositOut(uint256 _amountIn) external view override returns (uint256) {\n        return _calcDepositOut(_amountIn);\n    }\n\n    // Internal functions\n\n    function _depositHook(address _for, uint256 _amount) internal {\n        require(_amount > 0, \"ZERO_AMOUNT\");\n\n        // Calculate tenderTokens to be minted\n        uint256 amountOut = _calcDepositOut(_amount);\n\n        // mint tenderTokens\n        require(tenderToken.mint(_for, amountOut), \"TENDER_MINT_FAILED\");\n\n        // Transfer tokens to tenderizer\n        steak.safeTransferFrom(_for, address(this), _amount);\n\n        _deposit(_for, _amount);\n    }\n\n    function _calcDepositOut(uint256 _amountIn) internal view virtual returns (uint256) {\n        return _amountIn;\n    }\n\n    function _deposit(address _account, uint256 _amount) internal virtual;\n\n    function _stake(uint256 _amount) internal virtual;\n\n    function _unstake(\n        address _account,\n        address _node,\n        uint256 _amount\n    ) internal virtual returns (uint256 unstakeLockID);\n\n    function _withdraw(address _account, uint256 _unstakeLockID) internal virtual;\n\n    function _claimRewards() internal virtual {\n        _claimSecondaryRewards();\n\n        int256 rewards = _processNewStake();\n\n        if (rewards > 0) {\n            uint256 rewards_ = uint256(rewards);\n            uint256 pFees = _calculateFees(rewards_, protocolFee);\n            uint256 lFees = _calculateFees(rewards_, liquidityFee);\n            currentPrincipal += (rewards_ - pFees - lFees);\n\n            _collectFees(pFees);\n            _collectLiquidityFees(lFees);\n        } else if (rewards < 0) {\n            uint256 rewards_ = uint256(-rewards);\n            currentPrincipal -= rewards_;\n        }\n\n        _stake(steak.balanceOf(address(this)));\n    }\n\n    function _claimSecondaryRewards() internal virtual;\n\n    function _processNewStake() internal virtual returns (int256 rewards);\n\n    function _collectFees(uint256 fees) internal virtual {\n        tenderToken.mint(gov, fees);\n        currentPrincipal += fees;\n        emit ProtocolFeeCollected(fees);\n    }\n\n    function _collectLiquidityFees(uint256 liquidityFees) internal virtual {\n        // Don't transfer liquidity provider fees if there is no liquidity being farmed\n        if (tenderFarm.nextTotalStake() <= 0) return;\n\n        uint256 balBefore = tenderToken.balanceOf(address(this));\n        tenderToken.mint(address(this), liquidityFees);\n        currentPrincipal += liquidityFees;\n        uint256 balAfter = tenderToken.balanceOf(address(this));\n        uint256 stakeDiff = balAfter - balBefore;\n        // minting sometimes generates a little less, due to share calculation\n        // hence using the balance to transfer here\n        tenderToken.approve(address(tenderFarm), stakeDiff);\n        tenderFarm.addRewards(stakeDiff);\n        emit LiquidityFeeCollected(stakeDiff);\n    }\n\n    function _calculateFees(uint256 _rewards, uint256 _feePerc) internal pure returns (uint256 fees) {\n        return MathUtils.percOf(_rewards, _feePerc);\n    }\n\n    function _totalStakedTokens() internal view virtual returns (uint256) {\n        return currentPrincipal;\n    }\n\n    function _setStakingContract(address _stakingContract) internal virtual;\n\n    function _onlyGov() internal view {\n        require(msg.sender == gov);\n    }\n}\n"
    },
    "contracts/tenderizer/WithdrawalLocks.sol": {
      "content": "// SPDX-FileCopyrightText: 2021 Tenderize <info@tenderize.me>\n\n// SPDX-License-Identifier: MIT\n\nimport \"../libs/MathUtils.sol\";\npragma solidity 0.8.4;\n\n/**\n * @notice WithdrawalLocks are used to \"proxy\" user unlocks/withdrawals to the underlying contracts\n */\nlibrary WithdrawalLocks {\n    struct WithdrawLock {\n        uint256 amount;\n        address account;\n    }\n\n    struct Locks {\n        mapping(uint256 => WithdrawLock) withdrawals;\n        uint256 nextWithdrawLockID;\n    }\n\n    function initialize(Locks storage _lock, uint256 _initialLockID) internal {\n        _lock.nextWithdrawLockID = _initialLockID;\n    }\n\n    function unlock(\n        Locks storage _lock,\n        address _receiver,\n        uint256 _amount\n    ) internal returns (uint256 withdrawalLockID) {\n        withdrawalLockID = _lock.nextWithdrawLockID;\n\n        _lock.nextWithdrawLockID = withdrawalLockID + 1;\n\n        _lock.withdrawals[withdrawalLockID] = WithdrawLock({ amount: _amount, account: _receiver });\n    }\n\n    function withdraw(\n        Locks storage _lock,\n        address _account,\n        uint256 _withdrawalLockID\n    ) internal returns (uint256 amount) {\n        WithdrawLock storage lock = _lock.withdrawals[_withdrawalLockID];\n        address account = lock.account;\n        amount = lock.amount;\n\n        require(account == _account, \"ACCOUNT_MISTMATCH\");\n\n        delete _lock.withdrawals[_withdrawalLockID];\n    }\n}\n"
    },
    "contracts/tenderizer/WithdrawalPools.sol": {
      "content": "// SPDX-FileCopyrightText: 2021 Tenderize <info@tenderize.me>\n\n// SPDX-License-Identifier: MIT\n\nimport \"../libs/MathUtils.sol\";\npragma solidity 0.8.4;\n\n/**\n * @title WithdrawalPools are used to batch user unlocks/withdrawals together\n * @notice These are used for protocols that do not support simultaneous unlocks\n */\nlibrary WithdrawalPools {\n    struct Withdrawal {\n        uint256 shares; // shares\n        address receiver; // address of the receiver of this withdrawal, usually the caller of unlock\n        uint256 epoch; // epoch at time of unlock\n    }\n\n    struct Pool {\n        mapping(uint256 => Withdrawal) withdrawals; // key,value to keep track of withdrawals\n        uint256 withdrawalID; // incrementor to keep track of the key for the 'withdrawals' mapping\n        uint256 shares; // total outstanding shares of the unstake pool\n        uint256 amount; // total amount of available tokens\n        uint256 pendingUnlock; // amount of tokens to unlock\n        uint256 pendingWithdrawal; // amount of tokens unlocked, pending withdrawal\n        uint256 epoch; // current epoch start (e.g. incrementor or block number)\n        uint256 lastEpoch; // last completed epoch (withdrawal completed)\n    }\n\n    function unlock(\n        Pool storage _pool,\n        address _receiver,\n        uint256 _amount\n    ) internal returns (uint256 withdrawalID) {\n        withdrawalID = _pool.withdrawalID;\n\n        uint256 shares = calcShares(_pool, _amount);\n\n        _pool.withdrawals[withdrawalID] = Withdrawal({ shares: shares, receiver: _receiver, epoch: _pool.epoch });\n\n        _pool.pendingUnlock += _amount;\n\n        _pool.shares += shares;\n\n        _pool.withdrawalID++;\n    }\n\n    function withdraw(\n        Pool storage _pool,\n        uint256 _withdrawalID,\n        address _account\n    ) internal returns (uint256 withdrawAmount) {\n        Withdrawal memory withdrawal = _pool.withdrawals[_withdrawalID];\n\n        require(withdrawal.epoch < _pool.lastEpoch, \"ONGOING_UNLOCK\");\n        require(_account == withdrawal.receiver, \"ACCOUNT_MISTMATCH\");\n\n        withdrawAmount = calcAmount(_pool, withdrawal.shares);\n\n        _pool.amount -= withdrawAmount;\n\n        _pool.shares -= withdrawal.shares;\n\n        delete _pool.withdrawals[_withdrawalID];\n    }\n\n    function processUnlocks(Pool storage _pool) internal returns (uint256 pendingUnlock_) {\n        require(_pool.epoch == _pool.lastEpoch, \"ONGOING_UNLOCK\");\n        _pool.pendingWithdrawal += _pool.pendingUnlock;\n        pendingUnlock_ = _pool.pendingUnlock;\n        _pool.pendingUnlock = 0;\n        _pool.epoch = block.number;\n    }\n\n    function processWihdrawal(Pool storage _pool, uint256 _received) internal {\n        require(_pool.epoch > _pool.lastEpoch, \"ONGOING_UNLOCK\");\n        _pool.amount += _received;\n        _pool.pendingWithdrawal = 0;\n        _pool.lastEpoch = _pool.epoch;\n    }\n\n    function updateTotalTokens(Pool storage _pool, uint256 _newAmount) internal {\n        // calculate relative amounts to subtract from 'amount' and 'pendingUnlock'\n        uint256 amount_ = _pool.amount;\n        uint256 pendingUnlock_ = _pool.pendingUnlock;\n        uint256 total = amount_ + pendingUnlock_;\n        if (total > 0) {\n            _pool.amount = (_newAmount * amount_) / total;\n            _pool.pendingUnlock = (_newAmount * pendingUnlock_) / total;\n        }\n    }\n\n    function totalTokens(Pool storage _pool) internal view returns (uint256) {\n        return _pool.amount + _pool.pendingUnlock + _pool.pendingWithdrawal;\n    }\n\n    function getAmount(Pool storage _pool) internal view returns (uint256) {\n        return _pool.amount;\n    }\n\n    function epoch(Pool storage _pool) internal view returns (uint256) {\n        return _pool.epoch;\n    }\n\n    function lastEpoch(Pool storage _pool) internal view returns (uint256) {\n        return _pool.lastEpoch;\n    }\n\n    function getWithdrawal(Pool storage _pool, uint256 _withdrawalID) internal view returns (Withdrawal memory) {\n        return _pool.withdrawals[_withdrawalID];\n    }\n\n    function calcShares(Pool storage _pool, uint256 _amount) internal view returns (uint256 shares) {\n        uint256 totalTokens_ = totalTokens(_pool);\n        uint256 totalShares = _pool.shares;\n\n        if (totalTokens_ == 0) return _amount;\n\n        if (totalShares == 0) return _amount;\n\n        return MathUtils.percOf(_amount, totalShares, totalTokens_);\n    }\n\n    function calcAmount(Pool storage _pool, uint256 _shares) internal view returns (uint256) {\n        uint256 totalShares = _pool.shares;\n        if (totalShares == 0) return 0;\n\n        return MathUtils.percOf(_shares, totalTokens(_pool), totalShares);\n    }\n}\n"
    },
    "contracts/tenderswap/ITenderSwap.sol": {
      "content": "// SPDX-FileCopyrightText: 2021 Tenderize <info@tenderize.me>\n\n// SPDX-License-Identifier: MIT\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"./LiquidityPoolToken.sol\";\n\npragma solidity 0.8.4;\n\n/**\n * @title TenderSwap\n * @dev TenderSwap is a light-weight StableSwap implementation for two assets.\n * See the Curve StableSwap paper for more details (https://curve.fi/files/stableswap-paper.pdf).\n * that trade 1:1 with eachother (e.g. USD stablecoins or tenderToken derivatives vs their underlying assets).\n * It supports Elastic Supply ERC20 tokens, which are tokens of which the balances can change\n * as the total supply of the token 'rebases'.\n */\n\ninterface ITenderSwap {\n    /*** EVENTS ***/\n\n    // events replicated from SwapUtils to make the ABI easier for dumb\n    // clients\n\n    /**\n     * @notice Swap gets emitted when an accounts exchanges tokens.\n     * @param buyer address of the account initiating the swap\n     * @param tokenSold address of the swapped token\n     * @param amountSold amount of tokens swapped\n     * @param amountReceived amount of tokens received in exchange\n     */\n    event Swap(address indexed buyer, IERC20 tokenSold, uint256 amountSold, uint256 amountReceived);\n\n    /**\n     * @notice AddLiquidity gets emitted when liquidity is added to the pool.\n     * @param provider address of the account providing liquidity\n     * @param tokenAmounts array of token amounts provided corresponding to pool cardinality of [token0, token1]\n     * @param fees fees deducted for each of the tokens added corresponding to pool cardinality of [token0, token1]\n     * @param invariant pool invariant after adding liquidity\n     * @param lpTokenSupply the lpToken supply after minting\n     */\n    event AddLiquidity(\n        address indexed provider,\n        uint256[2] tokenAmounts,\n        uint256[2] fees,\n        uint256 invariant,\n        uint256 lpTokenSupply\n    );\n\n    /**\n     * @notice RemoveLiquidity gets emitted when liquidity for both tokens\n     * is removed from the pool.\n     * @param provider address of the account removing liquidity\n     * @param tokenAmounts array of token amounts removed corresponding to pool cardinality of [token0, token1]\n     * @param lpTokenSupply total supply of liquidity pool token after removing liquidity\n     */\n    event RemoveLiquidity(address indexed provider, uint256[2] tokenAmounts, uint256 lpTokenSupply);\n\n    /**\n     * @notice RemoveLiquidityOne gets emitted when single-sided liquidity is removed \n     * @param provider address of the account removing liquidity\n     * @param lpTokenAmount amount of liquidity pool tokens burnt\n     * @param lpTokenSupply total supply of liquidity pool token after removing liquidity\n\n     * @param tokenReceived address of the token for which liquidity was removed\n     * @param receivedAmount amount of tokens received\n     */\n    event RemoveLiquidityOne(\n        address indexed provider,\n        uint256 lpTokenAmount,\n        uint256 lpTokenSupply,\n        IERC20 tokenReceived,\n        uint256 receivedAmount\n    );\n\n    /**\n     * @notice RemoveLiquidityImbalance gets emitted when liquidity is removed weighted differently than the\n     * pool's current balances.\n     * with different weights than that of the pool.\n     * @param provider address of the the account removing liquidity imbalanced\n     * @param tokenAmounts array of amounts of tokens being removed corresponding\n     * to pool cardinality of [token0, token1]\n     * @param fees fees for each of the tokens removed corresponding to pool cardinality of [token0, token1]\n     * @param invariant pool invariant after removing liquidity\n     * @param lpTokenSupply total supply of liquidity pool token after removing liquidity\n     */\n    event RemoveLiquidityImbalance(\n        address indexed provider,\n        uint256[2] tokenAmounts,\n        uint256[2] fees,\n        uint256 invariant,\n        uint256 lpTokenSupply\n    );\n\n    /**\n     * @notice NewAdminFee gets emitted when the admin fee is updated.\n     * @param newAdminFee admin fee after update\n     */\n    event NewAdminFee(uint256 newAdminFee);\n\n    /**\n     * @notice NewSwapFee gets emitted when the swap fee is updated.\n     * @param newSwapFee swap fee after update\n     */\n    event NewSwapFee(uint256 newSwapFee);\n\n    /**\n     * @notice RampA gets emitted when A has started ramping up.\n     * @param oldA initial A value\n     * @param newA target value of A to ramp up to\n     * @param initialTime ramp start timestamp\n     * @param futureTime ramp end timestamp\n     */\n    event RampA(uint256 oldA, uint256 newA, uint256 initialTime, uint256 futureTime);\n\n    /**\n     * @notice StopRampA gets emitted when ramping A is stopped manually\n     * @param currentA current value of A\n     * @param time timestamp of when ramp is stopped\n     */\n    event StopRampA(uint256 currentA, uint256 time);\n\n    /**\n     * @notice Initializes this Swap contract with the given parameters.\n     * This will also clone a LPToken contract that represents users'\n     * LP positions. The owner of LPToken will be this contract - which means\n     * only this contract is allowed to mint/burn tokens.\n     *\n     * @param _token0 First token in the pool\n     * @param _token1 Second token in the pool\n     * @param lpTokenName the long-form name of the token to be deployed\n     * @param lpTokenSymbol the short symbol for the token to be deployed\n     * @param _a the amplification coefficient * n * (n - 1). See the\n     * StableSwap paper for details\n     * @param _fee default swap fee to be initialized with\n     * @param _adminFee default adminFee to be initialized with\n     * @param lpTokenTargetAddress the address of an existing LiquidityPoolToken contract to use as a target\n     * @return success true is successfully initialized\n     */\n    function initialize(\n        IERC20 _token0,\n        IERC20 _token1,\n        string memory lpTokenName,\n        string memory lpTokenSymbol,\n        uint256 _a,\n        uint256 _fee,\n        uint256 _adminFee,\n        LiquidityPoolToken lpTokenTargetAddress\n    ) external returns (bool success);\n\n    /*** VIEW FUNCTIONS ***/\n    /**\n     * @notice Returns the liquidity pool token contract.\n     * @return lpTokenContract Liquidity pool token contract.\n     */\n    function lpToken() external view returns (LiquidityPoolToken lpTokenContract);\n\n    /**\n     * @notice Return A, the amplification coefficient * n * (n - 1)\n     * @dev See the StableSwap paper for details\n     * @return a the amplifaction coefficient\n     */\n    function getA() external view returns (uint256 a);\n\n    /**\n     * @notice Return A in its raw precision form\n     * @dev See the StableSwap paper for details\n     * @return aPrecise A parameter in its raw precision form\n     */\n    function getAPrecise() external view returns (uint256 aPrecise);\n\n    /**\n     * @notice Returns the contract address for token0\n     * @dev EVM return type is IERC20\n     * @return token0 contract address\n     */\n    function getToken0() external view returns (IERC20 token0);\n\n    /**\n     * @notice Returns the contract address for token1\n     * @dev EVM return type is IERC20\n     * @return token1 contract address\n     */\n    function getToken1() external view returns (IERC20 token1);\n\n    /**\n     * @notice Return current balance of token0 (tender) in the pool\n     * @return token0Balance current balance of the pooled tendertoken\n     */\n    function getToken0Balance() external view returns (uint256 token0Balance);\n\n    /**\n     * @notice Return current balance of token1 (underlying) in the pool\n     * @return token1Balance current balance of the pooled underlying token\n     */\n    function getToken1Balance() external view returns (uint256 token1Balance);\n\n    /**\n     * @notice Get the override price, to help calculate profit\n     * @return virtualPrice the override price, scaled to the POOL_PRECISION_DECIMALS\n     */\n    function getVirtualPrice() external view returns (uint256 virtualPrice);\n\n    /**\n     * @notice Calculate amount of tokens you receive on swap\n     * @param _tokenFrom the token the user wants to sell\n     * @param _dx the amount of tokens the user wants to sell. If the token charges\n     * a fee on transfers, use the amount that gets transferred after the fee.\n     * @return tokensToReceive amount of tokens the user will receive\n     */\n    function calculateSwap(IERC20 _tokenFrom, uint256 _dx) external view returns (uint256 tokensToReceive);\n\n    /**\n     * @notice A simple method to calculate amount of each underlying\n     * tokens that is returned upon burning given amount of LP tokens\n     * @param amount the amount of LP tokens that would be burned on withdrawal\n     * @return tokensToReceive array of token balances that the user will receive\n     */\n    function calculateRemoveLiquidity(uint256 amount) external view returns (uint256[2] memory tokensToReceive);\n\n    /**\n     * @notice Calculate the amount of underlying token available to withdraw\n     * when withdrawing via only single token\n     * @param tokenAmount the amount of LP token to burn\n     * @param tokenReceive the token to receive\n     * @return tokensToReceive calculated amount of underlying token to be received.\n     * available to withdraw\n     */\n    function calculateRemoveLiquidityOneToken(uint256 tokenAmount, IERC20 tokenReceive)\n        external\n        view\n        returns (uint256 tokensToReceive);\n\n    /**\n     * @notice A simple method to calculate prices from deposits or\n     * withdrawals, excluding fees but including slippage. This is\n     * helpful as an input into the various \"min\" parameters on calls\n     * to fight front-running\n     *\n     * @dev This shouldn't be used outside frontends for user estimates.\n     *\n     * @param amounts an array of token amounts to deposit or withdrawal,\n     * corresponding to pool cardinality of [token0, token1]. The amount should be in each\n     * pooled token's native precision.\n     * @param deposit whether this is a deposit or a withdrawal\n     * @return tokensToReceive token amount the user will receive\n     */\n    function calculateTokenAmount(uint256[] calldata amounts, bool deposit)\n        external\n        view\n        returns (uint256 tokensToReceive);\n\n    /*** POOL FUNCTIONALITY ***/\n\n    /**\n     * @notice Swap two tokens using this pool\n     * @dev revert is token being sold is not in the pool.\n     * @param _tokenFrom the token the user wants to sell\n     * @param _dx the amount of tokens the user wants to swap from\n     * @param _minDy the min amount the user would like to receive, or revert\n     * @param _deadline latest timestamp to accept this transaction\n     * @return _dy amount of tokens received\n     */\n    function swap(\n        IERC20 _tokenFrom,\n        uint256 _dx,\n        uint256 _minDy,\n        uint256 _deadline\n    ) external returns (uint256 _dy);\n\n    /**\n     * @notice Add liquidity to the pool with the given amounts of tokens\n     * @param _amounts the amounts of each token to add, in their native precision\n     *          according to the cardinality of the pool [token0, token1]\n     * @param _minToMint the minimum LP tokens adding this amount of liquidity\n     * should mint, otherwise revert. Handy for front-running mitigation\n     * @param _deadline latest timestamp to accept this transaction\n     * @return lpMinted amount of LP token user minted and received\n     */\n    function addLiquidity(\n        uint256[2] calldata _amounts,\n        uint256 _minToMint,\n        uint256 _deadline\n    ) external returns (uint256 lpMinted);\n\n    /**\n     * @notice Burn LP tokens to remove liquidity from the pool.\n     * @dev Liquidity can always be removed, even when the pool is paused.\n     * @param amount the amount of LP tokens to burn\n     * @param minAmounts the minimum amounts of each token in the pool\n     *        acceptable for this burn. Useful as a front-running mitigation\n     *        according to the cardinality of the pool [token0, token1]\n     * @param deadline latest timestamp to accept this transaction\n     * @return tokensReceived is the amounts of tokens user received\n     */\n    function removeLiquidity(\n        uint256 amount,\n        uint256[2] calldata minAmounts,\n        uint256 deadline\n    ) external returns (uint256[2] memory tokensReceived);\n\n    /**\n     * @notice Remove liquidity from the pool all in one token.\n     * @param _tokenAmount the amount of the token you want to receive\n     * @param _tokenReceive the  token you want to receive\n     * @param _minAmount the minimum amount to withdraw, otherwise revert\n     * @param _deadline latest timestamp to accept this transaction\n     * @return tokensReceived amount of chosen token user received\n     */\n    function removeLiquidityOneToken(\n        uint256 _tokenAmount,\n        IERC20 _tokenReceive,\n        uint256 _minAmount,\n        uint256 _deadline\n    ) external returns (uint256 tokensReceived);\n\n    /**\n     * @notice Remove liquidity from the pool, weighted differently than the\n     * pool's current balances.\n     * @param _amounts how much of each token to withdraw\n     * @param _maxBurnAmount the max LP token provider is willing to pay to\n     * remove liquidity. Useful as a front-running mitigation.\n     * @param _deadline latest timestamp to accept this transaction\n     * @return lpBurned amount of LP tokens burned\n     */\n    function removeLiquidityImbalance(\n        uint256[2] calldata _amounts,\n        uint256 _maxBurnAmount,\n        uint256 _deadline\n    ) external returns (uint256 lpBurned);\n\n    /*** ADMIN FUNCTIONALITY ***/\n    /**\n     * @notice Update the admin fee. Admin fee takes portion of the swap fee.\n     * @param newAdminFee new admin fee to be applied on future transactions\n     */\n    function setAdminFee(uint256 newAdminFee) external;\n\n    /**\n     * @notice Update the swap fee to be applied on swaps\n     * @param newSwapFee new swap fee to be applied on future transactions\n     */\n    function setSwapFee(uint256 newSwapFee) external;\n\n    /**\n     * @notice Start ramping up or down A parameter towards given futureA and futureTime\n     * Checks if the change is too rapid, and commits the new A value only when it falls under\n     * the limit range.\n     * @param futureA the new A to ramp towards\n     * @param futureTime timestamp when the new A should be reached\n     */\n    function rampA(uint256 futureA, uint256 futureTime) external;\n\n    /**\n     * @notice Stop ramping A immediately. Reverts if ramp A is already stopped.\n     */\n    function stopRampA() external;\n\n    /**\n     * @notice Changes the owner of the contract\n     * @param _newOwner address of the new owner\n     */\n    function transferOwnership(address _newOwner) external;\n}\n"
    },
    "contracts/tenderswap/LiquidityPoolToken.sol": {
      "content": "// SPDX-FileCopyrightText: 2021 Tenderize <info@tenderize.me>\n\n// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20BurnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/draft-ERC20PermitUpgradeable.sol\";\n\ncontract LiquidityPoolToken is OwnableUpgradeable, ERC20BurnableUpgradeable, ERC20PermitUpgradeable {\n    /**\n     * @notice Initializes this LPToken contract with the given name and symbol\n     * @dev The caller of this function will become the owner. A Swap contract should call this\n     * in its initializer function.\n     * @param name name of this token\n     * @param symbol symbol of this token\n     */\n    function initialize(string memory name, string memory symbol) external initializer returns (bool) {\n        __Context_init_unchained();\n        __ERC20_init_unchained(name, symbol);\n        __EIP712_init_unchained(name, \"1\");\n        __ERC20Permit_init_unchained(name);\n        __Ownable_init_unchained();\n        return true;\n    }\n\n    /**\n     * @notice Mints the given amount of LPToken to the recipient.\n     * @dev only owner can call this mint function.\n     * @param recipient address of account to receive the tokens\n     * @param amount amount of tokens to mint\n     */\n\n    function mint(address recipient, uint256 amount) external onlyOwner {\n        require(amount != 0, \"LPToken: cannot mint 0\");\n        _mint(recipient, amount);\n    }\n}\n"
    },
    "contracts/tenderswap/SwapUtils.sol": {
      "content": "// SPDX-FileCopyrightText: 2021 Tenderize <info@tenderize.me>\n\n// SPDX-License-Identifier: MIT\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"../libs/MathUtils.sol\";\nimport \"./LiquidityPoolToken.sol\";\n\npragma solidity 0.8.4;\n\nlibrary SwapUtils {\n    using MathUtils for uint256;\n    using SafeERC20 for IERC20;\n\n    // =============================================\n    //                   EVENTS\n    // =============================================\n    event Swap(address indexed buyer, IERC20 tokenSold, uint256 amountSold, uint256 amountReceived);\n    event AddLiquidity(\n        address indexed provider,\n        uint256[2] tokenAmounts,\n        uint256[2] fees,\n        uint256 invariant,\n        uint256 lpTokenSupply\n    );\n    event RemoveLiquidity(address indexed provider, uint256[2] tokenAmounts, uint256 lpTokenSupply);\n    event RemoveLiquidityOne(\n        address indexed provider,\n        uint256 lpTokenAmount,\n        uint256 lpTokenSupply,\n        IERC20 tokenReceived,\n        uint256 receivedAmount\n    );\n    event RemoveLiquidityImbalance(\n        address indexed provider,\n        uint256[2] tokenAmounts,\n        uint256[2] fees,\n        uint256 invariant,\n        uint256 lpTokenSupply\n    );\n    event NewAdminFee(uint256 newAdminFee);\n    event NewSwapFee(uint256 newSwapFee);\n\n    // =============================================\n    //                 SWAP LOGIC\n    // =============================================\n\n    // the precision all pools tokens will be converted to\n    uint8 public constant POOL_PRECISION_DECIMALS = 18;\n\n    // the denominator used to calculate admin and LP fees. For example, an\n    // LP fee might be something like tradeAmount.mul(fee).div(FEE_DENOMINATOR)\n    uint256 private constant FEE_DENOMINATOR = 10**10;\n\n    // Max swap fee is 1% or 100bps of each swap\n    uint256 public constant MAX_SWAP_FEE = 10**8;\n\n    // Max adminFee is 100% of the swapFee\n    // adminFee does not add additional fee on top of swapFee\n    // Instead it takes a certain % of the swapFee. Therefore it has no impact on the\n    // users but only on the earnings of LPs\n    uint256 public constant MAX_ADMIN_FEE = 10**10;\n\n    // Constant value used as max loop limit\n    uint256 private constant MAX_LOOP_LIMIT = 256;\n\n    uint256 internal constant NUM_TOKENS = 2;\n\n    struct FeeParams {\n        uint256 swapFee;\n        uint256 adminFee;\n    }\n\n    struct PooledToken {\n        IERC20 token;\n        uint256 precisionMultiplier;\n    }\n\n    // Struct storing variables used in calculations in the\n    // {add,remove}Liquidity functions to avoid stack too deep errors\n    struct ManageLiquidityInfo {\n        uint256 d0;\n        uint256 d1;\n        uint256 d2;\n        uint256 preciseA;\n        LiquidityPoolToken lpToken;\n        uint256 totalSupply;\n        PooledToken[2] tokens;\n        uint256[2] oldBalances;\n        uint256[2] newBalances;\n    }\n\n    // Struct storing variables used in calculations in the\n    // calculateWithdrawOneTokenDY function to avoid stack too deep errors\n    struct CalculateWithdrawOneTokenDYInfo {\n        uint256 d0;\n        uint256 d1;\n        uint256 newY;\n        uint256 feePerToken;\n        uint256 preciseA;\n    }\n\n    /**\n     * @notice swap two tokens in the pool\n     * @param tokenFrom the token to sell\n     * @param tokenTo the token to buy\n     * @param dx the number of tokens to sell\n     * @param minDy the min amount the user would like to receive (revert if not met)\n     * @param amplificationParams amplification parameters for the pool\n     * @param feeParams fee parameters for the pool\n     * @return amount of token user received on swap\n     */\n    function swap(\n        PooledToken storage tokenFrom,\n        PooledToken storage tokenTo,\n        uint256 dx,\n        uint256 minDy,\n        Amplification storage amplificationParams,\n        FeeParams storage feeParams\n    ) external returns (uint256) {\n        require(dx <= tokenFrom.token.balanceOf(msg.sender), \"ERC20: transfer amount exceeds balance\");\n        uint256 dy;\n        uint256 dyFee;\n        (dy, dyFee) = _calculateSwap(tokenFrom, tokenTo, dx, amplificationParams, feeParams);\n\n        require(dy >= minDy, \"Swap didn't result in min tokens\");\n\n        uint256 dyAdminFee = (dyFee * feeParams.adminFee) / FEE_DENOMINATOR / tokenTo.precisionMultiplier;\n        // TODO: Need to handle keeping track of admin fees or transfer them instantly\n\n        // transfer tokens\n        tokenFrom.token.safeTransferFrom(msg.sender, address(this), dx);\n        tokenTo.token.safeTransfer(msg.sender, dy);\n\n        emit Swap(msg.sender, tokenFrom.token, dx, dy);\n\n        return dy;\n    }\n\n    /**\n     * @notice Get the virtual price, to help calculate profit\n     * @param token0 token0 in the pool\n     * @param token1 token1 in the pool\n     * @param amplificationParams amplification parameters for the pool\n     * @param lpToken Liquidity pool token\n     * @return the virtual price, scaled to precision of POOL_PRECISION_DECIMALS\n     */\n    function getVirtualPrice(\n        PooledToken storage token0,\n        PooledToken storage token1,\n        Amplification storage amplificationParams,\n        LiquidityPoolToken lpToken\n    ) external view returns (uint256) {\n        uint256 xp0 = _xp(_getTokenBalance(token0.token), token0.precisionMultiplier);\n        uint256 xp1 = _xp(_getTokenBalance(token1.token), token1.precisionMultiplier);\n\n        uint256 d = getD(xp0, xp1, _getAPrecise(amplificationParams));\n        uint256 supply = lpToken.totalSupply();\n        if (supply > 0) {\n            return (d * (10**POOL_PRECISION_DECIMALS)) / supply;\n        }\n        return 0;\n    }\n\n    /**\n     * @notice Externally calculates a swap between two tokens.\n     * @param tokenFrom the token to sell\n     * @param tokenTo the token to buy\n     * @param dx the number of tokens to sell\n     * @param amplificationParams amplification parameters for the pool\n     * @param feeParams fee parameters for the pool\n     * @return dy the number of tokens the user will get\n     */\n    function calculateSwap(\n        PooledToken storage tokenFrom,\n        PooledToken storage tokenTo,\n        uint256 dx,\n        Amplification storage amplificationParams,\n        FeeParams storage feeParams\n    ) external view returns (uint256 dy) {\n        (dy, ) = _calculateSwap(tokenFrom, tokenTo, dx, amplificationParams, feeParams);\n    }\n\n    /**\n     * @notice Add liquidity to the pool\n     * @param tokens Array of [token0, token1]\n     * @param amounts the amounts of each token to add, in their native precision\n     * according to the cardinality of 'tokens'\n     * @param minToMint the minimum LP tokens adding this amount of liquidity\n     * should mint, otherwise revert. Handy for front-running mitigation\n     * allowed addresses. If the pool is not in the guarded launch phase, this parameter will be ignored.\n     * @param amplificationParams amplification parameters for the pool\n     * @param feeParams fee parameters for the pool\n     * @param lpToken Liquidity pool token contract\n     * @return amount of LP token user received\n     */\n    function addLiquidity(\n        PooledToken[2] memory tokens,\n        uint256[2] memory amounts,\n        uint256 minToMint,\n        Amplification storage amplificationParams,\n        FeeParams storage feeParams,\n        LiquidityPoolToken lpToken\n    ) external returns (uint256) {\n        // current state\n        ManageLiquidityInfo memory v = ManageLiquidityInfo(\n            0,\n            0,\n            0,\n            _getAPrecise(amplificationParams),\n            lpToken,\n            0,\n            tokens,\n            [uint256(0), uint256(0)],\n            [uint256(0), uint256(0)]\n        );\n        v.totalSupply = v.lpToken.totalSupply();\n\n        // Get the current pool invariant d0\n        if (v.totalSupply != 0) {\n            uint256 _bal0 = _getTokenBalance(tokens[0].token);\n            uint256 _bal1 = _getTokenBalance(tokens[1].token);\n            v.oldBalances = [_bal0, _bal1];\n            uint256 xp0 = _xp(_bal0, tokens[0].precisionMultiplier);\n            uint256 xp1 = _xp(_bal1, tokens[1].precisionMultiplier);\n            v.d0 = getD(xp0, xp1, v.preciseA);\n        }\n\n        // Transfer the tokens\n        for (uint256 i = 0; i < tokens.length; i++) {\n            tokens[i].token.safeTransferFrom(msg.sender, address(this), amounts[i]);\n        }\n\n        // calculate pool invariant after balance changes d1\n        {\n            uint256 _bal0 = _getTokenBalance(tokens[0].token);\n            uint256 _bal1 = _getTokenBalance(tokens[1].token);\n            v.newBalances = [_bal0, _bal1];\n            uint256 _xp0 = _xp(_bal0, tokens[0].precisionMultiplier);\n            uint256 _xp1 = _xp(_bal1, tokens[1].precisionMultiplier);\n            v.d1 = getD(_xp0, _xp1, v.preciseA);\n            require(v.d1 > v.d0, \"D1 <= D0\");\n        }\n\n        // calculate swap fees\n        v.d2 = v.d1;\n\n        // first entrant doesn't pay fees\n        uint256[2] memory fees;\n        if (v.totalSupply != 0) {\n            uint256 feePerToken = _feePerToken(feeParams.swapFee);\n\n            for (uint256 i = 0; i < tokens.length; i++) {\n                uint256 idealBal = (v.d1 * v.oldBalances[i]) / v.d0;\n                (feePerToken * idealBal.difference(v.newBalances[i])) / FEE_DENOMINATOR;\n                fees[i] = (feePerToken * idealBal.difference(v.newBalances[i])) / FEE_DENOMINATOR;\n                v.newBalances[i] = v.newBalances[i] - fees[i];\n                // TODO: handle admin fee\n            }\n\n            // calculate invariant after subtracting fees, d2\n            {\n                uint256 _xp0 = _xp(v.newBalances[0], tokens[0].precisionMultiplier);\n                uint256 _xp1 = _xp(v.newBalances[1], tokens[1].precisionMultiplier);\n                v.d2 = getD(_xp0, _xp1, v.preciseA);\n            }\n        }\n\n        uint256 toMint;\n        if (v.totalSupply == 0) {\n            toMint = v.d1;\n        } else {\n            toMint = ((v.d2 - v.d0) * v.totalSupply) / v.d0;\n        }\n\n        require(toMint >= minToMint, \"Couldn't mint min requested\");\n\n        // mint the user's LP tokens\n        v.lpToken.mint(msg.sender, toMint);\n\n        emit AddLiquidity(msg.sender, amounts, fees, v.d1, v.totalSupply + toMint);\n\n        return toMint;\n    }\n\n    /**\n     * @notice Burn LP tokens to remove liquidity from the pool.\n     * @dev Liquidity can always be removed, even when the pool is paused.\n     * @param amount the amount of LP tokens to burn\n     * @param tokens Array of [token0, token1]\n     * @param minAmounts the minimum amounts of each token in the pool\n     * acceptable for this burn. Useful as a front-running mitigation.\n     * Should be according to the cardinality of 'tokens'\n     * @param lpToken Liquidity pool token contract\n     * @return amounts of tokens the user receives for each token in the pool\n     * according to [token0, token1] cardinality\n     */\n    function removeLiquidity(\n        uint256 amount,\n        PooledToken[2] calldata tokens,\n        uint256[2] calldata minAmounts,\n        LiquidityPoolToken lpToken\n    ) external returns (uint256[2] memory) {\n        uint256 totalSupply = lpToken.totalSupply();\n\n        uint256[2] memory amounts = _calculateRemoveLiquidity(amount, tokens, totalSupply);\n\n        lpToken.burnFrom(msg.sender, amount);\n\n        for (uint256 i = 0; i < tokens.length; i++) {\n            require(amounts[i] >= minAmounts[i], \"amounts[i] < minAmounts[i]\");\n            tokens[i].token.safeTransfer(msg.sender, amounts[i]);\n        }\n\n        emit RemoveLiquidity(msg.sender, amounts, totalSupply - amount);\n\n        return amounts;\n    }\n\n    /**\n     * @notice Remove liquidity from the pool all in one token.\n     * @param tokenAmount the amount of the lp tokens to burn\n     * @param tokenReceive  the token you want to receive\n     * @param tokenCounterpart the counterpart token in the pool of the token you want to receive\n     * @param minAmount the minimum amount to withdraw, otherwise revert\n     * @param amplificationParams amplification parameters for the pool\n     * @param feeParams fee parameters for the pool\n     * @param lpToken Liquidity pool token contract\n     * @return amount chosen token that user received\n     */\n    function removeLiquidityOneToken(\n        uint256 tokenAmount,\n        PooledToken storage tokenReceive,\n        PooledToken storage tokenCounterpart,\n        uint256 minAmount,\n        Amplification storage amplificationParams,\n        FeeParams storage feeParams,\n        LiquidityPoolToken lpToken\n    ) external returns (uint256) {\n        uint256 totalSupply = lpToken.totalSupply();\n        require(tokenAmount <= lpToken.balanceOf(msg.sender), \">LP.balanceOf\");\n\n        (\n            uint256 dy, /*uint256 dyFee*/\n\n        ) = _calculateWithdrawOneToken(\n                tokenAmount,\n                tokenReceive,\n                tokenCounterpart,\n                totalSupply,\n                amplificationParams,\n                feeParams\n            );\n\n        require(dy >= minAmount, \"dy < minAmount\");\n\n        // TODO: Handle admin fee from dyFee\n\n        // Transfer tokens\n        tokenReceive.token.safeTransfer(msg.sender, dy);\n\n        // Burn LP tokens\n        lpToken.burnFrom(msg.sender, tokenAmount);\n\n        emit RemoveLiquidityOne(msg.sender, tokenAmount, totalSupply, tokenReceive.token, dy);\n\n        return dy;\n    }\n\n    /**\n     * @notice Remove liquidity from the pool, weighted differently than the\n     * pool's current balances.\n     *\n     * @param tokens Array of [token0, token1]\n     * @param amounts how much of each token to withdraw according to cardinality of pooled tokens\n     * @param maxBurnAmount the max LP token provider is willing to pay to\n     * remove liquidity. Useful as a front-running mitigation.\n     * @param amplificationParams amplification parameters for the pool\n     * @param feeParams fee parameters for the pool\n     * @param lpToken Liquidity pool token contract\n     * @return actual amount of LP tokens burned in the withdrawal\n     */\n    function removeLiquidityImbalance(\n        PooledToken[2] memory tokens,\n        uint256[2] memory amounts,\n        uint256 maxBurnAmount,\n        Amplification storage amplificationParams,\n        FeeParams storage feeParams,\n        LiquidityPoolToken lpToken\n    ) public returns (uint256) {\n        ManageLiquidityInfo memory v = ManageLiquidityInfo({\n            d0: 0,\n            d1: 0,\n            d2: 0,\n            preciseA: _getAPrecise(amplificationParams),\n            lpToken: lpToken,\n            totalSupply: 0,\n            tokens: tokens,\n            oldBalances: [uint256(0), uint256(0)],\n            newBalances: [uint256(0), uint256(0)]\n        });\n\n        v.totalSupply = v.lpToken.totalSupply();\n\n        // Get the current pool invariant d0\n        if (v.totalSupply != 0) {\n            uint256 _bal0 = _getTokenBalance(tokens[0].token);\n            uint256 _bal1 = _getTokenBalance(tokens[1].token);\n            v.oldBalances = [_bal0, _bal1];\n            uint256 xp0 = _xp(_bal0, tokens[0].precisionMultiplier);\n            uint256 xp1 = _xp(_bal1, tokens[1].precisionMultiplier);\n            v.d0 = getD(xp0, xp1, v.preciseA);\n        }\n\n        // calculate pool invariant after balance changes d1\n        {\n            require(v.oldBalances[0] >= amounts[0], \"AMOUNT_EXCEEDS_BALANCE\");\n            require(v.oldBalances[1] >= amounts[1], \"AMOUNT_EXCEEDS_BALANCE\");\n\n            uint256 _bal0 = v.oldBalances[0] - amounts[0];\n            uint256 _bal1 = v.oldBalances[1] - amounts[1];\n            v.newBalances = [_bal0, _bal1];\n            uint256 _xp0 = _xp(_bal0, tokens[0].precisionMultiplier);\n            uint256 _xp1 = _xp(_bal1, tokens[1].precisionMultiplier);\n            v.d1 = getD(_xp0, _xp1, v.preciseA);\n        }\n\n        // calculate swap fees\n        v.d2 = v.d1;\n\n        // first entrant doesn't pay fees\n        uint256[2] memory fees;\n        uint256 feePerToken = _feePerToken(feeParams.swapFee);\n\n        for (uint256 i = 0; i < tokens.length; i++) {\n            uint256 idealBal = (v.d1 * v.oldBalances[i]) / v.d0;\n            (feePerToken * idealBal.difference(v.newBalances[i])) / FEE_DENOMINATOR;\n            fees[i] = (feePerToken * idealBal.difference(v.newBalances[i])) / FEE_DENOMINATOR;\n            v.newBalances[i] = v.newBalances[i] - fees[i];\n            // TODO: handle admin fee\n        }\n\n        // calculate invariant after subtracting fees, d2\n        {\n            uint256 _xp0 = _xp(v.newBalances[0], tokens[0].precisionMultiplier);\n            uint256 _xp1 = _xp(v.newBalances[1], tokens[1].precisionMultiplier);\n            v.d2 = getD(_xp0, _xp1, v.preciseA);\n        }\n\n        uint256 tokenAmount = ((v.d0 - v.d2) * v.totalSupply) / v.d0;\n        require(tokenAmount != 0, \"Burnt amount cannot be zero\");\n\n        require(tokenAmount <= maxBurnAmount, \"tokenAmount > maxBurnAmount\");\n\n        v.lpToken.burnFrom(msg.sender, tokenAmount);\n\n        for (uint256 i = 0; i < tokens.length; i++) {\n            tokens[i].token.safeTransfer(msg.sender, amounts[i]);\n        }\n\n        emit RemoveLiquidityImbalance(msg.sender, amounts, fees, v.d1, v.totalSupply - tokenAmount);\n\n        return tokenAmount;\n    }\n\n    /**\n     * @notice Calculate the dy, the amount of selected token that user receives and\n     * the fee of withdrawing in one token\n     * @param tokenAmount the amount to withdraw in the pool's precision\n     * @param tokenReceive which token will be withdrawn\n     * @param tokenCounterpart the token we need to swap for\n     * @param amplificationParams amplification parameters for the pool\n     * @param feeParams fee parameters for the pool\n     * @param lpToken liquidity pool token\n     * @return the amount of token user will receive\n     */\n    function calculateWithdrawOneToken(\n        uint256 tokenAmount,\n        PooledToken storage tokenReceive,\n        PooledToken storage tokenCounterpart,\n        Amplification storage amplificationParams,\n        FeeParams storage feeParams,\n        LiquidityPoolToken lpToken\n    ) internal view returns (uint256) {\n        (uint256 availableAmount, ) = _calculateWithdrawOneToken(\n            tokenAmount,\n            tokenReceive,\n            tokenCounterpart,\n            lpToken.totalSupply(),\n            amplificationParams,\n            feeParams\n        );\n        return availableAmount;\n    }\n\n    /**\n     * @notice Calculate the dy, the amount of selected token that user receives and\n     * the fee of withdrawing in one token\n     * @param tokenAmount the amount to withdraw in the pool's precision\n     * @param tokenReceive which token will be withdrawn\n     * @param tokenCounterpart the token we need to swap for\n     * @param totalSupply total supply of LP tokens\n     * @param amplificationParams amplification parameters for the pool\n     * @param feeParams fee parameters for the pool\n     * @return the amount of token user will receive\n     */\n    function _calculateWithdrawOneToken(\n        uint256 tokenAmount,\n        PooledToken storage tokenReceive,\n        PooledToken storage tokenCounterpart,\n        uint256 totalSupply,\n        Amplification storage amplificationParams,\n        FeeParams storage feeParams\n    ) internal view returns (uint256, uint256) {\n        uint256 dy;\n        uint256 newY;\n        uint256 currentY;\n\n        (dy, newY, currentY) = calculateWithdrawOneTokenDY(\n            tokenAmount,\n            tokenReceive,\n            tokenCounterpart,\n            totalSupply,\n            _getAPrecise(amplificationParams),\n            feeParams.swapFee\n        );\n\n        // dy_0 (without fees)\n        // dy, dy_0 - dy\n\n        uint256 dySwapFee = (currentY - newY) / tokenReceive.precisionMultiplier - dy;\n\n        return (dy, dySwapFee);\n    }\n\n    /**\n     * @notice Calculate the dy of withdrawing in one token\n     * @param tokenAmount the amount to withdraw in the pools precision\n     * @param tokenReceive Swap struct to read from\n     * @param tokenCounterpart which token will be withdrawn\n     * @param totalSupply total supply of the lp token\n     * @return the d and the new y after withdrawing one token\n     */\n    function calculateWithdrawOneTokenDY(\n        uint256 tokenAmount,\n        PooledToken storage tokenReceive,\n        PooledToken storage tokenCounterpart,\n        uint256 totalSupply,\n        uint256 preciseA,\n        uint256 swapFee\n    )\n        internal\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        // Get the current D, then solve the stableswap invariant\n        // y_i for D - tokenAmount\n        uint256 trBal = _getTokenBalance(tokenReceive.token);\n        uint256 xpR = _xp(trBal, tokenReceive.precisionMultiplier);\n\n        uint256 tcBal = _getTokenBalance(tokenCounterpart.token);\n        uint256 xpC = _xp(tcBal, tokenCounterpart.precisionMultiplier);\n\n        CalculateWithdrawOneTokenDYInfo memory v = CalculateWithdrawOneTokenDYInfo(0, 0, 0, 0, 0);\n        v.preciseA = preciseA;\n        // swap from counterpart to receive (so counterpart is from and receive is to)\n        v.d0 = getD(xpC, xpR, v.preciseA);\n        v.d1 = v.d0 - ((tokenAmount * v.d0) / totalSupply);\n\n        require(tokenAmount <= xpR, \"AMOUNT_EXCEEDS_AVAILABLE\");\n\n        v.newY = getYD(v.preciseA, xpC, v.d1);\n\n        v.feePerToken = _feePerToken(swapFee);\n\n        // For xpR => dxExpected = xpR * d1 / d0 - newY\n        // For xpC => dxExpected = xpC - (xpC * d1 / d0)\n        // xpReduced -= dxExpected * fee / FEE_DENOMINATOR\n        uint256 xpRReduced = xpR - (((xpR * v.d1) / v.d0 - v.newY) * v.feePerToken) / FEE_DENOMINATOR;\n        uint256 xpCReduced = xpC - ((xpC - ((xpC * v.d1) / v.d0)) * v.feePerToken) / FEE_DENOMINATOR;\n\n        uint256 dy = xpRReduced - getYD(v.preciseA, xpCReduced, v.d1);\n\n        dy = (dy - 1) / tokenReceive.precisionMultiplier;\n\n        return (dy, v.newY, xpR);\n    }\n\n    /**\n     * @notice A simple method to calculate prices from deposits or\n     * withdrawals, excluding fees but including slippage. This is\n     * helpful as an input into the various \"min\" parameters on calls\n     * to fight front-running\n     *\n     * @dev This shouldn't be used outside frontends for user estimates.\n     *\n     * @param tokens Array of tokens in the pool\n     *          according to pool cardinality [token0, token1]\n     * @param amounts an array of token amounts to deposit or withdrawal,\n     * corresponding to tokens. The amount should be in each\n     * pooled token's native precision.\n     * @param deposit whether this is a deposit or a withdrawal\n     * @param amplificationParams amplification parameters for the pool\n     * @param lpToken liquidity pool token\n     * @return if deposit was true, total amount of lp token that will be minted and if\n     * deposit was false, total amount of lp token that will be burned\n     */\n    function calculateTokenAmount(\n        PooledToken[2] memory tokens,\n        uint256[] calldata amounts,\n        bool deposit,\n        Amplification storage amplificationParams,\n        LiquidityPoolToken lpToken\n    ) external view returns (uint256) {\n        uint256 a = _getAPrecise(amplificationParams);\n\n        uint256 xp0;\n        uint256 xp0_;\n        {\n            uint256 prec0 = tokens[0].precisionMultiplier;\n            uint256 bal0 = _getTokenBalance(tokens[0].token);\n            xp0 = _xp(bal0, prec0);\n            if (!deposit && bal0 < amounts[0]) revert(\"AMOUNT_EXCEEDS_SUPPLY\");\n            xp0_ = _xp(deposit ? bal0 + amounts[0] : bal0 - amounts[0], prec0);\n        }\n\n        uint256 xp1;\n        uint256 xp1_;\n        {\n            uint256 prec1 = tokens[1].precisionMultiplier;\n            uint256 bal1 = _getTokenBalance(tokens[1].token);\n            xp1 = _xp(bal1, prec1);\n            if (!deposit && bal1 < amounts[1]) revert(\"AMOUNT_EXCEEDS_SUPPLY\");\n            xp1_ = _xp(deposit ? bal1 + amounts[1] : bal1 - amounts[1], prec1);\n        }\n\n        uint256 d0 = getD(xp0, xp1, a);\n        uint256 d1 = getD(xp0_, xp1_, a);\n\n        uint256 totalSupply = lpToken.totalSupply();\n\n        if (deposit) {\n            return totalSupply == 0 ? d1 : ((d1 - d0) * totalSupply) / d0;\n        } else {\n            return ((d0 - d1) * totalSupply) / d0;\n        }\n    }\n\n    /**\n     * @notice Calculate the price of a token in the pool with given\n     * precision-adjusted balances and a particular D.\n     *\n     * @dev This is accomplished via solving the invariant iteratively.\n     * See the StableSwap paper and Curve.fi implementation for further details.\n     *\n     * x_1**2 + x1 * (sum' - (A*n**n - 1) * D / (A * n**n)) = D ** (n + 1) / (n ** (2 * n) * prod' * A)\n     * x_1**2 + b*x_1 = c\n     * x_1 = (x_1**2 + c) / (2*x_1 + b)\n     *\n     * @param a the amplification coefficient * n * (n - 1). See the StableSwap paper for details.\n     * @param xpFrom a precision-adjusted balance of the token to send\n     * @param d the stableswap invariant\n     * @return the price of the token, in the same precision as in xp\n     */\n    function getYD(\n        uint256 a,\n        uint256 xpFrom,\n        uint256 d\n    ) internal pure returns (uint256) {\n        uint256 c = (d * d) / (xpFrom * NUM_TOKENS);\n        uint256 s = xpFrom;\n        uint256 nA = a * NUM_TOKENS;\n\n        c = (c * d * A_PRECISION) / (nA * NUM_TOKENS);\n\n        uint256 b = s + ((d * A_PRECISION) / nA);\n\n        uint256 yPrev;\n        uint256 y = d;\n        for (uint256 i = 0; i < MAX_LOOP_LIMIT; i++) {\n            yPrev = y;\n            uint256 num = y * y + c;\n            uint256 denom = y * 2 + b - d;\n            y = num / denom;\n            // y = y.mul(y).add(c).div(y.mul(2).add(b).sub(d));\n            if (y.within1(yPrev)) {\n                return y;\n            }\n        }\n        revert(\"Approximation did not converge\");\n    }\n\n    /**\n     * @notice Internally calculates a swap between two tokens.\n     *\n     * @dev The caller is expected to transfer the actual amounts (dx and dy)\n     * using the token contracts.\n     *\n     * @param tokenFrom the token to sell\n     * @param tokenTo the token to buy\n     * @param dx the number of tokens to sell\n     * @param amplificationParams amplification parameters for the pool\n     * @param feeParams fee parameters for the pool\n     * @return dy the number of tokens the user will get\n     * @return dyFee the associated fee\n     */\n    function _calculateSwap(\n        PooledToken storage tokenFrom,\n        PooledToken storage tokenTo,\n        uint256 dx,\n        Amplification storage amplificationParams,\n        FeeParams storage feeParams\n    ) internal view returns (uint256 dy, uint256 dyFee) {\n        // tokenFrom balance\n        uint256 fromBalance = _getTokenBalance(tokenFrom.token);\n        // precision adjusted balance\n        uint256 fromXp = _xp(fromBalance, tokenFrom.precisionMultiplier);\n\n        // tokenTo balance\n        uint256 toBalance = _getTokenBalance(tokenTo.token);\n        // precision adjusted balance\n        uint256 toXp = _xp(toBalance, tokenTo.precisionMultiplier);\n\n        // x is the new total amount of tokenFrom\n        uint256 x = _xp(dx, tokenFrom.precisionMultiplier) + fromXp;\n\n        uint256 y = getY(_getAPrecise(amplificationParams), fromXp, toXp, x);\n\n        dy = toXp - y - 1;\n        dyFee = (dy * feeParams.swapFee) / FEE_DENOMINATOR;\n        dy = (dy - dyFee) / tokenTo.precisionMultiplier;\n    }\n\n    /**\n     * @notice A simple method to calculate amount of each underlying\n     * tokens that is returned upon burning given amount of\n     * LP tokens\n     *\n     * @param amount the amount of LP tokens that would to be burned on\n     * withdrawal\n     * @param tokens the tokens of the pool in their cardinality [token0, token1]\n     * @param lpToken Liquidity pool token\n     * @return array of amounts of tokens user will receive\n     */\n    function calculateRemoveLiquidity(\n        uint256 amount,\n        PooledToken[2] calldata tokens,\n        LiquidityPoolToken lpToken\n    ) external view returns (uint256[2] memory) {\n        uint256 totalSupply = lpToken.totalSupply();\n        uint256[2] memory amounts = _calculateRemoveLiquidity(amount, tokens, totalSupply);\n        return amounts;\n    }\n\n    /**\n     * @notice A simple method to calculate amount of each underlying\n     * tokens that is returned upon burning given amount of\n     * LP tokens\n     *\n     * @param amount the amount of LP tokens that would to be burned on\n     * withdrawal\n     * @param tokens the tokens of the pool in their cardinality [token0, token1]\n     * @param totalSupply total supply of the LP token\n     * @return array of amounts of tokens user will receive\n     */\n    function _calculateRemoveLiquidity(\n        uint256 amount,\n        PooledToken[2] calldata tokens,\n        uint256 totalSupply\n    ) internal view returns (uint256[2] memory) {\n        require(amount <= totalSupply, \"Cannot exceed total supply\");\n\n        uint256[2] memory outAmounts;\n\n        for (uint256 i = 0; i < tokens.length; i++) {\n            uint256 balance = _getTokenBalance(tokens[i].token);\n            outAmounts[i] = (balance * amount) / totalSupply;\n        }\n        return outAmounts;\n    }\n\n    /**\n     * @notice Calculate the new balances of the tokens given FROM and TO tokens.\n     * This function is used as a helper function to calculate how much TO token\n     * the user should receive on swap.\n     *\n     * @param preciseA precise form of amplification coefficient\n     * @param fromXp FROM precision-adjusted balance in the pool\n     * @param toXp TO precision-adjusted balance in the pool\n     * @param x the new total amount of precision-adjusted FROM token\n     * @return the amount of TO token that should remain in the pool\n     */\n    function getY(\n        uint256 preciseA,\n        uint256 fromXp,\n        uint256 toXp,\n        uint256 x\n    ) internal pure returns (uint256) {\n        // d is the invariant of the pool\n        uint256 d = getD(fromXp, toXp, preciseA);\n        uint256 nA = NUM_TOKENS * preciseA;\n        uint256 c = (d * d) / (x * NUM_TOKENS);\n        c = (c * d * A_PRECISION) / (nA * NUM_TOKENS);\n\n        uint256 b = x + ((d * A_PRECISION) / nA);\n        uint256 yPrev;\n        uint256 y = d;\n\n        // iterative approximation\n        for (uint256 i = 0; i < MAX_LOOP_LIMIT; i++) {\n            yPrev = y;\n            y = (y * y + c) / (y * 2 + b - d);\n            // y = y.mul(y).add(c).div(y.mul(2).add(b).sub(d));\n            if (y.within1(yPrev)) {\n                return y;\n            }\n        }\n        revert(\"Approximation did not converge\");\n    }\n\n    /**\n     * @notice Get D, the StableSwap invariant, based on a set of balances and a particular A.\n     * @param fromXp a precision-adjusted balance of the token to sell\n     * @param toXp a precision-adjusted balance of the token to buy\n     * @param a the amplification coefficient * n * (n - 1) in A_PRECISION.\n     * See the StableSwap paper for details\n     * @return the invariant, at the precision of the pool\n     */\n    function getD(\n        uint256 fromXp,\n        uint256 toXp,\n        uint256 a\n    ) internal pure returns (uint256) {\n        uint256 s = fromXp + toXp;\n        if (s == 0) return 0;\n\n        uint256 prevD;\n        uint256 d = s;\n        uint256 nA = a * NUM_TOKENS;\n\n        for (uint256 i = 0; i < MAX_LOOP_LIMIT; i++) {\n            uint256 dP = d;\n\n            // dP = dP.mul(d).div(xp[j].mul(numTokens));\n\n            dP = (dP * d) / (fromXp * NUM_TOKENS);\n            dP = (dP * d) / (toXp * NUM_TOKENS);\n\n            prevD = d;\n\n            uint256 num = ((nA * s) / A_PRECISION + (dP * NUM_TOKENS)) * d;\n            uint256 denom = ((nA - A_PRECISION) * d) / A_PRECISION + (NUM_TOKENS + 1) * dP;\n            d = num / denom;\n            // d = nA\n            //     .mul(s)\n            //     .div(A_PRECISION)\n            //     .add(dP.mul(NUM_TOKENS))\n            //     .mul(d)\n            //     .div(\n            //         nA\n            //             .sub(A_PRECISION)\n            //             .mul(d)\n            //             .div(A_PRECISION)\n            //             .add(NUM_TOKENS.add(1).mul(dP))\n            //     );\n            if (d.within1(prevD)) {\n                return d;\n            }\n        }\n\n        // Convergence should occur in 4 loops or less. If this is reached, there may be something wrong\n        // with the pool. If this were to occur repeatedly, LPs should withdraw via `removeLiquidity()`\n        // function which does not rely on D.\n        revert(\"D does not converge\");\n    }\n\n    /**\n     * @notice Given a a balance and precision multiplier, return the\n     * precision-adjusted balance.\n     *\n     * @param balance a token balance in its native precision\n     *\n     * @param precisionMultiplier a precision multiplier for the token, When multiplied together they\n     * should yield amounts at the pool's precision.\n     *\n     * @return an amount  \"scaled\" to the pool's precision\n     */\n    function _xp(uint256 balance, uint256 precisionMultiplier) internal pure returns (uint256) {\n        return balance * precisionMultiplier;\n    }\n\n    /**\n     * @notice internal helper function to calculate fee per token multiplier used in\n     * swap fee calculations\n     * @param swapFee swap fee for the tokens\n     */\n    function _feePerToken(uint256 swapFee) internal pure returns (uint256) {\n        return swapFee / NUM_TOKENS;\n    }\n\n    // =============================================\n    //             AMPLIFICATION LOGIC\n    // =============================================\n\n    // Constant values used in ramping A calculations\n    uint256 public constant A_PRECISION = 100;\n    uint256 public constant MAX_A = 10**6;\n    uint256 private constant MAX_A_CHANGE = 2;\n    uint256 private constant MIN_RAMP_TIME = 14 days;\n\n    struct Amplification {\n        // variables around the ramp management of A,\n        // the amplification coefficient * n * (n - 1)\n        // see https://www.curve.fi/stableswap-paper.pdf for details\n        uint256 initialA;\n        uint256 futureA;\n        uint256 initialATime;\n        uint256 futureATime;\n    }\n\n    event RampA(uint256 oldA, uint256 newA, uint256 initialTime, uint256 futureTime);\n    event StopRampA(uint256 currentA, uint256 time);\n\n    /**\n     * @notice Return A, the amplification coefficient * n * (n - 1)\n     * @dev See the StableSwap paper for details\n     * @param self Swap struct to read from\n     * @return A parameter\n     */\n    function getA(Amplification storage self) external view returns (uint256) {\n        return _getAPrecise(self) / A_PRECISION;\n    }\n\n    /**\n     * @notice Return A in its raw precision\n     * @dev See the StableSwap paper for details\n     * @param self Swap struct to read from\n     * @return A parameter in its raw precision form\n     */\n    function getAPrecise(Amplification storage self) external view returns (uint256) {\n        return _getAPrecise(self);\n    }\n\n    /**\n     * @notice Return A in its raw precision\n     * @dev See the StableSwap paper for details\n     * @param self Swap struct to read from\n     * @return A parameter in its raw precision form\n     */\n    function _getAPrecise(Amplification storage self) internal view returns (uint256) {\n        uint256 t1 = self.futureATime; // time when ramp is finished\n        uint256 a1 = self.futureA; // final A value when ramp is finished\n\n        if (block.timestamp < t1) {\n            uint256 t0 = self.initialATime; // time when ramp is started\n            uint256 a0 = self.initialA; // initial A value when ramp is started\n            if (a1 > a0) {\n                // a0 + (a1 - a0) * (block.timestamp - t0) / (t1 - t0)\n                return a0 + ((a1 - a0) * (block.timestamp - t0)) / (t1 - t0);\n            } else {\n                // a0 - (a0 - a1) * (block.timestamp - t0) / (t1 - t0)\n                return a0 - ((a0 - a1) * (block.timestamp - t0)) / (t1 - t0);\n            }\n        } else {\n            return a1;\n        }\n    }\n\n    /**\n     * @notice Start ramping up or down A parameter towards given futureA_ and futureTime_\n     * Checks if the change is too rapid, and commits the new A value only when it falls under\n     * the limit range.\n     * @param self Swap struct to update\n     * @param futureA_ the new A to ramp towards\n     * @param futureTime_ timestamp when the new A should be reached\n     */\n    function rampA(\n        Amplification storage self,\n        uint256 futureA_,\n        uint256 futureTime_\n    ) external {\n        require(block.timestamp >= self.initialATime + 1 days, \"Wait 1 day before starting ramp\");\n        require(futureTime_ >= block.timestamp + MIN_RAMP_TIME, \"Insufficient ramp time\");\n        require(futureA_ > 0 && futureA_ < MAX_A, \"futureA_ must be > 0 and < MAX_A\");\n\n        uint256 initialAPrecise = _getAPrecise(self);\n        uint256 futureAPrecise = futureA_ * A_PRECISION;\n\n        if (futureAPrecise < initialAPrecise) {\n            require(futureAPrecise * MAX_A_CHANGE >= initialAPrecise, \"futureA_ is too small\");\n        } else {\n            require(futureAPrecise <= initialAPrecise * MAX_A_CHANGE, \"futureA_ is too large\");\n        }\n\n        self.initialA = initialAPrecise;\n        self.futureA = futureAPrecise;\n        self.initialATime = block.timestamp;\n        self.futureATime = futureTime_;\n\n        emit RampA(initialAPrecise, futureAPrecise, block.timestamp, futureTime_);\n    }\n\n    /**\n     * @notice Stops ramping A immediately. Once this function is called, rampA()\n     * cannot be called for another 24 hours\n     * @param self Swap struct to update\n     */\n    function stopRampA(Amplification storage self) external {\n        require(self.futureATime > block.timestamp, \"Ramp is already stopped\");\n\n        uint256 currentA = _getAPrecise(self);\n        self.initialA = currentA;\n        self.futureA = currentA;\n        self.initialATime = block.timestamp;\n        self.futureATime = block.timestamp;\n\n        emit StopRampA(currentA, block.timestamp);\n    }\n\n    // =============================================\n    //            TOKEN INTERACTIONS\n    // =============================================\n\n    function getTokenBalance(PooledToken storage _token) external view returns (uint256) {\n        return _getTokenBalance(_token.token);\n    }\n\n    function _getTokenBalance(IERC20 _token) internal view returns (uint256) {\n        return _token.balanceOf(address(this));\n    }\n\n    // =============================================\n    //            FEE MANAGEMENT\n    // =============================================\n\n    /**\n     * @notice Sets the admin fee\n     * @dev adminFee cannot be higher than 100% of the swap fee\n     * @param self Swap struct to update\n     * @param newAdminFee new admin fee to be applied on future transactions\n     */\n    function setAdminFee(FeeParams storage self, uint256 newAdminFee) external {\n        require(newAdminFee <= MAX_ADMIN_FEE, \"Fee is too high\");\n        self.adminFee = newAdminFee;\n\n        emit NewAdminFee(newAdminFee);\n    }\n\n    /**\n     * @notice update the swap fee\n     * @dev fee cannot be higher than 1% of each swap\n     * @param self Swap struct to update\n     * @param newSwapFee new swap fee to be applied on future transactions\n     */\n    function setSwapFee(FeeParams storage self, uint256 newSwapFee) external {\n        require(newSwapFee <= MAX_SWAP_FEE, \"Fee is too high\");\n        self.swapFee = newSwapFee;\n\n        emit NewSwapFee(newSwapFee);\n    }\n}\n"
    },
    "contracts/tenderswap/TenderSwap.sol": {
      "content": "// SPDX-FileCopyrightText: 2021 Tenderize <info@tenderize.me>\n// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts/proxy/Clones.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n\nimport { Multicall } from \"../helpers/Multicall.sol\";\nimport { SelfPermit } from \"../helpers/SelfPermit.sol\";\n\nimport \"./LiquidityPoolToken.sol\";\nimport \"./SwapUtils.sol\";\nimport \"./ITenderSwap.sol\";\n\n// TODO: flat withdraw LP token fee ?\n\ninterface IERC20Decimals is IERC20 {\n    function decimals() external view returns (uint8);\n}\n\n/**\n * @title TenderSwap\n * @dev TenderSwap is a light-weight StableSwap implementation for two assets.\n * See the Curve StableSwap paper for more details (https://curve.fi/files/stableswap-paper.pdf).\n * that trade 1:1 with eachother (e.g. USD stablecoins or tenderToken derivatives vs their underlying assets).\n * It supports Elastic Supply ERC20 tokens, which are tokens of which the balances can change\n * as the total supply of the token 'rebases'.\n */\n\ncontract TenderSwap is OwnableUpgradeable, ReentrancyGuardUpgradeable, ITenderSwap, Multicall, SelfPermit {\n    using SwapUtils for SwapUtils.Amplification;\n    using SwapUtils for SwapUtils.PooledToken;\n    using SwapUtils for SwapUtils.FeeParams;\n\n    // Fee parameters\n    SwapUtils.FeeParams public feeParams;\n\n    // Amplification coefficient parameters\n    SwapUtils.Amplification public amplificationParams;\n\n    // Pool Tokens\n    SwapUtils.PooledToken private token0;\n    SwapUtils.PooledToken private token1;\n\n    // Liquidity pool shares\n    LiquidityPoolToken public override lpToken;\n\n    /*** MODIFIERS ***/\n\n    /**\n     * @notice Modifier to check deadline against current timestamp\n     * @param _deadline latest timestamp to accept this transaction\n     */\n    modifier deadlineCheck(uint256 _deadline) {\n        _deadlineCheck(_deadline);\n        _;\n    }\n\n    /// @inheritdoc ITenderSwap\n    function initialize(\n        IERC20 _token0,\n        IERC20 _token1,\n        string memory lpTokenName,\n        string memory lpTokenSymbol,\n        uint256 _a,\n        uint256 _fee,\n        uint256 _adminFee,\n        LiquidityPoolToken lpTokenTargetAddress\n    ) external override initializer returns (bool) {\n        __Context_init_unchained();\n        __Ownable_init_unchained();\n        __ReentrancyGuard_init_unchained();\n\n        // Check token addresses are different and not 0\n        require(_token0 != _token1, \"DUPLICATE_TOKENS\");\n        require(address(_token0) != address(0), \"TOKEN0_ZEROADDRESS\");\n        require(address(_token1) != address(0), \"TOKEN1_ZEROADDRESS\");\n\n        // Set precision multipliers\n        uint8 _tenderTokenDecimals = IERC20Decimals(address(_token0)).decimals();\n        require(_tenderTokenDecimals > 0);\n        token0 = SwapUtils.PooledToken({\n            token: _token0,\n            precisionMultiplier: 10**(SwapUtils.POOL_PRECISION_DECIMALS - _tenderTokenDecimals)\n        });\n\n        uint8 _tokenDecimals = IERC20Decimals(address(_token1)).decimals();\n        require(_tokenDecimals > 0);\n        token1 = SwapUtils.PooledToken({\n            token: _token1,\n            precisionMultiplier: 10**(SwapUtils.POOL_PRECISION_DECIMALS - _tokenDecimals)\n        });\n\n        // Check _a and Set Amplifaction Parameters\n        require(_a < SwapUtils.MAX_A, \"_a exceeds maximum\");\n        amplificationParams.initialA = _a * SwapUtils.A_PRECISION;\n        amplificationParams.futureA = _a * SwapUtils.A_PRECISION;\n\n        // Check _fee, _adminFee and set fee parameters\n        require(_fee < SwapUtils.MAX_SWAP_FEE, \"_fee exceeds maximum\");\n        require(_adminFee < SwapUtils.MAX_ADMIN_FEE, \"_adminFee exceeds maximum\");\n        feeParams = SwapUtils.FeeParams({ swapFee: _fee, adminFee: _adminFee });\n\n        // Clone an existing LP token deployment in an immutable way\n        // see https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.2.0/contracts/proxy/Clones.sol\n        lpToken = LiquidityPoolToken(Clones.clone(address(lpTokenTargetAddress)));\n        require(lpToken.initialize(lpTokenName, lpTokenSymbol), \"could not init lpToken clone\");\n\n        return true;\n    }\n\n    /*** VIEW FUNCTIONS ***/\n\n    /// @inheritdoc ITenderSwap\n    function getA() external view override returns (uint256) {\n        return amplificationParams.getA();\n    }\n\n    /// @inheritdoc ITenderSwap\n    function getAPrecise() external view override returns (uint256) {\n        return amplificationParams.getAPrecise();\n    }\n\n    /// @inheritdoc ITenderSwap\n    function getToken0() external view override returns (IERC20) {\n        return token0.token;\n    }\n\n    /// @inheritdoc ITenderSwap\n    function getToken1() external view override returns (IERC20) {\n        return token1.token;\n    }\n\n    /// @inheritdoc ITenderSwap\n    function getToken0Balance() external view override returns (uint256) {\n        return token0.getTokenBalance();\n    }\n\n    /// @inheritdoc ITenderSwap\n    function getToken1Balance() external view override returns (uint256) {\n        return token1.getTokenBalance();\n    }\n\n    /// @inheritdoc ITenderSwap\n    function getVirtualPrice() external view override returns (uint256) {\n        return SwapUtils.getVirtualPrice(token0, token1, amplificationParams, lpToken);\n    }\n\n    /// @inheritdoc ITenderSwap\n    function calculateSwap(IERC20 _tokenFrom, uint256 _dx) external view override returns (uint256) {\n        return\n            _tokenFrom == token0.token\n                ? SwapUtils.calculateSwap(token0, token1, _dx, amplificationParams, feeParams)\n                : SwapUtils.calculateSwap(token1, token0, _dx, amplificationParams, feeParams);\n    }\n\n    /// @inheritdoc ITenderSwap\n    function calculateRemoveLiquidity(uint256 amount) external view override returns (uint256[2] memory) {\n        SwapUtils.PooledToken[2] memory tokens_ = [token0, token1];\n        return SwapUtils.calculateRemoveLiquidity(amount, tokens_, lpToken);\n    }\n\n    /// @inheritdoc ITenderSwap\n    function calculateRemoveLiquidityOneToken(uint256 tokenAmount, IERC20 tokenReceive)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return\n            tokenReceive == token0.token\n                ? SwapUtils.calculateWithdrawOneToken(\n                    tokenAmount,\n                    token0,\n                    token1,\n                    amplificationParams,\n                    feeParams,\n                    lpToken\n                )\n                : SwapUtils.calculateWithdrawOneToken(\n                    tokenAmount,\n                    token1,\n                    token0,\n                    amplificationParams,\n                    feeParams,\n                    lpToken\n                );\n    }\n\n    /// @inheritdoc ITenderSwap\n    function calculateTokenAmount(uint256[] calldata amounts, bool deposit) external view override returns (uint256) {\n        SwapUtils.PooledToken[2] memory tokens_ = [token0, token1];\n\n        return SwapUtils.calculateTokenAmount(tokens_, amounts, deposit, amplificationParams, lpToken);\n    }\n\n    /*** STATE MODIFYING FUNCTIONS ***/\n\n    /// @inheritdoc ITenderSwap\n    function swap(\n        IERC20 _tokenFrom,\n        uint256 _dx,\n        uint256 _minDy,\n        uint256 _deadline\n    ) external override nonReentrant deadlineCheck(_deadline) returns (uint256) {\n        if (_tokenFrom == token0.token) {\n            return SwapUtils.swap(token0, token1, _dx, _minDy, amplificationParams, feeParams);\n        } else if (_tokenFrom == token1.token) {\n            return SwapUtils.swap(token1, token0, _dx, _minDy, amplificationParams, feeParams);\n        } else {\n            revert(\"BAD_TOKEN_FROM\");\n        }\n    }\n\n    /// @inheritdoc ITenderSwap\n    function addLiquidity(\n        uint256[2] calldata _amounts,\n        uint256 _minToMint,\n        uint256 _deadline\n    ) external override nonReentrant deadlineCheck(_deadline) returns (uint256) {\n        SwapUtils.PooledToken[2] memory tokens_ = [token0, token1];\n\n        return SwapUtils.addLiquidity(tokens_, _amounts, _minToMint, amplificationParams, feeParams, lpToken);\n    }\n\n    /// @inheritdoc ITenderSwap\n    function removeLiquidity(\n        uint256 amount,\n        uint256[2] calldata minAmounts,\n        uint256 deadline\n    ) external override nonReentrant deadlineCheck(deadline) returns (uint256[2] memory) {\n        SwapUtils.PooledToken[2] memory tokens_ = [token0, token1];\n\n        return SwapUtils.removeLiquidity(amount, tokens_, minAmounts, lpToken);\n    }\n\n    /// @inheritdoc ITenderSwap\n    function removeLiquidityOneToken(\n        uint256 _tokenAmount,\n        IERC20 _tokenReceive,\n        uint256 _minAmount,\n        uint256 _deadline\n    ) external override nonReentrant deadlineCheck(_deadline) returns (uint256) {\n        if (_tokenReceive == token0.token) {\n            return\n                SwapUtils.removeLiquidityOneToken(\n                    _tokenAmount,\n                    token0,\n                    token1,\n                    _minAmount,\n                    amplificationParams,\n                    feeParams,\n                    lpToken\n                );\n        } else {\n            return\n                SwapUtils.removeLiquidityOneToken(\n                    _tokenAmount,\n                    token1,\n                    token0,\n                    _minAmount,\n                    amplificationParams,\n                    feeParams,\n                    lpToken\n                );\n        }\n    }\n\n    /// @inheritdoc ITenderSwap\n    function removeLiquidityImbalance(\n        uint256[2] calldata _amounts,\n        uint256 _maxBurnAmount,\n        uint256 _deadline\n    ) external override nonReentrant deadlineCheck(_deadline) returns (uint256) {\n        SwapUtils.PooledToken[2] memory tokens_ = [token0, token1];\n\n        return\n            SwapUtils.removeLiquidityImbalance(\n                tokens_,\n                _amounts,\n                _maxBurnAmount,\n                amplificationParams,\n                feeParams,\n                lpToken\n            );\n    }\n\n    /*** ADMIN FUNCTIONS ***/\n\n    /// @inheritdoc ITenderSwap\n    function setAdminFee(uint256 newAdminFee) external override onlyOwner {\n        feeParams.setAdminFee(newAdminFee);\n    }\n\n    /// @inheritdoc ITenderSwap\n    function setSwapFee(uint256 newSwapFee) external override onlyOwner {\n        feeParams.setSwapFee(newSwapFee);\n    }\n\n    /// @inheritdoc ITenderSwap\n    function rampA(uint256 futureA, uint256 futureTime) external override onlyOwner {\n        amplificationParams.rampA(futureA, futureTime);\n    }\n\n    /// @inheritdoc ITenderSwap\n    function stopRampA() external override onlyOwner {\n        amplificationParams.stopRampA();\n    }\n\n    /*** INTERNAL FUNCTIONS ***/\n\n    function _deadlineCheck(uint256 _deadline) internal view {\n        require(block.timestamp <= _deadline, \"Deadline not met\");\n    }\n\n    /// @inheritdoc ITenderSwap\n    function transferOwnership(address _newOwnner) public override(OwnableUpgradeable, ITenderSwap) onlyOwner {\n        OwnableUpgradeable.transferOwnership(_newOwnner);\n    }\n}\n"
    },
    "contracts/tenderswap/TenderSwapFactory.sol": {
      "content": "// SPDX-FileCopyrightText: 2021 Tenderize <info@tenderize.me>\n\n// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport \"./ITenderSwap.sol\";\nimport \"@openzeppelin/contracts/proxy/Clones.sol\";\n\ninterface ITenderSwapFactory {\n    struct Config {\n        IERC20 token0;\n        IERC20 token1;\n        string lpTokenName;\n        string lpTokenSymbol; // e.g. tLPT-LPT-SWAP\n    }\n\n    function deploy(Config calldata _config) external returns (ITenderSwap);\n}\n\ncontract TenderSwapFactoryV1 is ITenderSwapFactory {\n    event NewTenderSwap(\n        ITenderSwap tenderSwap,\n        string lpTokenName,\n        string lpTokenSymbol,\n        uint256 amplifier,\n        uint256 fee,\n        uint256 adminFee\n    );\n\n    ITenderSwap immutable tenderSwapTarget;\n    LiquidityPoolToken immutable lpTokenTarget;\n    uint256 immutable amplifier;\n    uint256 immutable fee;\n    uint256 immutable adminFee;\n\n    constructor(\n        ITenderSwap _tenderSwapTarget,\n        LiquidityPoolToken _lpTokenTarget,\n        uint256 _amplifier,\n        uint256 _fee,\n        uint256 _adminFee\n    ) {\n        tenderSwapTarget = _tenderSwapTarget;\n        lpTokenTarget = _lpTokenTarget;\n        amplifier = _amplifier;\n        fee = _fee;\n        adminFee = _adminFee;\n    }\n\n    function deploy(Config calldata _config) external override returns (ITenderSwap tenderSwap) {\n        tenderSwap = ITenderSwap(Clones.clone(address(tenderSwapTarget)));\n\n        require(\n            tenderSwap.initialize(\n                _config.token0,\n                _config.token1,\n                _config.lpTokenName,\n                _config.lpTokenSymbol,\n                amplifier,\n                fee,\n                adminFee,\n                lpTokenTarget\n            ),\n            \"FAIL_INIT_TENDERSWAP\"\n        );\n\n        tenderSwap.transferOwnership(msg.sender);\n\n        emit NewTenderSwap(tenderSwap, _config.lpTokenName, _config.lpTokenSymbol, amplifier, fee, adminFee);\n    }\n}\n"
    },
    "contracts/test/AudiusMock.sol": {
      "content": "// SPDX-FileCopyrightText: 2021 Tenderize <info@tenderize.me>\n\n// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"./MockStaking.sol\";\n\ncontract AudiusMock is MockStaking {\n    constructor(IERC20 _token) MockStaking(_token) {}\n\n    /**\n     * @notice Get total delegation from a given address\n     * @param _delegator - delegator address\n     */\n    function getTotalDelegatorStake(address _delegator) external view returns (uint256) {\n        return staked;\n    }\n\n    /**\n     * @notice Allow a delegator to delegate stake to a service provider\n     * @param _targetSP - address of service provider to delegate to\n     * @param _amount - amount in wei to delegate\n     * @return Updated total amount delegated to the service provider by delegator\n     */\n    function delegateStake(address _targetSP, uint256 _amount)\n        external\n        reverted(this.delegateStake.selector)\n        returns (uint256)\n    {\n        require(token.transferFrom(msg.sender, address(this), _amount));\n        staked += _amount;\n        return staked;\n    }\n\n    /**\n     * @notice Submit request for undelegation\n     * @param _target - address of service provider to undelegate stake from\n     * @param _amount - amount in wei to undelegate\n     * @return Updated total amount delegated to the service provider by delegator\n     */\n    function requestUndelegateStake(address _target, uint256 _amount)\n        external\n        reverted(this.requestUndelegateStake.selector)\n        returns (uint256)\n    {\n        staked -= _amount;\n        unstakeLocks[nextUnstakeLockID] = UnstakeLock({ amount: _amount, account: msg.sender });\n    }\n\n    /**\n     * @notice Cancel undelegation request\n     */\n    function cancelUndelegateStakeRequest() external {}\n\n    /**\n     * @notice Finalize undelegation request and withdraw stake\n     * @return New total amount currently staked after stake has been undelegated\n     */\n    function undelegateStake() external reverted(this.undelegateStake.selector) returns (uint256) {\n        token.transfer(unstakeLocks[nextUnstakeLockID].account, unstakeLocks[nextUnstakeLockID].amount);\n    }\n\n    /**\n     * @notice Claim and distribute rewards to delegators and service provider as necessary\n     * @param _serviceProvider - Provider for which rewards are being distributed\n     * @dev Factors in service provider rewards from delegator and transfers deployer cut\n     */\n    function claimRewards(address _serviceProvider) external reverted(this.claimRewards.selector) {\n        return;\n    }\n\n    /// @notice Get the Staking address\n    function getStakingAddress() external view returns (address) {\n        return address(this);\n    }\n}\n"
    },
    "contracts/test/DummyStaking.sol": {
      "content": "// SPDX-FileCopyrightText: 2021 Tenderize <info@tenderize.me>\n\n// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/draft-ERC20Permit.sol\";\nimport \"../tenderizer/WithdrawalLocks.sol\";\n\ncontract DummyStaking is ERC20, ERC20Permit {\n    using WithdrawalLocks for WithdrawalLocks.Locks;\n\n    WithdrawalLocks.Locks withdrawalLocks;\n\n    uint256 public totalStaked;\n\n    /**\n     * @dev Constructor that gives msg.sender all of existing tokens.\n     */\n    constructor(\n        string memory name,\n        string memory symbol,\n        uint256 initialSupply\n    ) ERC20(name, symbol) ERC20Permit(name) {\n        _mint(msg.sender, initialSupply);\n    }\n\n    function stake(\n        uint256 _amount,\n        address /*_node*/\n    ) public {\n        totalStaked += _amount;\n        ERC20(address(this)).transferFrom(msg.sender, address(this), _amount);\n    }\n\n    function unstake(\n        uint256 _amount,\n        address /*_node*/\n    ) public {\n        totalStaked -= _amount;\n        uint256 lockID = withdrawalLocks.unlock(msg.sender, _amount);\n    }\n\n    function withdraw(uint256 _withdrawalLockID) public {\n        uint256 amountWithdrawn = withdrawalLocks.withdraw(msg.sender, _withdrawalLockID);\n        ERC20(address(this)).transfer(msg.sender, amountWithdrawn);\n    }\n\n    function addRewards(uint256 _amount) external {\n        totalStaked += _amount;\n        _mint(address(this), _amount);\n    }\n\n    function slash(uint256 _amount) external {\n        totalStaked -= _amount;\n        _burn(address(this), _amount);\n    }\n}\n"
    },
    "contracts/test/DummyTenderizer.sol": {
      "content": "// SPDX-FileCopyrightText: 2021 Tenderize <info@tenderize.me>\n\n// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"../libs/MathUtils.sol\";\n\nimport \"..//tenderizer/Tenderizer.sol\";\n\nimport \"../tenderizer/WithdrawalLocks.sol\";\n\nimport \"./DummyStaking.sol\";\n\nimport { ITenderSwapFactory } from \"../tenderswap/TenderSwapFactory.sol\";\n\ncontract DummyTenderizer is Tenderizer {\n    using WithdrawalLocks for WithdrawalLocks.Locks;\n    using SafeERC20 for IERC20;\n\n    DummyStaking dummyStaking;\n\n    WithdrawalLocks.Locks withdrawLocks;\n\n    function initialize(\n        IERC20 _steak,\n        string calldata _symbol,\n        DummyStaking _dummyStaking,\n        address _node,\n        uint256 _protocolFee,\n        uint256 _liquidityFee,\n        ITenderToken _tenderTokenTarget,\n        TenderFarmFactory _tenderFarmFactory,\n        ITenderSwapFactory _tenderSwapFactory\n    ) external {\n        Tenderizer._initialize(\n            _steak,\n            _symbol,\n            _node,\n            _protocolFee,\n            _liquidityFee,\n            _tenderTokenTarget,\n            _tenderFarmFactory,\n            _tenderSwapFactory\n        );\n        dummyStaking = _dummyStaking;\n    }\n\n    function _deposit(address _from, uint256 _amount) internal override {\n        currentPrincipal += _amount;\n\n        emit Deposit(_from, _amount);\n    }\n\n    function _stake(uint256 _amount) internal override {\n        uint256 amount = _amount;\n\n        if (amount == 0) {\n            return;\n        }\n\n        // approve amount to Livepeer protocol\n        steak.safeApprove(address(dummyStaking), amount);\n\n        // stake tokens\n        dummyStaking.stake(amount, node);\n\n        emit Stake(node, amount);\n    }\n\n    function _unstake(\n        address _account,\n        address _node,\n        uint256 _amount\n    ) internal override returns (uint256 withdrawalLockID) {\n        uint256 amount = _amount;\n\n        // Unbond tokens\n        dummyStaking.unstake(amount, node);\n\n        // Manage Livepeer unbonding locks\n        withdrawalLockID = withdrawLocks.unlock(_account, amount);\n\n        emit Unstake(_account, _node, amount, withdrawalLockID);\n    }\n\n    function _withdraw(address _account, uint256 _withdrawalID) internal override {\n        uint256 amount = withdrawLocks.withdraw(_account, _withdrawalID);\n\n        // Withdraw stake, transfers steak tokens to address(this)\n        dummyStaking.withdraw(_withdrawalID);\n\n        // Transfer amount from unbondingLock to _account\n        steak.safeTransfer(_account, amount);\n\n        emit Withdraw(_account, amount, _withdrawalID);\n    }\n\n    function _processNewStake() internal override returns (int256 rewards) {\n        uint256 stake = dummyStaking.totalStaked();\n        uint256 currentPrincipal_ = currentPrincipal;\n        // adjust current token balance for potential protocol specific taxes or staking fees\n        uint256 currentBal = _calcDepositOut(steak.balanceOf(address(this)));\n\n        // calculate the new total stake\n        stake += currentBal;\n\n        rewards = int256(stake) - int256(currentPrincipal_);\n\n        emit RewardsClaimed(rewards, stake, currentPrincipal_);\n    }\n\n    /**\n     * @notice claims secondary rewards\n     * these are rewards that are not from staking\n     * but from fees that do not directly accumulate\n     * towards stake. These could either be liquid\n     * underlying tokens, or other tokens that then\n     * need to be swapped using a DEX.\n     * Secondary claimed fees will be immeadiatly\n     * added to the balance of this contract\n     * @dev this is implementation specific\n     */\n    function _claimSecondaryRewards() internal override {}\n\n    function _setStakingContract(address _stakingContract) internal override {\n        emit GovernanceUpdate(\n            GovernanceParameter.STAKING_CONTRACT,\n            abi.encode(dummyStaking),\n            abi.encode(_stakingContract)\n        );\n        dummyStaking = DummyStaking(_stakingContract);\n    }\n}\n"
    },
    "contracts/test/GraphMock.sol": {
      "content": "// SPDX-FileCopyrightText: 2021 Tenderize <info@tenderize.me>\n\n// SPDX-License-Identifier: MIT\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"./MockStaking.sol\";\n\npragma solidity 0.8.4;\n\ncontract GraphMock is MockStaking {\n    uint32 constant MAX_PPM = 1000000;\n\n    constructor(IERC20 _token) MockStaking(_token) {}\n\n    // -- Delegation Data --\n\n    /**\n     * @dev Delegation pool information. One per indexer.\n     */\n    struct DelegationPool {\n        uint32 cooldownBlocks; // Blocks to wait before updating parameters\n        uint32 indexingRewardCut; // in PPM\n        uint32 queryFeeCut; // in PPM\n        uint256 updatedAtBlock; // Block when the pool was last updated\n        uint256 tokens; // Total tokens as pool reserves\n        uint256 shares; // Total shares minted in the pool\n        // mapping(address => Delegation) delegators; // Mapping of delegator => Delegation\n    }\n\n    /**\n     * @dev Individual delegation data of a delegator in a pool.\n     */\n    struct Delegation {\n        uint256 shares; // Shares owned by a delegator in the pool\n        uint256 tokensLocked; // Tokens locked for undelegation\n        uint256 tokensLockedUntil; // Block when locked tokens can be withdrawn\n    }\n\n    function delegate(address _indexer, uint256 _tokens) external reverted(this.delegate.selector) returns (uint256) {\n        require(token.transferFrom(msg.sender, address(this), _tokens));\n        uint256 add = _tokens - ((_tokens * this.delegationTaxPercentage()) / MAX_PPM);\n        staked += add;\n        return add;\n    }\n\n    function undelegate(address _indexer, uint256 _shares)\n        external\n        reverted(this.undelegate.selector)\n        returns (uint256)\n    {\n        unstakeLocks[nextUnstakeLockID] = UnstakeLock({ amount: _shares, account: msg.sender });\n        staked -= _shares;\n    }\n\n    function withdrawDelegated(address _indexer, address _newIndexer)\n        external\n        reverted(this.withdrawDelegated.selector)\n        returns (uint256)\n    {\n        token.transfer(unstakeLocks[nextUnstakeLockID].account, unstakeLocks[nextUnstakeLockID].amount);\n    }\n\n    function getDelegation(address _indexer, address _delegator) external view returns (Delegation memory) {\n        return Delegation({ shares: staked, tokensLocked: 0, tokensLockedUntil: 0 });\n    }\n\n    function delegationPools(address _indexer) external view returns (DelegationPool memory) {\n        return\n            DelegationPool({\n                tokens: staked,\n                cooldownBlocks: 0,\n                indexingRewardCut: 0,\n                queryFeeCut: 0,\n                updatedAtBlock: 0,\n                shares: staked\n            });\n    }\n\n    function getWithdraweableDelegatedTokens(Delegation memory _delegation) external view returns (uint256) {}\n\n    function thawingPeriod() external view returns (uint256) {}\n\n    function delegationTaxPercentage() external view returns (uint32) {\n        return 5000;\n    }\n}\n"
    },
    "contracts/test/IMaticStakeManager.sol": {
      "content": "// SPDX-FileCopyrightText: 2021 Tenderize <info@tenderize.me>\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\nenum Status {\n    Inactive,\n    Active,\n    Locked,\n    Unstaked\n}\n\nstruct Validator {\n    uint256 amount;\n    uint256 reward;\n    uint256 activationEpoch;\n    uint256 deactivationEpoch;\n    uint256 jailTime;\n    address signer;\n    address contractAddress;\n    Status status;\n    uint256 commissionRate;\n    uint256 lastCommissionUpdate;\n    uint256 delegatorsReward;\n    uint256 delegatedAmount;\n    uint256 initialRewardPerStake;\n}\n\ninterface IMaticStakeManager {\n    // validator replacement\n    function startAuction(\n        uint256 validatorId,\n        uint256 amount,\n        bool acceptDelegation,\n        bytes calldata signerPubkey\n    ) external;\n\n    function confirmAuctionBid(uint256 validatorId, uint256 heimdallFee) external;\n\n    function transferFunds(\n        uint256 validatorId,\n        uint256 amount,\n        address delegator\n    ) external returns (bool);\n\n    function delegationDeposit(\n        uint256 validatorId,\n        uint256 amount,\n        address delegator\n    ) external returns (bool);\n\n    function unstake(uint256 validatorId) external;\n\n    function totalStakedFor(address addr) external view returns (uint256);\n\n    function stakeFor(\n        address user,\n        uint256 amount,\n        uint256 heimdallFee,\n        bool acceptDelegation,\n        bytes memory signerPubkey\n    ) external;\n\n    function checkSignatures(\n        uint256 blockInterval,\n        bytes32 voteHash,\n        bytes32 stateRoot,\n        address proposer,\n        uint256[3][] calldata sigs\n    ) external returns (uint256);\n\n    function updateValidatorState(uint256 validatorId, int256 amount) external;\n\n    function ownerOf(uint256 tokenId) external view returns (address);\n\n    function slash(bytes calldata slashingInfoList) external returns (uint256);\n\n    function validatorStake(uint256 validatorId) external view returns (uint256);\n\n    function currentValidatorSetSize() external view returns (uint256);\n\n    function epoch() external view returns (uint256);\n\n    function getRegistry() external view returns (address);\n\n    function withdrawalDelay() external view returns (uint256);\n\n    function delegatedAmount(uint256 validatorId) external view returns (uint256);\n\n    function decreaseValidatorDelegatedAmount(uint256 validatorId, uint256 amount) external;\n\n    function withdrawDelegatorsReward(uint256 validatorId) external returns (uint256);\n\n    function delegatorsReward(uint256 validatorId) external view returns (uint256);\n\n    function dethroneAndStake(\n        address auctionUser,\n        uint256 heimdallFee,\n        uint256 validatorId,\n        uint256 auctionAmount,\n        bool acceptDelegation,\n        bytes calldata signerPubkey\n    ) external;\n\n    function updateSigner(uint256 validatorId, bytes memory signerPubkey) external;\n\n    function validators(uint256 validatorId) external view returns (Validator memory);\n}\n"
    },
    "contracts/test/LivepeerMock.sol": {
      "content": "// SPDX-FileCopyrightText: 2021 Tenderize <info@tenderize.me>\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"./MockStaking.sol\";\n\ncontract LivepeerMock is MockStaking {\n    constructor(IERC20 _token) MockStaking(_token) {}\n\n    function bond(uint256 _amount, address _to) external reverted(this.bond.selector) {\n        require(token.transferFrom(msg.sender, address(this), _amount));\n        staked += _amount;\n    }\n\n    function unbond(uint256 _amount) external reverted(this.unbond.selector) {\n        staked -= _amount;\n        unstakeLocks[nextUnstakeLockID] = UnstakeLock({ amount: _amount, account: msg.sender });\n        nextUnstakeLockID++;\n    }\n\n    function rebondFromUnbonded(address _to, uint256 _unbondingLockId) external {\n        return;\n    }\n\n    function withdrawStake(uint256 _unbondingLockId) external reverted(this.withdrawStake.selector) {\n        token.transfer(unstakeLocks[_unbondingLockId].account, unstakeLocks[_unbondingLockId].amount);\n    }\n\n    function withdrawFees(address recipient, uint256 amount) external reverted(this.withdrawFees.selector) {\n        staked += secondaryRewards;\n        secondaryRewards = 0;\n    }\n\n    function pendingFees(address _delegator, uint256 _endRound) external view returns (uint256) {\n        return secondaryRewards;\n    }\n\n    function pendingStake(address _delegator, uint256 _endRound) external view returns (uint256) {\n        return staked;\n    }\n}\n"
    },
    "contracts/test/MaticMock.sol": {
      "content": "pragma solidity 0.8.4;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"./MockStaking.sol\";\n\ncontract MaticMock is MockStaking {\n    uint256 public constant validatorId = 1;\n    uint256 public constant exchangeRate = 100;\n\n    constructor(IERC20 _token) MockStaking(_token) {\n        nextUnstakeLockID = 1;\n    }\n\n    function owner() external view returns (address) {\n        return msg.sender;\n    }\n\n    function restake() public {\n        return;\n    }\n\n    function buyVoucher(uint256 _amount, uint256 _minSharesToMint) external reverted(this.buyVoucher.selector) {\n        require(token.transferFrom(msg.sender, address(this), _amount));\n        staked += _amount;\n    }\n\n    function sellVoucher_new(uint256 _claimAmount, uint256 _maximumSharesToBurn)\n        external\n        reverted(this.sellVoucher_new.selector)\n    {\n        staked -= _claimAmount;\n        unstakeLocks[nextUnstakeLockID] = UnstakeLock({ amount: _claimAmount, account: msg.sender });\n        nextUnstakeLockID++;\n    }\n\n    function unstakeClaimTokens_new(uint256 _unbondNonce) external reverted(this.unstakeClaimTokens_new.selector) {\n        token.transfer(unstakeLocks[_unbondNonce].account, unstakeLocks[_unbondNonce].amount);\n    }\n\n    function balanceOf(address _from) external view returns (uint256) {\n        return staked;\n    }\n}\n"
    },
    "contracts/test/MockStaking.sol": {
      "content": "// SPDX-FileCopyrightText: 2021 Tenderize <info@tenderize.me>\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ncontract MockStaking {\n    IERC20 token;\n\n    uint256 public staked;\n    uint256 secondaryRewards;\n\n    struct UnstakeLock {\n        uint256 amount;\n        address account;\n    }\n\n    mapping(uint256 => UnstakeLock) public unstakeLocks;\n    uint256 public nextUnstakeLockID;\n\n    mapping(bytes4 => bool) reverts;\n\n    modifier reverted(bytes4 _sel) {\n        require(!reverts[_sel]);\n        _;\n    }\n\n    constructor(IERC20 _token) {\n        token = _token;\n    }\n\n    function setStaked(uint256 _staked) public {\n        staked = _staked;\n    }\n\n    function setSecondaryRewards(uint256 _secondaryRewards) public {\n        secondaryRewards = _secondaryRewards;\n    }\n\n    function setReverts(bytes4 _sel, bool yn) public {\n        reverts[_sel] = yn;\n    }\n\n    function changePendingUndelegation(uint256 _unstakeLockID, uint256 _newAmount) external {\n        unstakeLocks[_unstakeLockID].amount = _newAmount;\n    }\n}\n"
    },
    "contracts/test/Proxy.sol": {
      "content": "// SPDX-License-Identifier: GNUV3\n\npragma solidity ^0.8.4;\n\nimport \"hardhat-deploy/solc_0.8/proxy/EIP173ProxyWithReceive.sol\";\n"
    },
    "contracts/test/SimpleToken.sol": {
      "content": "// SPDX-FileCopyrightText: 2021 Tenderize <info@tenderize.me>\n\n// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/draft-ERC20Permit.sol\";\n\n/**\n * @title SimpleToken\n * @dev Very simple ERC20 Token example, where all tokens are pre-assigned to the creator.\n * Note they can later distribute these tokens as they wish using `transfer` and other\n * `ERC20` functions.\n * Based on https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v2.5.1/contracts/examples/SimpleToken.sol\n */\ncontract SimpleToken is ERC20, ERC20Permit {\n    /**\n     * @dev Constructor that gives msg.sender all of existing tokens.\n     */\n    constructor(\n        string memory name,\n        string memory symbol,\n        uint256 initialSupply\n    ) ERC20(name, symbol) ERC20Permit(name) {\n        _mint(msg.sender, initialSupply);\n    }\n\n    /**\n     * @notice Mints the given amount of LPToken to the recipient.\n     * @dev only owner can call this mint function\n     * @param recipient address of account to receive the tokens\n     * @param amount amount of tokens to mint\n     */\n    function mint(address recipient, uint256 amount) external {\n        require(amount != 0, \"LPToken: cannot mint 0\");\n        _mint(recipient, amount);\n    }\n}\n"
    },
    "contracts/test/TestSwapReturnValues.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport \"../tenderswap/ITenderSwap.sol\";\nimport \"hardhat/console.sol\";\n\ncontract TestSwapReturnValues {\n    ITenderSwap public swap;\n    IERC20 public lpToken;\n    uint8 public n;\n\n    uint256 public constant MAX_INT = 2**256 - 1;\n\n    constructor(ITenderSwap swapContract, IERC20 lpTokenContract) {\n        swap = swapContract;\n        lpToken = lpTokenContract;\n        // num tokens\n        n = 2;\n\n        // Pre-approve tokens\n        swap.getToken0().approve(address(swap), MAX_INT);\n        swap.getToken1().approve(address(swap), MAX_INT);\n        lpToken.approve(address(swap), MAX_INT);\n    }\n\n    function test_swap(\n        IERC20 tokenFrom,\n        uint256 dx,\n        uint256 minDy\n    ) public {\n        IERC20 tokenTo = tokenFrom == swap.getToken0() ? swap.getToken1() : swap.getToken0();\n        uint256 balanceBefore = tokenTo.balanceOf(address(this));\n        uint256 returnValue = swap.swap(tokenFrom, dx, minDy, block.timestamp);\n        uint256 balanceAfter = tokenTo.balanceOf(address(this));\n\n        console.log(\"swap: Expected %s, got %s\", balanceAfter - balanceBefore, returnValue);\n\n        require(returnValue == balanceAfter - balanceBefore, \"swap()'s return value does not match received amount\");\n    }\n\n    function test_addLiquidity(uint256[2] calldata amounts, uint256 minToMint) public {\n        uint256 balanceBefore = lpToken.balanceOf(address(this));\n        uint256 returnValue = swap.addLiquidity(amounts, minToMint, MAX_INT);\n        uint256 balanceAfter = lpToken.balanceOf(address(this));\n\n        console.log(\"addLiquidity: Expected %s, got %s\", balanceAfter - balanceBefore, returnValue);\n\n        require(\n            returnValue == balanceAfter - balanceBefore,\n            \"addLiquidity()'s return value does not match minted amount\"\n        );\n    }\n\n    function test_removeLiquidity(uint256 amount, uint256[2] memory minAmounts) public {\n        uint256[] memory balanceBefore = new uint256[](n);\n        uint256[] memory balanceAfter = new uint256[](n);\n\n        {\n            balanceBefore[0] = swap.getToken0().balanceOf(address(this));\n            balanceBefore[1] = swap.getToken1().balanceOf(address(this));\n        }\n\n        uint256[2] memory returnValue = swap.removeLiquidity(amount, minAmounts, MAX_INT);\n\n        {\n            balanceAfter[0] = swap.getToken0().balanceOf(address(this));\n            balanceAfter[1] = swap.getToken1().balanceOf(address(this));\n        }\n\n        for (uint8 i = 0; i < n; i++) {\n            console.log(\"removeLiquidity: Expected %s, got %s\", balanceAfter[i] - balanceBefore[i], returnValue[i]);\n            require(\n                balanceAfter[i] - balanceBefore[i] == returnValue[i],\n                \"removeLiquidity()'s return value does not match received amounts of tokens\"\n            );\n        }\n    }\n\n    function test_removeLiquidityImbalance(uint256[2] calldata amounts, uint256 maxBurnAmount) public {\n        uint256 balanceBefore = lpToken.balanceOf(address(this));\n        uint256 returnValue = swap.removeLiquidityImbalance(amounts, maxBurnAmount, MAX_INT);\n        uint256 balanceAfter = lpToken.balanceOf(address(this));\n\n        console.log(\"removeLiquidityImbalance: Expected %s, got %s\", balanceBefore - balanceAfter, returnValue);\n\n        require(\n            returnValue == balanceBefore - balanceAfter,\n            \"removeLiquidityImbalance()'s return value does not match burned lpToken amount\"\n        );\n    }\n\n    function test_removeLiquidityOneToken(\n        uint256 tokenAmount,\n        IERC20 tokenReceive,\n        uint256 minAmount\n    ) public {\n        uint256 balanceBefore = tokenReceive.balanceOf(address(this));\n        uint256 returnValue = swap.removeLiquidityOneToken(tokenAmount, tokenReceive, minAmount, MAX_INT);\n        uint256 balanceAfter = tokenReceive.balanceOf(address(this));\n\n        console.log(\"removeLiquidityOneToken: Expected %s, got %s\", balanceAfter - balanceBefore, returnValue);\n\n        require(\n            returnValue == balanceAfter - balanceBefore,\n            \"removeLiquidityOneToken()'s return value does not match received token amount\"\n        );\n    }\n}\n"
    },
    "contracts/test/UniswapPoolMock.sol": {
      "content": "// SPDX-FileCopyrightText: 2021 Tenderize <info@tenderize.me>\n\n// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\ncontract UniswapPoolMock {\n    struct Slot0 {\n        // the current price\n        uint160 sqrtPriceX96;\n        // the current tick\n        int24 tick;\n        // the most-recently updated index of the observations array\n        uint16 observationIndex;\n        // the current maximum number of observations that are being stored\n        uint16 observationCardinality;\n        // the next maximum number of observations to store, triggered in observations.write\n        uint16 observationCardinalityNext;\n        // the current protocol fee as a percentage of the swap fee taken on withdrawal\n        // represented as an integer denominator (1/x)%\n        uint8 feeProtocol;\n        // whether the pool is locked\n        bool unlocked;\n    }\n\n    function slot0() external returns (Slot0 memory _slot0) {}\n}\n"
    },
    "contracts/test/UniswapRouterMock.sol": {
      "content": "// SPDX-FileCopyrightText: 2021 Tenderize <info@tenderize.me>\n\n// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ncontract UniswapRouterMock {\n    struct ExactInputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    function WETH9() external returns (address) {}\n\n    function exactInputSingle(ExactInputSingleParams calldata params) external payable returns (uint256 amountOut) {}\n}\n"
    },
    "contracts/test/WETHMock.sol": {
      "content": "// SPDX-FileCopyrightText: 2021 Tenderize <info@tenderize.me>\n\n// SPDX-License-Identifier: MIT\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\npragma solidity 0.8.4;\n\ncontract WETHMock is ERC20 {\n    constructor() ERC20(\"WrappedETH\", \"WETH\") {}\n\n    function deposit() external payable {}\n}\n"
    },
    "contracts/token/ITenderToken.sol": {
      "content": "// SPDX-FileCopyrightText: 2021 Tenderize <info@tenderize.me>\n\n// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport \"../tenderizer/ITotalStakedReader.sol\";\n\n/**\n * @title Interest-bearing ERC20-like token for Tenderize protocol.\n * @author Tenderize <info@tenderize.me>\n * @dev TenderToken balances are dynamic and are calculated based on the accounts' shares\n * and the total amount of Tokens controlled by the protocol. Account shares aren't\n * normalized, so the contract also stores the sum of all shares to calculate\n * each account's token balance which equals to:\n *\n * shares[account] * _getTotalPooledTokens() / _getTotalShares()\n */\ninterface ITenderToken {\n    /**\n     * @notice Initilize the TenderToken Contract\n     * @param _name name of the token (steak)\n     * @param _symbol symbol of the token (steak)\n     * @param _stakedReader contract address implementing the ITotalStakedReader interface\n     * @return a boolean value indicating whether the init succeeded.\n     */\n    function initialize(\n        string memory _name,\n        string memory _symbol,\n        ITotalStakedReader _stakedReader\n    ) external returns (bool);\n\n    /**\n     * @notice The number of decimals the TenderToken uses.\n     * @return decimals the number of decimals for getting user representation of a token amount.\n     */\n    function decimals() external pure returns (uint8);\n\n    /**\n     * @notice The total supply of tender tokens in existence.\n     * @dev Always equals to `_getTotalPooledTokens()` since token amount\n     * is pegged to the total amount of Tokens controlled by the protocol.\n     * @return totalSupply total supply\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @notice Total amount of underlying tokens controlled by the Tenderizer.\n     * @dev The sum of all Tokens balances in the protocol, equals to the total supply of TenderToken.\n     * @return totalPooledTokens total amount of pooled tokens\n     */\n    function getTotalPooledTokens() external view returns (uint256);\n\n    /**\n     * @notice The total amount of shares in existence.\n     * @dev The sum of all accounts' shares can be an arbitrary number, therefore\n     * it is necessary to store it in order to calculate each account's relative share.\n     * @return totalShares total amount of shares\n     */\n    function getTotalShares() external view returns (uint256);\n\n    /**\n     * @notice the amount of tokens owned by the `_account`.\n     * @dev Balances are dynamic and equal the `_account`'s share in the amount of the\n        total Tokens controlled by the protocol. See `sharesOf`.\n     * @param _account address of the account to check the balance for\n     * @return balance token balance of `_account`\n     */\n    function balanceOf(address _account) external view returns (uint256);\n\n    /**\n     * @notice The amount of shares owned by an account\n     * @param _account address of the account\n     * @return shares the amount of shares owned by `_account`.\n     */\n    function sharesOf(address _account) external view returns (uint256);\n\n    /**\n     * @notice The remaining number of tokens that `_spender` is allowed to spend\n     * behalf of `_owner` through `transferFrom`. This is zero by default.\n     * @dev This value changes when `approve` or `transferFrom` is called.\n     * @param _owner address that approved the allowance\n     * @param _spender address that is allowed to spend the allowance\n     * @return allowance amount '_spender' is allowed to spend from '_owner'\n     */\n    function allowance(address _owner, address _spender) external view returns (uint256);\n\n    /**\n     * @notice The amount of shares that corresponds to `_tokens` protocol-controlled Tokens.\n     * @param _tokens amount of tokens to calculate shares for\n     * @return shares nominal amount of shares the tokens represent\n     */\n    function tokensToShares(uint256 _tokens) external view returns (uint256);\n\n    /**\n     * @notice The amount of tokens that corresponds to `_shares` token shares.\n     * @param _shares the amount of shares to calculate the amount of tokens for\n     * @return tokens the amount of tokens represented by the shares\n     */\n    function sharesToTokens(uint256 _shares) external view returns (uint256);\n\n    /**\n     * @notice Transfers `_amount` tokens from the caller's account to the `_recipient` account.\n     * @param _recipient address of the recipient\n     * @param _amount amount of tokens to transfer\n     * @return success a boolean value indicating whether the operation succeeded.\n     * @dev Emits a `Transfer` event.\n     * @dev Requirements:\n     * - `_recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `_amount`.\n     * @dev The `_amount` argument is the amount of tokens, not shares.\n     */\n    function transfer(address _recipient, uint256 _amount) external returns (bool);\n\n    /**\n     * @notice Sets `_amount` as the allowance of `_spender` over the caller's tokens.\n     * @param _spender address of the spender allowed to approve tokens from caller\n     * @param _amount amount of tokens to allow '_spender' to spend\n     * @return success a boolean value indicating whether the operation succeeded.\n     * @dev Emits an `Approval` event.\n     * @dev Requirements:\n     * - `_spender` cannot be the zero address.\n     * @dev The `_amount` argument is the amount of tokens, not shares.\n     */\n    function approve(address _spender, uint256 _amount) external returns (bool);\n\n    /**\n     * @notice Transfers `_amount` tokens from `_sender` to `_recipient` using the\n     * allowance mechanism. `_amount` is then deducted from the caller's allowance.\n     * @param _sender address of the account to transfer tokens from\n     * @param _recipient address of the recipient\n     * @return success a boolean value indicating whether the operation succeeded.\n     * @dev Emits a `Transfer` event.\n     * @dev Emits an `Approval` event indicating the updated allowance.\n     * @dev Requirements:\n     * - `_sender` and `_recipient` cannot be the zero addresses.\n     * - `_sender` must have a balance of at least `_amount`.\n     * - the caller must have allowance for `_sender`'s tokens of at least `_amount`.\n     * @dev The `_amount` argument is the amount of tokens, not shares.\n     */\n    function transferFrom(\n        address _sender,\n        address _recipient,\n        uint256 _amount\n    ) external returns (bool);\n\n    /**\n     * @notice Atomically increases the allowance granted to `_spender` by the caller by `_addedValue`.\n     * @param _spender address of the spender allowed to approve tokens from caller\n     * @param _addedValue amount to add to allowance\n     * @return success a boolean value indicating whether the operation succeeded.\n     * @dev This is an alternative to `approve` that can be used as a mitigation for problems described in:\n     * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/IERC20.sol#L42\n     * @dev Emits an `Approval` event indicating the updated allowance.\n     * @dev Requirements:\n     * - `_spender` cannot be the the zero address.\n     */\n    function increaseAllowance(address _spender, uint256 _addedValue) external returns (bool);\n\n    /**\n     * @notice Atomically decreases the allowance granted to `_spender` by the caller by `_subtractedValue`.\n     * @param _spender address of the spender allowed to approve tokens from caller\n     * @param _subtractedValue amount to subtract from current allowance\n     * @return success a boolean value indicating whether the operation succeeded.\n     * @dev This is an alternative to `approve` that can be used as a mitigation for problems described in:\n     * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/IERC20.sol#L42\n     * @dev Emits an `Approval` event indicating the updated allowance.\n     * @dev Requirements:\n     * - `_spender` cannot be the zero address.\n     * - `_spender` must have allowance for the caller of at least `_subtractedValue`.\n     */\n    function decreaseAllowance(address _spender, uint256 _subtractedValue) external returns (bool);\n\n    /**\n     * @notice Mints '_amount' of tokens for '_recipient'\n     * @param _recipient address to mint tokens for\n     * @param _amount amount to mint\n     * @return success a boolean value indicating whether the operation succeeded.\n     * @dev Only callable by contract owner\n     * @dev Calculates the amount of shares to create based on the specified '_amount'\n     * and creates new shares rather than minting actual tokens\n     * @dev '_recipient' should also deposit into Tenderizer\n     * atomically to prevent diluation of existing particpants\n     */\n    function mint(address _recipient, uint256 _amount) external returns (bool);\n\n    /**\n     * @notice Burns '_amount' of tokens from '_recipient'\n     * @param _account address to burn the tokens from\n     * @param _amount amount to burn\n     * @return success a boolean value indicating whether the operation succeeded.\n     * @dev Only callable by contract owner\n     * @dev Calculates the amount of shares to destroy based on the specified '_amount'\n     * and destroy shares rather than burning tokens\n     * @dev '_recipient' should also withdraw from Tenderizer atomically\n     */\n    function burn(address _account, uint256 _amount) external returns (bool);\n\n    /**\n     * @notice sets a TotalStakedReader to read the total staked tokens from\n     * @param _stakedReader contract address implementing the ITotalStakedReader interface\n     * @dev Only callable by contract owner.\n     * @dev Used to determine TenderToken total supply.\n     */\n    function setTotalStakedReader(ITotalStakedReader _stakedReader) external;\n}\n"
    },
    "contracts/token/TenderToken.sol": {
      "content": "// SPDX-FileCopyrightText: 2021 Tenderize <info@tenderize.me>\n\n// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"../libs/MathUtils.sol\";\nimport \"../tenderizer/ITotalStakedReader.sol\";\nimport \"./ITenderToken.sol\";\n// solhint-disable-next-line max-line-length\nimport { ERC20Upgradeable, ERC20PermitUpgradeable } from \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/draft-ERC20PermitUpgradeable.sol\";\n\n/**\n * @title Interest-bearing ERC20-like token for Tenderize protocol.\n * @author Tenderize <info@tenderize.me>\n * @dev TenderToken balances are dynamic and are calculated based on the accounts' shares\n * and the total amount of Tokens controlled by the protocol. Account shares aren't\n * normalized, so the contract also stores the sum of all shares to calculate\n * each account's token balance which equals to:\n *\n * shares[account] * _getTotalPooledTokens() / _getTotalShares()\n */\ncontract TenderToken is OwnableUpgradeable, ERC20PermitUpgradeable, ITenderToken {\n    uint8 internal constant DECIMALS = 18;\n\n    /**\n     * @dev Total amount of outstanding shares\n     */\n    uint256 private totalShares;\n\n    /**\n     * @dev Nominal amount of shares held by each account\n     */\n    mapping(address => uint256) private shares;\n\n    /**\n     * @dev Allowances nominated in tokens, not token shares.\n     */\n    mapping(address => mapping(address => uint256)) private allowances;\n\n    /**\n     * @dev Tenderizer address, to read total staked tokens\n     */\n    ITotalStakedReader public totalStakedReader;\n\n    /// @inheritdoc ITenderToken\n    function initialize(\n        string memory _name,\n        string memory _symbol,\n        ITotalStakedReader _totalStakedReader\n    ) external override initializer returns (bool) {\n        __Context_init_unchained();\n        __Ownable_init_unchained();\n        __ERC20_init_unchained(string(abi.encodePacked(\"tender \", _name)), string(abi.encodePacked(\"t\", _symbol)));\n        __EIP712_init_unchained(string(abi.encodePacked(\"tender \", _name)), \"1\");\n        __ERC20Permit_init_unchained(string(abi.encodePacked(\"tender \", _name)));\n        totalStakedReader = _totalStakedReader;\n        return true;\n    }\n\n    /// @inheritdoc ITenderToken\n    function decimals() public pure override(ITenderToken, ERC20Upgradeable) returns (uint8) {\n        return DECIMALS;\n    }\n\n    /// @inheritdoc ITenderToken\n    function totalSupply() public view override(ITenderToken, ERC20Upgradeable) returns (uint256) {\n        return _getTotalPooledTokens();\n    }\n\n    /// @inheritdoc ITenderToken\n    function getTotalPooledTokens() external view override returns (uint256) {\n        return _getTotalPooledTokens();\n    }\n\n    /// @inheritdoc ITenderToken\n    function getTotalShares() external view override returns (uint256) {\n        return _getTotalShares();\n    }\n\n    /// @inheritdoc ITenderToken\n    function balanceOf(address _account) public view override(ITenderToken, ERC20Upgradeable) returns (uint256) {\n        return _sharesToTokens(_sharesOf(_account));\n    }\n\n    /// @inheritdoc ITenderToken\n    function sharesOf(address _account) external view override returns (uint256) {\n        return _sharesOf(_account);\n    }\n\n    /// @inheritdoc ITenderToken\n    function allowance(address _owner, address _spender)\n        public\n        view\n        override(ITenderToken, ERC20Upgradeable)\n        returns (uint256)\n    {\n        return allowances[_owner][_spender];\n    }\n\n    /// @inheritdoc ITenderToken\n    function tokensToShares(uint256 _tokens) external view override returns (uint256) {\n        return _tokensToShares(_tokens);\n    }\n\n    /// @inheritdoc ITenderToken\n    function sharesToTokens(uint256 _shares) external view override returns (uint256) {\n        return _sharesToTokens(_shares);\n    }\n\n    /// @inheritdoc ITenderToken\n    function transfer(address _recipient, uint256 _amount)\n        public\n        override(ITenderToken, ERC20Upgradeable)\n        returns (bool)\n    {\n        _transfer(msg.sender, _recipient, _amount);\n        return true;\n    }\n\n    /// @inheritdoc ITenderToken\n    function approve(address _spender, uint256 _amount) public override(ITenderToken, ERC20Upgradeable) returns (bool) {\n        _approve(msg.sender, _spender, _amount);\n        return true;\n    }\n\n    /// @inheritdoc ITenderToken\n    function transferFrom(\n        address _sender,\n        address _recipient,\n        uint256 _amount\n    ) public override(ITenderToken, ERC20Upgradeable) returns (bool) {\n        uint256 currentAllowance = allowances[_sender][msg.sender];\n        require(currentAllowance >= _amount, \"TRANSFER_AMOUNT_EXCEEDS_ALLOWANCE\");\n\n        _transfer(_sender, _recipient, _amount);\n        _approve(_sender, msg.sender, currentAllowance - _amount);\n        return true;\n    }\n\n    /// @inheritdoc ITenderToken\n    function increaseAllowance(address _spender, uint256 _addedValue)\n        public\n        override(ITenderToken, ERC20Upgradeable)\n        returns (bool)\n    {\n        _approve(msg.sender, _spender, allowances[msg.sender][_spender] + _addedValue);\n        return true;\n    }\n\n    /// @inheritdoc ITenderToken\n    function decreaseAllowance(address _spender, uint256 _subtractedValue)\n        public\n        override(ITenderToken, ERC20Upgradeable)\n        returns (bool)\n    {\n        uint256 currentAllowance = allowances[msg.sender][_spender];\n        require(currentAllowance >= _subtractedValue, \"DECREASED_ALLOWANCE_BELOW_ZERO\");\n        _approve(msg.sender, _spender, currentAllowance - _subtractedValue);\n        return true;\n    }\n\n    /// @inheritdoc ITenderToken\n    function mint(address _recipient, uint256 _amount) external override onlyOwner returns (bool) {\n        _mintShares(_recipient, _tokensToShares(_amount));\n        return true;\n    }\n\n    /// @inheritdoc ITenderToken\n    function burn(address _account, uint256 _amount) external override onlyOwner returns (bool) {\n        uint256 _sharesToburn = _tokensToShares(_amount);\n        _burnShares(_account, _sharesToburn);\n        return true;\n    }\n\n    /// @inheritdoc ITenderToken\n    function setTotalStakedReader(ITotalStakedReader _totalStakedReader) external override onlyOwner {\n        require(address(_totalStakedReader) != address(0));\n        totalStakedReader = _totalStakedReader;\n    }\n\n    // INTERNAL FUNCTIONS\n\n    /**\n     * @return the total amount (in 10e18) of Tokens controlled by the protocol.\n     * @dev This is used for calculating tokens from shares and vice versa.\n     * @dev This function is required to be implemented in a derived contract.\n     */\n    function _getTotalPooledTokens() internal view returns (uint256) {\n        return totalStakedReader.totalStakedTokens();\n    }\n\n    /**\n     * @dev Moves `_amount` tokens from `_sender` to `_recipient`.\n     * @dev Emits a `Transfer` event.\n     */\n    function _transfer(\n        address _sender,\n        address _recipient,\n        uint256 _amount\n    ) internal override {\n        uint256 _sharesToTransfer = _tokensToShares(_amount);\n        _transferShares(_sender, _recipient, _sharesToTransfer);\n        emit Transfer(_sender, _recipient, _amount);\n    }\n\n    /**\n     * @dev Sets `_amount` as the allowance of `_spender` over the `_owner` s tokens.\n     * @dev Emits an `Approval` event.\n     */\n    function _approve(\n        address _owner,\n        address _spender,\n        uint256 _amount\n    ) internal override {\n        require(_owner != address(0), \"APPROVE_FROM_ZERO_ADDRESS\");\n        require(_spender != address(0), \"APPROVE_TO_ZERO_ADDRESS\");\n\n        allowances[_owner][_spender] = _amount;\n        emit Approval(_owner, _spender, _amount);\n    }\n\n    /**\n     * @dev the total amount of shares in existence.\n     */\n    function _getTotalShares() internal view returns (uint256) {\n        return totalShares;\n    }\n\n    /**\n     * @dev the amount of shares owned by `_account`.\n     */\n    function _sharesOf(address _account) internal view returns (uint256) {\n        return shares[_account];\n    }\n\n    /**\n     * @dev Moves `_shares` shares from `_sender` to `_recipient`.\n     * @dev Requirements:\n     * - `_sender` cannot be the zero address.\n     * - `_recipient` cannot be the zero address.\n     * - `_sender` must hold at least `_shares` shares.\n     */\n    function _transferShares(\n        address _sender,\n        address _recipient,\n        uint256 _shares\n    ) internal {\n        require(_sender != address(0), \"TRANSFER_FROM_THE_ZERO_ADDRESS\");\n        require(_recipient != address(0), \"TRANSFER_TO_THE_ZERO_ADDRESS\");\n\n        uint256 currentSenderShares = shares[_sender];\n        require(_shares <= currentSenderShares, \"TRANSFER_AMOUNT_EXCEEDS_BALANCE\");\n\n        shares[_sender] = currentSenderShares - _shares;\n        shares[_recipient] += _shares;\n    }\n\n    /**\n     * @dev Creates `_shares` shares and assigns them to `_recipient`, increasing the total amount of shares.\n     * @dev This doesn't increase the token total supply.\n     * @dev Requirements:\n     * - `_recipient` cannot be the zero address.\n     */\n    function _mintShares(address _recipient, uint256 _shares) internal {\n        require(_recipient != address(0), \"MINT_TO_THE_ZERO_ADDRESS\");\n\n        shares[_recipient] += _shares;\n\n        // Notice: we're not emitting a Transfer event from the zero address here since shares mint\n        // works by taking the amount of tokens corresponding to the minted shares from all other\n        // token holders, proportionally to their share. The total supply of the token doesn't change\n        // as the result. This is equivalent to performing a send from each other token holder's\n        // address to `address`, but we cannot reflect this as it would require sending an unbounded\n        // number of events.\n        totalShares += _shares;\n    }\n\n    /**\n     * @dev Destroys `_shares` shares from `_account`'s holdings, decreasing the total amount of shares.\n     * @dev This doesn't decrease the token total supply.\n     * @dev Requirements:\n     * - `_account` cannot be the zero address.\n     * - `_account` must hold at least `_shares` shares.\n     */\n    function _burnShares(address _account, uint256 _shares) internal returns (uint256 newTotalShares) {\n        require(_account != address(0), \"BURN_FROM_THE_ZERO_ADDRESS\");\n\n        uint256 accountShares = shares[_account];\n        require(_shares <= accountShares, \"BURN_AMOUNT_EXCEEDS_BALANCE\");\n\n        newTotalShares = totalShares - _shares;\n\n        shares[_account] = accountShares - _shares;\n\n        // Notice: we're not emitting a Transfer event to the zero address here since shares burn\n        // works by redistributing the amount of tokens corresponding to the burned shares between\n        // all other token holders. The total supply of the token doesn't change as the result.\n        // This is equivalent to performing a send from `address` to each other token holder address,\n        // but we cannot reflect this as it would require sending an unbounded number of events.\n        totalShares = newTotalShares;\n    }\n\n    function _tokensToShares(uint256 _tokens) internal view returns (uint256) {\n        uint256 _totalPooledTokens = _getTotalPooledTokens();\n        uint256 _totalShares = _getTotalShares();\n        if (_totalShares == 0) {\n            return _tokens;\n        } else if (_totalPooledTokens == 0) {\n            return 0;\n        } else {\n            return MathUtils.percOf(_tokens, _totalShares, _totalPooledTokens);\n        }\n    }\n\n    function _sharesToTokens(uint256 _shares) internal view returns (uint256) {\n        uint256 _totalShares = _getTotalShares();\n        if (_totalShares == 0) {\n            return _shares;\n        } else {\n            return MathUtils.percOf(_shares, _getTotalPooledTokens(), _totalShares);\n        }\n    }\n}\n"
    },
    "hardhat-deploy/solc_0.8/proxy/EIP173Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./Proxy.sol\";\n\ninterface ERC165 {\n    function supportsInterface(bytes4 id) external view returns (bool);\n}\n\n///@notice Proxy implementing EIP173 for ownership management\ncontract EIP173Proxy is Proxy {\n    // ////////////////////////// EVENTS ///////////////////////////////////////////////////////////////////////\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    // /////////////////////// CONSTRUCTOR //////////////////////////////////////////////////////////////////////\n\n    constructor(\n        address implementationAddress,\n        address ownerAddress,\n        bytes memory data\n    ) payable {\n        _setImplementation(implementationAddress, data);\n        _setOwner(ownerAddress);\n    }\n\n    // ///////////////////// EXTERNAL ///////////////////////////////////////////////////////////////////////////\n\n    function owner() external view returns (address) {\n        return _owner();\n    }\n\n    function supportsInterface(bytes4 id) external view returns (bool) {\n        if (id == 0x01ffc9a7 || id == 0x7f5828d0) {\n            return true;\n        }\n        if (id == 0xFFFFFFFF) {\n            return false;\n        }\n\n        ERC165 implementation;\n        // solhint-disable-next-line security/no-inline-assembly\n        assembly {\n            implementation := sload(0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc)\n        }\n\n        // Technically this is not standard compliant as ERC-165 require 30,000 gas which that call cannot ensure\n        // because it is itself inside `supportsInterface` that might only get 30,000 gas.\n        // In practise this is unlikely to be an issue.\n        try implementation.supportsInterface(id) returns (bool support) {\n            return support;\n        } catch {\n            return false;\n        }\n    }\n\n    function transferOwnership(address newOwner) external onlyOwner {\n        _setOwner(newOwner);\n    }\n\n    function upgradeTo(address newImplementation) external onlyOwner {\n        _setImplementation(newImplementation, \"\");\n    }\n\n    function upgradeToAndCall(address newImplementation, bytes calldata data) external payable onlyOwner {\n        _setImplementation(newImplementation, data);\n    }\n\n    // /////////////////////// MODIFIERS ////////////////////////////////////////////////////////////////////////\n\n    modifier onlyOwner() {\n        require(msg.sender == _owner(), \"NOT_AUTHORIZED\");\n        _;\n    }\n\n    // ///////////////////////// INTERNAL //////////////////////////////////////////////////////////////////////\n\n    function _owner() internal view returns (address adminAddress) {\n        // solhint-disable-next-line security/no-inline-assembly\n        assembly {\n            adminAddress := sload(0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103)\n        }\n    }\n\n    function _setOwner(address newOwner) internal {\n        address previousOwner = _owner();\n        // solhint-disable-next-line security/no-inline-assembly\n        assembly {\n            sstore(0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103, newOwner)\n        }\n        emit OwnershipTransferred(previousOwner, newOwner);\n    }\n}\n"
    },
    "hardhat-deploy/solc_0.8/proxy/EIP173ProxyWithReceive.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./EIP173Proxy.sol\";\n\n///@notice Proxy implementing EIP173 for ownership management that accept ETH via receive\ncontract EIP173ProxyWithReceive is EIP173Proxy {\n    constructor(\n        address implementationAddress,\n        address ownerAddress,\n        bytes memory data\n    ) payable EIP173Proxy(implementationAddress, ownerAddress, data) {}\n\n    receive() external payable override {}\n}\n"
    },
    "hardhat-deploy/solc_0.8/proxy/Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// EIP-1967\nabstract contract Proxy {\n    // /////////////////////// EVENTS ///////////////////////////////////////////////////////////////////////////\n\n    event ProxyImplementationUpdated(address indexed previousImplementation, address indexed newImplementation);\n\n    // ///////////////////// EXTERNAL ///////////////////////////////////////////////////////////////////////////\n\n    receive() external payable virtual {\n        revert(\"ETHER_REJECTED\"); // explicit reject by default\n    }\n\n    fallback() external payable {\n        _fallback();\n    }\n\n    // ///////////////////////// INTERNAL //////////////////////////////////////////////////////////////////////\n\n    function _fallback() internal {\n        // solhint-disable-next-line security/no-inline-assembly\n        assembly {\n            let implementationAddress := sload(0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc)\n            calldatacopy(0x0, 0x0, calldatasize())\n            let success := delegatecall(gas(), implementationAddress, 0x0, calldatasize(), 0, 0)\n            let retSz := returndatasize()\n            returndatacopy(0, 0, retSz)\n            switch success\n            case 0 {\n                revert(0, retSz)\n            }\n            default {\n                return(0, retSz)\n            }\n        }\n    }\n\n    function _setImplementation(address newImplementation, bytes memory data) internal {\n        address previousImplementation;\n        // solhint-disable-next-line security/no-inline-assembly\n        assembly {\n            previousImplementation := sload(0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc)\n        }\n\n        // solhint-disable-next-line security/no-inline-assembly\n        assembly {\n            sstore(0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc, newImplementation)\n        }\n\n        emit ProxyImplementationUpdated(previousImplementation, newImplementation);\n\n        if (data.length > 0) {\n            (bool success, ) = newImplementation.delegatecall(data);\n            if (!success) {\n                assembly {\n                    // This assembly ensure the revert contains the exact string data\n                    let returnDataSize := returndatasize()\n                    returndatacopy(0, 0, returnDataSize)\n                    revert(0, returnDataSize)\n                }\n            }\n        }\n    }\n}\n"
    },
    "hardhat/console.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >= 0.4.22 <0.9.0;\n\nlibrary console {\n\taddress constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\n\n\tfunction _sendLogPayload(bytes memory payload) private view {\n\t\tuint256 payloadLength = payload.length;\n\t\taddress consoleAddress = CONSOLE_ADDRESS;\n\t\tassembly {\n\t\t\tlet payloadStart := add(payload, 32)\n\t\t\tlet r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\n\t\t}\n\t}\n\n\tfunction log() internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log()\"));\n\t}\n\n\tfunction logInt(int256 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(int256)\", p0));\n\t}\n\n\tfunction logUint(uint256 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n\t}\n\n\tfunction logString(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction logBool(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction logAddress(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction logBytes(bytes memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n\t}\n\n\tfunction logBytes1(bytes1 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n\t}\n\n\tfunction logBytes2(bytes2 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n\t}\n\n\tfunction logBytes3(bytes3 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n\t}\n\n\tfunction logBytes4(bytes4 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n\t}\n\n\tfunction logBytes5(bytes5 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n\t}\n\n\tfunction logBytes6(bytes6 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n\t}\n\n\tfunction logBytes7(bytes7 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n\t}\n\n\tfunction logBytes8(bytes8 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n\t}\n\n\tfunction logBytes9(bytes9 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n\t}\n\n\tfunction logBytes10(bytes10 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n\t}\n\n\tfunction logBytes11(bytes11 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n\t}\n\n\tfunction logBytes12(bytes12 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n\t}\n\n\tfunction logBytes13(bytes13 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n\t}\n\n\tfunction logBytes14(bytes14 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n\t}\n\n\tfunction logBytes15(bytes15 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n\t}\n\n\tfunction logBytes16(bytes16 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n\t}\n\n\tfunction logBytes17(bytes17 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n\t}\n\n\tfunction logBytes18(bytes18 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n\t}\n\n\tfunction logBytes19(bytes19 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n\t}\n\n\tfunction logBytes20(bytes20 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n\t}\n\n\tfunction logBytes21(bytes21 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n\t}\n\n\tfunction logBytes22(bytes22 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n\t}\n\n\tfunction logBytes23(bytes23 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n\t}\n\n\tfunction logBytes24(bytes24 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n\t}\n\n\tfunction logBytes25(bytes25 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n\t}\n\n\tfunction logBytes26(bytes26 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n\t}\n\n\tfunction logBytes27(bytes27 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n\t}\n\n\tfunction logBytes28(bytes28 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n\t}\n\n\tfunction logBytes29(bytes29 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n\t}\n\n\tfunction logBytes30(bytes30 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n\t}\n\n\tfunction logBytes31(bytes31 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n\t}\n\n\tfunction logBytes32(bytes32 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n\t}\n\n\tfunction log(uint256 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n\t}\n\n\tfunction log(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction log(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction log(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256)\", p0, p1));\n\t}\n\n\tfunction log(uint256 p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string)\", p0, p1));\n\t}\n\n\tfunction log(uint256 p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool)\", p0, p1));\n\t}\n\n\tfunction log(uint256 p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, uint256 p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, uint256 p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n\t}\n\n\tfunction log(address p0, uint256 p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256)\", p0, p1));\n\t}\n\n\tfunction log(address p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n\t}\n\n\tfunction log(address p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n\t}\n\n\tfunction log(address p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}