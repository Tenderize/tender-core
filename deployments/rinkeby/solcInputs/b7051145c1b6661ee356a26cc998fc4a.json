{
  "language": "Solidity",
  "sources": {
    "contracts/Controller.sol": {
      "content": "// // SPDX-FileCopyrightText: 2020 Tenderize <info@tenderize.me>\n\n// // SPDX-License-Identifier: GPL-3.0\n\n// /* See contracts/COMPILERS.md */\npragma solidity 0.8.4;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\nimport \"./token/ITenderToken.sol\";\nimport \"./tenderizer/ITenderizer.sol\";\nimport \"./liquidity/IElasticSupplyPool.sol\";\nimport \"./liquidity/ITenderFarm.sol\";\n\n/**\n * @title Controller contract for a Tenderizer\n */\n\ncontract Controller is Ownable, ReentrancyGuard {\n    IERC20 public steak;\n    ITenderizer public tenderizer;\n    ITenderToken public tenderToken;\n    IElasticSupplyPool public esp;\n    ITenderFarm public tenderFarm;\n\n    constructor(\n        IERC20 _steak,\n        ITenderizer _tenderizer,\n        ITenderToken _tenderToken,\n        IElasticSupplyPool _esp\n    ) {\n        steak = _steak;\n        tenderizer = _tenderizer;\n        // TODO: consider deploying these contracts using factories and proxies\n        // from the constructutor so that deploying a new system is only deploying a single contract\n        tenderToken = _tenderToken;\n        esp = _esp;\n    }\n\n    /**\n     * @notice Deposit tokens in Tenderizer to earn staking rewards\n     * @param _amount amount deposited\n     * @dev calls Tenderizer to deposit tokens and updates total pooled tokens\n     * @dev equal amount of tenderTokens are minted for the caller\n     * @dev requires '_amount' to be approved by '_from'\n     */\n    function deposit(uint256 _amount) public {\n        require(_amount > 0, \"ZERO_AMOUNT\");\n\n        // mint tenderTokens\n        require(tenderToken.mint(msg.sender, _amount), \"TENDER_MINT_FAILED\");\n\n        tenderizer.deposit(msg.sender, _amount);\n\n        _updateTotalPooledTokens();\n\n        // Transfer tokens to tenderizer\n        require(steak.transferFrom(msg.sender, address(tenderizer), _amount), \"STEAK_TRANSFERFROM_FAILED\");\n    }\n\n    /**\n     * @notice Unlock staked tokens\n     * @param _amount amount deposited\n     * @return unstakeLockID \n     * @dev calls Tenderizer to unstake tokens and updates total pooled tokens\n     * @dev equal amount of tenderTokens are burned from the user\n     * @dev unstaking functionality varies by the protocol, check tenderizer.unstake()\n     */\n    function unlock(uint256 _amount) public nonReentrant returns (uint256 unstakeLockID) {\n        require(_amount > 0, \"ZERO_AMOUNT\");\n        // Burn tenderTokens\n        require(tenderToken.burn(msg.sender, _amount), \"TENDER_BURN_FAILED\");\n\n        // Unstake tokens for pending withdrawal\n        unstakeLockID = tenderizer.unstake(msg.sender, _amount);\n\n        // update total pooled tokens\n        _updateTotalPooledTokens();\n    }\n\n    /**\n     * @notice Withdraws unstaked tokens\n     * @param _unstakeLockID lockID of the unstake\n     * @dev tokens need to be unstaked before they can be withdrawn\n     * @dev caller address should match the user address in lock\n     */\n    function withdraw(uint256 _unstakeLockID) public nonReentrant {\n        require(_unstakeLockID > 0, \"ZERO_AMOUNT\");\n        // Execute pending withdrawal\n        // Reverts if unthawing period hasn't ended\n        tenderizer.withdraw(msg.sender, _unstakeLockID);\n    }\n\n    /**\n     * @notice Rebase will stake pending deposits, claim rewards, \n     resync the liquidity pool and collect fees\n     * @dev only callable by owner(gov)\n     */\n    function rebase() public nonReentrant {\n        // stake tokens\n        gulp();\n\n        // claim rewards\n        tenderizer.claimRewards();\n\n        // update total pooled tokens\n        _updateTotalPooledTokens();\n\n        // Collect governance fees\n        _collectFees();\n        // Collect LP fees\n        _collectLiquidityFees();\n\n        // Resync weight for tenderToken\n        try esp.resyncWeight(address(tenderToken)) {} catch {\n            // No-op\n        }\n    }\n\n    /**\n     * @notice Gulp stakes any unstaked token balance held by the Tenderizer\n     * @dev deposit() only aggregates stake in the tenderizer, while gulp\n     will perform the actual stake call\n     * @dev only callable by owner(gov)\n     */\n    function gulp() public {\n        // gulp steak balance of Tenderizer and stake it\n        try tenderizer.stake(address(0), 0) {} catch {}\n    }\n\n    /**\n     * @notice Collect pending protocol fees from Tenderizer\n     * @dev mints equal number of tender tokens to the owner\n     * @dev only callable by owner(gov)\n     */\n    function collectFees() public onlyOwner {\n        _collectFees();\n    }\n\n    /**\n     * @notice Collect pending liquidity provider fees from Tenderizer\n     * @dev mints equal number of tender tokens to the tenderFarm\n     * @dev only callable by owner(gov)\n     */\n    function collectLiquidityFees() public onlyOwner {\n        _collectLiquidityFees();\n    }\n\n    /**\n     * @notice Set Elastic Supply Pool contract\n     * @param _esp Elastic Supply Pool contract address\n     * @dev only callable by owner(gov)\n     */\n    function setEsp(IElasticSupplyPool _esp) public onlyOwner {\n        require(address(_esp) != address(0), \"ZERO_ADDRESS\");\n        esp = _esp;\n    }\n\n    function migrateToNewTenderizer(ITenderizer _tenderizer) public onlyOwner {}\n\n    /**\n     * @notice Set TenderFarm contract\n     * @param _tenderFarm TenderFarm contract address\n     * @dev only callable by owner(gov)\n     */\n    function setTenderFarm(ITenderFarm _tenderFarm) public onlyOwner {\n        tenderFarm = _tenderFarm;\n    }\n\n    /**\n     * @notice Exectutes a transaction on behalf of the controller\n     * @param _target target address for the contract call\n     * @param _value ether value to be transeffered with the transaction\n     * @param _data call data - check ethers.interface.encodeFunctionData()\n     * @dev only callable by owner(gov)\n     */\n    function execute(\n        address _target,\n        uint256 _value,\n        bytes calldata _data\n    ) public onlyOwner {\n        _execute(_target, _value, _data);\n    }\n\n    /**\n     * @notice Exectutes a batch of transaction on behalf of the controller\n     * @param _targets array of target addresses for the contract call\n     * @param _values array of ether values to be transeffered with the transactions\n     * @param _datas array of call datas - check ethers.interface.encodeFunctionData()\n     * @dev Every target to its value, data via it's corresponding index\n     * @dev only callable by owner(gov)\n     */\n    function batchExecute(\n        address[] calldata _targets,\n        uint256[] calldata _values,\n        bytes[] calldata _datas\n    ) public onlyOwner {\n        require(_targets.length == _values.length && _targets.length == _datas.length, \"INVALID_ARGUMENTS\");\n        for (uint256 i = 0; i < _targets.length; i++) {\n            _execute(_targets[i], _values[i], _datas[i]);\n        }\n    }\n\n    function _execute(\n        address _target,\n        uint256 _value,\n        bytes calldata _data\n    ) internal {\n        (bool success, bytes memory returnData) = _target.call{ value: _value }(_data);\n        require(success, string(returnData));\n    }\n\n    function _updateTotalPooledTokens() internal {\n        // get total staked tokens\n        uint256 stakedTokens = tenderizer.totalStakedTokens();\n\n        // Set total pooled tokens, rebases tenderToken supply\n        tenderToken.setTotalPooledTokens(stakedTokens);\n    }\n\n    function _collectFees() internal {\n        // collect fees and get amount\n        uint256 amount = tenderizer.collectFees();\n\n        // mint tenderToken to fee distributor (governance)\n        tenderToken.mint(owner(), amount);\n    }\n\n    function _collectLiquidityFees() internal {\n        if (tenderFarm.nextTotalStake() == 0) return;\n        // collect fees and get amount\n        uint256 amount = tenderizer.collectLiquidityFees();\n\n        // mint tenderToken to fee distributor (governance)\n        tenderToken.mint(address(this), amount);\n        tenderToken.approve(address(tenderFarm), amount);\n        tenderFarm.addRewards(amount);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n"
    },
    "@openzeppelin/contracts/security/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor () {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "contracts/token/ITenderToken.sol": {
      "content": "// // SPDX-FileCopyrightText: 2020 Tenderize <info@tenderize.me>\n\n// // SPDX-License-Identifier: GPL-3.0\n\n// /* See contracts/COMPILERS.md */\npragma solidity 0.8.4;\n\ninterface ITenderToken {\n    function decimals() external pure returns (uint8);\n\n    function totalSupply() external view returns (uint256);\n\n    function getTotalPooledTokens() external view returns (uint256);\n\n    function getTotalShares() external view returns (uint256);\n\n    function balanceOf(address _account) external view returns (uint256);\n\n    function sharesOf(address _account) external view returns (uint256);\n\n    function allowance(address _owner, address _spender) external view returns (uint256);\n\n    function tokensToShares(uint256 _tokens) external view returns (uint256);\n\n    function sharesToTokens(uint256 _shares) external view returns (uint256);\n\n    function transfer(address _recipient, uint256 _amount) external returns (bool);\n\n    function approve(address _spender, uint256 _amount) external returns (bool);\n\n    function transferFrom(\n        address _sender,\n        address _recipient,\n        uint256 _amount\n    ) external returns (bool);\n\n    function increaseAllowance(address _spender, uint256 _addedValue) external returns (bool);\n\n    function decreaseAllowance(address _spender, uint256 _subtractedValue) external returns (bool);\n\n    function mint(address _recipient, uint256 _amount) external returns (bool);\n\n    function burn(address _account, uint256 _amount) external returns (bool);\n\n    function setTotalPooledTokens(uint256 _newTotalPooledTokens) external;\n}\n"
    },
    "contracts/tenderizer/ITenderizer.sol": {
      "content": "// // SPDX-FileCopyrightText: 2020 Tenderize <info@tenderize.me>\n\n// // SPDX-License-Identifier: GPL-3.0\n\n// /* See contracts/COMPILERS.md */\npragma solidity 0.8.4;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface ITenderizer {\n    function deposit(address _from, uint256 _amount) external;\n\n    function stake(address _node, uint256 _amount) external;\n\n    function unstake(address _account, uint256 _amount) external returns (uint256 unstakeLockID);\n\n    function withdraw(address _account, uint256 _unstakeLockID) external;\n\n    function claimRewards() external;\n\n    function collectFees() external returns (uint256);\n\n    function collectLiquidityFees() external returns (uint256);\n\n    function totalStakedTokens() external view returns (uint256);\n\n    // Governance\n\n    function setController(address _controller) external;\n\n    function setNode(address _node) external;\n\n    function setSteak(IERC20 _steak) external;\n\n    function setProtocolFee(uint256 _protocolFee) external;\n\n    function setLiquidityFee(uint256 _liquidityFee) external;\n\n    function setStakingContract(address _stakingContract) external;\n}\n"
    },
    "contracts/liquidity/IElasticSupplyPool.sol": {
      "content": "// // SPDX-FileCopyrightText: 2020 Tenderize <info@tenderize.me>\n\n// // SPDX-License-Identifier: GPL-3.0\n\n// /* See contracts/COMPILERS.md */\npragma solidity 0.8.4;\n\ninterface IElasticSupplyPool {\n    function resyncWeight(address _token) external;\n}\n"
    },
    "contracts/liquidity/ITenderFarm.sol": {
      "content": "// // SPDX-FileCopyrightText: 2020 Tenderize <info@tenderize.me>\n\n// // SPDX-License-Identifier: GPL-3.0\n\n// /* See contracts/COMPILERS.md */\npragma solidity 0.8.4;\n\ninterface ITenderFarm {\n    function farm(uint256 _amount) external;\n\n    function farmFor(address _for, uint256 _amount) external;\n\n    function unfarm(uint256 _amount) external;\n\n    function harvest() external;\n\n    function addRewards(uint256 _amount) external;\n\n    function availableRewards(address _for) external view returns (uint256);\n\n    function stakeOf(address _of) external view returns (uint256);\n\n    function totalStake() external view returns (uint256);\n\n    function nextTotalStake() external view returns (uint256);\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"
    },
    "contracts/tenderizer/Tenderizer.sol": {
      "content": "// // SPDX-FileCopyrightText: 2020 Tenderize <info@tenderize.me>\n\n// // SPDX-License-Identifier: GPL-3.0\n\n// /* See contracts/COMPILERS.md */\npragma solidity 0.8.4;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n\nimport \"./ITenderizer.sol\";\n\nabstract contract Tenderizer is Initializable, ITenderizer {\n\n    struct UnstakeLock {\n        uint256 amount;\n        address account;\n    }\n\n    address constant ZERO_ADDRESS = address(0);\n\n    IERC20 public steak;\n    address public node;\n\n    address public controller;\n\n    uint256 public protocolFee;\n    uint256 public liquidityFee;\n    uint256 public pendingFees; // pending protocol fees since last distribution\n    uint256 public pendingLiquidityFees;\n    uint256 public currentPrincipal; // Principal since last claiming earnings\n\n    mapping (uint256 => UnstakeLock) public unstakeLocks;\n    uint256 lastUnstakeLockID;\n\n    // Events\n    event Deposit(address indexed from, uint256 amount);\n    event Stake(address indexed node, uint256 amount);\n    event Unstake(address indexed from, address indexed node, uint256 amount, uint256 unstakeLockID);\n    event Withdraw(address indexed from, uint256 amount, uint256 unstakeLockID);\n    event RewardsClaimed(uint256 rewards, uint256 currentPrincipal, uint256 oldPrincipal);\n    event ProtocolFeeCollected(uint256 amount);\n    event LiquidityFeeCollected(uint256 amount);\n    event GovernanceUpdate(string _param);\n\n    modifier onlyController() {\n        require(msg.sender == controller);\n        _;\n    }\n\n    function _initialize(\n        IERC20 _steak,\n        address _node,\n        address _controller\n    ) internal initializer {\n        steak = _steak;\n        node = _node;\n        protocolFee = 25 * 1e15; // 2.5%\n        controller = _controller;\n    }\n\n    /**\n     * @notice Deposit tokens in Tenderizer\n     * @param _from account that deposits\n     * @param _amount amount deposited\n     * @dev only callable by Controller\n     * @dev doesn't actually stakes the tokens but aggregates the balance in the tenderizer\n        awaiting to be staked\n     * @dev requires '_amount' to be approved by '_from'\n     */\n    function deposit(address _from, uint256 _amount) external override onlyController {\n        _deposit(_from, _amount);\n    }\n\n    /**\n     * @notice Stake '_amount' of tokens to '_account'\n     * @param _account account to stake to in the underlying protocol\n     * @param _amount amount to stake\n     * @dev If '_account' is not specified, stake towards the default address\n     * @dev If '_amount' is 0, stake the entire current token balance of the Tenderizer\n     * @dev Only callable by controller\n     */\n    function stake(address _account, uint256 _amount) external override onlyController {\n        // Execute state updates\n        // approve pendingTokens for staking\n        // Stake tokens\n        _stake(_account, _amount);\n    }\n\n    /**\n     * @notice Unstake '_amount' of tokens from '_account'\n     * @param _account account to unstake from in the underlying protocol\n     * @param _amount amount to unstake\n     * @dev If '_account' is not specified, stake towards the default address\n     * @dev If '_amount' is 0, unstake the entire amount staked towards _account\n     * @dev Only callable by controller\n     */\n    function unstake(address _account, uint256 _amount) \n        external\n        override\n        onlyController \n        returns (uint256 unstakeLockID) {\n        // Execute state updates to pending withdrawals\n        // Unstake tokens\n        return _unstake(_account, address(0), _amount);\n    }\n\n    /**\n     * @notice Withdraw '_amount' of tokens previously unstaked by '_account'\n      * @param _unstakeLockID ID for the lock to request the withdraw for\n     * @param _account account requesting the withdrawam\n     * @dev If '_amount' isn't specified all unstake tokens by '_account' will be withdrawn\n     * @dev Requires '_account' to have unstaked prior to calling withdraw\n     * @dev Only callable by controller\n     */\n    function withdraw(address _account, uint256 _unstakeLockID) \n        external\n        override\n        onlyController {\n        // Execute state updates to pending withdrawals\n        // Transfer tokens to _account\n        _withdraw(_account, _unstakeLockID);\n    }\n\n    /**\n     * @notice Claim staking rewards for the underlying protocol\n     * @dev Only callable by controller\n     */\n    function claimRewards() external override onlyController {\n        // Claim rewards\n        // If received staking rewards in steak don't automatically compound, add to pendingTokens\n        // Swap tokens with address != steak to steak\n        // Add steak from swap to pendingTokens\n        _claimRewards();\n    }\n\n    function setController(address _controller) external override onlyController {\n        require(_controller != address(0), \"ZERO_ADDRESS\");\n        controller = _controller;\n        emit GovernanceUpdate(\"CONTROLLER\");\n    }\n\n    function setNode(address _node) external virtual override onlyController {\n        require(_node != address(0), \"ZERO_ADDRESS\");\n        node = _node;\n        emit GovernanceUpdate(\"NODE\");\n    }\n\n    function setSteak(IERC20 _steak) external virtual override onlyController {\n        require(address(_steak) != address(0), \"ZERO_ADDRESS\");\n        steak = _steak;\n        emit GovernanceUpdate(\"STEAK\");\n    }\n\n    function setProtocolFee(uint256 _protocolFee) external virtual override onlyController {\n        protocolFee = _protocolFee;\n        emit GovernanceUpdate(\"PROTOCOL_FEE\");\n    }\n\n    function setLiquidityFee(uint256 _liquidityFee) external virtual override onlyController {\n        liquidityFee = _liquidityFee;\n        emit GovernanceUpdate(\"LIQUIDITY_FEE\");\n    }\n\n    function setStakingContract(address _stakingContract) external override onlyController {\n        _setStakingContract(_stakingContract);\n    }\n\n    function collectFees() external override onlyController returns (uint256) {\n        return _collectFees();\n    }\n\n    function collectLiquidityFees() external override onlyController returns (uint256) {\n        return _collectLiquidityFees();\n    }\n\n    function totalStakedTokens() external view override returns (uint256) {\n        return _totalStakedTokens();\n    }\n\n    function _deposit(address _account, uint256 _amount) internal virtual;\n\n    function _stake(address _account, uint256 _amount) internal virtual;\n\n    function _unstake(\n        address _account,\n        address _node,\n        uint256 _amount\n    ) internal virtual returns (uint256  unstakeLockID);\n\n    function _withdraw(address _account, uint256 _unstakeLockID) internal virtual;\n\n    function _claimRewards() internal virtual;\n\n    function _collectFees() internal virtual returns (uint256) {\n        // set pendingFees to 0\n        // Controller will mint tenderToken and distribute it\n        uint256 before = pendingFees;\n        pendingFees = 0;\n        emit ProtocolFeeCollected(before);\n        return before;\n    }\n\n    function _collectLiquidityFees() internal virtual returns (uint256) {\n        // set pendingFees to 0\n        // Controller will mint tenderToken and distribute it\n        uint256 before = pendingLiquidityFees;\n        pendingLiquidityFees = 0;\n        emit LiquidityFeeCollected(before);\n        return before;\n    }\n\n    function _totalStakedTokens() internal view virtual returns (uint256);\n\n    // Internal governance functions\n    function _setStakingContract(address _stakingContract) internal virtual;\n}\n"
    },
    "@openzeppelin/contracts/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// solhint-disable-next-line compiler-version\npragma solidity ^0.8.0;\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n */\nabstract contract Initializable {\n\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    bool private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Modifier to protect an initializer function from being invoked twice.\n     */\n    modifier initializer() {\n        require(_initializing || !_initialized, \"Initializable: contract is already initialized\");\n\n        bool isTopLevelCall = !_initializing;\n        if (isTopLevelCall) {\n            _initializing = true;\n            _initialized = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            _initializing = false;\n        }\n    }\n}\n"
    },
    "contracts/tenderizer/integrations/matic/Matic.sol": {
      "content": "// // SPDX-FileCopyrightText: 2020 Tenderize <info@tenderize.me>\n\n// // SPDX-License-Identifier: GPL-3.0\n\n// /* See contracts/COMPILERS.md */\npragma solidity 0.8.4;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"../../../libs/MathUtils.sol\";\n\nimport \"../../Tenderizer.sol\";\nimport \"./IMatic.sol\";\n\ncontract Matic is Tenderizer {\n    // Matic exchange rate precision\n    uint256 constant EXCHANGE_RATE_PRECISION = 100;\n\n    // Matic stakeManager address\n    address maticStakeManager;\n\n    // Matic ValidatorShare\n    IMatic matic;\n\n    mapping(address => uint256) pendingWithdrawals;\n    uint256 totalPendingWithdrawals;\n\n    function initialize(\n        IERC20 _steak,\n        address _matic,\n        address _node\n    ) public {\n        Tenderizer._initialize(_steak, _node, msg.sender);\n        maticStakeManager = _matic;\n        matic = IMatic(_node);\n    }\n\n    function setNode(address _node) external override onlyController {\n        require(_node != address(0), \"ZERO_ADDRESS\");\n        node = _node;\n        matic = IMatic(_node);\n    }\n\n    function _deposit(address _from, uint256 _amount) internal override {\n        currentPrincipal += _amount;\n\n        emit Deposit(_from, _amount);\n    }\n\n    function _stake(address _node, uint256 _amount) internal override {\n        // if no amount is specified, stake all available tokens\n        uint256 amount = _amount;\n        if (amount == 0) {\n            amount = IERC20(steak).balanceOf(address(this));\n        }\n\n        if (amount == 0) {\n            return;\n            // TODO: revert ?\n        }\n\n        // use default validator share contract if _node isn't specified\n        IMatic matic_ = matic;\n        if (_node != address(0)) {\n            matic_ = IMatic(_node);\n        }\n\n        // approve tokens\n        steak.approve(maticStakeManager, amount);\n\n        // stake tokens\n        uint256 fxRate = matic.exchangeRate();\n        if (fxRate == 0) fxRate = 1;\n        uint256 min = MathUtils.percOf(amount, EXCHANGE_RATE_PRECISION, fxRate);\n        matic_.buyVoucher(amount, min);\n\n        emit Stake(address(matic_), amount);\n    }\n\n    function _unstake(\n        address _account,\n        address _node,\n        uint256 _amount\n    ) internal override returns (uint256 unstakeLockID) {\n        //  // Check that no withdrawal is pending\n        // require(pendingWithdrawals[_account] == 0, \"PENDING_WITHDRAWAL\");\n        // uint256 amount = _amount;\n        // // Sanity check. Controller already checks user deposits and withdrawals > 0\n        // if (_account != owner()) require(amount > 0, \"ZERO_AMOUNT\");\n        // if (amount == 0) {\n        //     amount = IERC20(steak).balanceOf(address(this));\n        // }\n        // // if no _node is specified, stake towards the default node\n        // IMatic node_ = IMatic(_node);\n        // if (_node == address(0)) {\n        //     node_ = IMatic(node);\n        // }\n        // currentPrincipal = currentPrincipal - _amount;\n        // // undelegate shares\n        // node_.sellVoucher(0);\n    }\n\n    function _withdraw(\n        address _account,\n        uint256 _unstakeLockID\n    ) internal override {\n        // // Check that a withdrawal is pending\n        // uint256 amount = graph.withdrawDelegated(node, ZERO_ADDRESS);\n        // // Transfer amount from unbondingLock to _account\n        // steak.transfer(_account, amount);\n    }\n\n    function _claimRewards() internal override {\n        // restake to compound rewards\n\n        try matic.restake() {} catch {}\n\n        // calculate rewards and fees\n        uint256 rewards;\n        uint256 stake;\n\n\n        uint256 shares = matic.balanceOf(address(this));\n        uint256 fxRate = matic.exchangeRate();\n        if (fxRate == 0) fxRate = 1;\n        stake = MathUtils.percOf(shares, fxRate, EXCHANGE_RATE_PRECISION);\n\n        uint256 currentPrincipal_ = currentPrincipal;\n\n        if (stake >= currentPrincipal_) {\n            rewards = stake - currentPrincipal_;\n        }\n\n        // Substract protocol fee amount and add it to pendingFees\n        uint256 _pendingFees = pendingFees + MathUtils.percOf(rewards, protocolFee);\n        pendingFees = _pendingFees;\n        uint256 _liquidityFees = pendingLiquidityFees + MathUtils.percOf(rewards, liquidityFee);\n        pendingLiquidityFees = _liquidityFees;\n        // Add current pending stake minus fees and set it as current principal\n        currentPrincipal = stake - _pendingFees - _liquidityFees;\n\n        emit RewardsClaimed(rewards, currentPrincipal, currentPrincipal_);\n    }\n\n    function _totalStakedTokens() internal view override returns (uint256) {\n        return currentPrincipal;\n    }\n\n    function _setStakingContract(address _stakingContract) internal override {\n        maticStakeManager = _stakingContract;\n\n        emit GovernanceUpdate(\"STAKING_CONTRACT\");\n    }\n}\n"
    },
    "contracts/libs/MathUtils.sol": {
      "content": "// // SPDX-FileCopyrightText: 2020 Tenderize <info@tenderize.me>\n\n// // SPDX-License-Identifier: GPL-3.0\n\n// /* See contracts/COMPILERS.md */\npragma solidity 0.8.4;\n\nlibrary MathUtils {\n    // Divisor used for representing percentages\n    uint256 public constant PERC_DIVISOR = 10**21;\n\n    /**\n     * @dev Returns whether an amount is a valid percentage out of PERC_DIVISOR\n     * @param _amount Amount that is supposed to be a percentage\n     */\n    function validPerc(uint256 _amount) internal pure returns (bool) {\n        return _amount <= PERC_DIVISOR;\n    }\n\n    /**\n     * @dev Compute percentage of a value with the percentage represented by a fraction\n     * @param _amount Amount to take the percentage of\n     * @param _fracNum Numerator of fraction representing the percentage\n     * @param _fracDenom Denominator of fraction representing the percentage\n     */\n    function percOf(\n        uint256 _amount,\n        uint256 _fracNum,\n        uint256 _fracDenom\n    ) internal pure returns (uint256) {\n        return (_amount * percPoints(_fracNum, _fracDenom)) / PERC_DIVISOR;\n    }\n\n    /**\n     * @dev Compute percentage of a value with the percentage represented by a fraction over PERC_DIVISOR\n     * @param _amount Amount to take the percentage of\n     * @param _fracNum Numerator of fraction representing the percentage with PERC_DIVISOR as the denominator\n     */\n    function percOf(uint256 _amount, uint256 _fracNum) internal pure returns (uint256) {\n        return (_amount * _fracNum) / PERC_DIVISOR;\n    }\n\n    /**\n     * @dev Compute percentage representation of a fraction\n     * @param _fracNum Numerator of fraction represeting the percentage\n     * @param _fracDenom Denominator of fraction represeting the percentage\n     */\n    function percPoints(uint256 _fracNum, uint256 _fracDenom) internal pure returns (uint256) {\n        return (_fracNum * PERC_DIVISOR) / _fracDenom;\n    }\n}\n"
    },
    "contracts/tenderizer/integrations/matic/IMatic.sol": {
      "content": "// // SPDX-FileCopyrightText: 2020 Tenderize <info@tenderize.me>\n\n// // SPDX-License-Identifier: GPL-3.0\n\n// /* See contracts/COMPILERS.md */\npragma solidity 0.8.4;\n\n// note this contract interface is only for stakeManager use\ninterface IMatic {\n    function unstakeClaimTokens() external;\n\n    function getLiquidRewards(address user) external view returns (uint256);\n\n    function owner() external view returns (address);\n\n    function restake() external;\n\n    function buyVoucher(uint256 _amount, uint256 _minSharesToMint) external;\n\n    function sellVoucher(uint256 _minClaimAmount) external;\n\n    function exchangeRate() external view returns (uint256);\n\n    struct Delegator {\n        uint256 shares;\n        uint256 withdrawEpoch;\n    }\n\n    function delegators(address) external view returns (Delegator memory);\n\n    function balanceOf(address) external view returns (uint256);\n}\n"
    },
    "contracts/token/TenderToken.sol": {
      "content": "// // SPDX-FileCopyrightText: 2020 Tenderize <info@tenderize.me>\n\n// // SPDX-License-Identifier: GPL-3.0\n\n// /* See contracts/COMPILERS.md */\npragma solidity 0.8.4;\n\nimport \"./NamedToken.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"../libs/MathUtils.sol\";\n\n/**\n * @title Interest-bearing ERC20-like token for Tenderize protocol.\n * @author Tenderize <info@tenderize.me>\n * @dev TenderToken balances are dynamic and are calculated based on the accounts' shares\n    and the total amount of Tokens controlled by the protocol. Account shares aren't\n    normalized, so the contract also stores the sum of all shares to calculate\n    each account's token balance which equals to:\n\n    shares[account] * _getTotalPooledTokens() / _getTotalShares()\n */\ncontract TenderToken is NamedToken, Ownable, IERC20 {\n    uint8 internal constant DECIMALS = 18;\n\n    /**\n     * @dev Total amount of outstanding shares\n     */\n    uint256 private totalShares;\n\n    /**\n     * @dev Total amount of underlying tokens pooled\n     */\n    uint256 private totalPooledTokens;\n\n    /**\n     * @dev Nominal amount of shares held by each account\n     */\n    mapping(address => uint256) private shares;\n\n    /**\n     * @dev Allowances nominated in tokens, not token shares.\n     */\n    mapping(address => mapping(address => uint256)) private allowances;\n\n    constructor(string memory _name, string memory _symbol)\n        NamedToken(string(abi.encodePacked(\"tender \", _name)), string(abi.encodePacked(\"t\", _symbol)))\n    {}\n\n    /**\n     * @notice The number of decimals the TenderToken uses\n     * @return the number of decimals for getting user representation of a token amount.\n     */\n    function decimals() public pure returns (uint8) {\n        return DECIMALS;\n    }\n\n    /**\n     * @notice The total supply of tender tokens in existence\n     * @dev Always equals to `_getTotalPooledTokens()` since token amount\n        is pegged to the total amount of Tokens controlled by the protocol.\n     * @return total supply\n     */\n    function totalSupply() external view override returns (uint256) {\n        return _getTotalPooledTokens();\n    }\n\n    /**\n     * @notice Total amount of underlying tokens controlled by the Tenderizer\n     * @dev The sum of all Tokens balances in the protocol, equals to the total supply of TenderToken.\n     * @return total amount of pooled tokens\n     */\n    function getTotalPooledTokens() public view returns (uint256) {\n        return _getTotalPooledTokens();\n    }\n\n    /**\n     * @notice The total amount of shares in existence.\n     * @dev The sum of all accounts' shares can be an arbitrary number, therefore\n        it is necessary to store it in order to calculate each account's relative share.\n     * @return total amount of shares\n     */\n    function getTotalShares() public view returns (uint256) {\n        return _getTotalShares();\n    }\n\n    /**\n     * @notice the amount of tokens owned by the `_account`.\n     * @dev Balances are dynamic and equal the `_account`'s share in the amount of the\n        total Tokens controlled by the protocol. See `sharesOf`.\n     * @param _account address of the account to check the balance for\n     */\n    function balanceOf(address _account) external view override returns (uint256) {\n        return sharesToTokens(_sharesOf(_account));\n    }\n\n    /**\n     * @notice The amount of shares owned by an account\n     * @param _account address of the account\n     * @return the amount of shares owned by `_account`.\n     */\n    function sharesOf(address _account) public view returns (uint256) {\n        return _sharesOf(_account);\n    }\n\n    /**\n     * @notice The remaining number of tokens that `_spender` is allowed to spend\n        behalf of `_owner` through `transferFrom`. This is zero by default.\n     * @dev This value changes when `approve` or `transferFrom` is called.\n     * @param _owner address that approved the allowance\n     * @param _spender address that is allowed to spend the allowance\n     * @return amount '_spender' is allowed to spend from '_owner'\n     */\n    function allowance(address _owner, address _spender) external view override returns (uint256) {\n        return allowances[_owner][_spender];\n    }\n\n    /**\n     * @notice The amount of shares that corresponds to `_tokens` protocol-controlled Tokens.\n     * @param _tokens amount of tokens to calculate shares for\n     * @return nominal amount of shares the tokens represent\n     */\n    function tokensToShares(uint256 _tokens) public view returns (uint256) {\n        uint256 _totalPooledTokens = _getTotalPooledTokens();\n        uint256 _totalShares = _getTotalShares();\n        if (_totalPooledTokens == 0) {\n            return 0;\n        } else if (_totalShares == 0) {\n            return _tokens;\n        } else {\n            return MathUtils.percOf(_tokens, _totalShares, _totalPooledTokens);\n        }\n    }\n\n    /**\n     * @notice The amount of tokens that corresponds to `_shares` token shares.\n     * @param _shares the amount of shares to calculate the amount of tokens for\n     * @return the amount of tokens represented by the shares\n     */\n    function sharesToTokens(uint256 _shares) public view returns (uint256) {\n        uint256 currShares = _getTotalShares();\n        if (currShares == 0) {\n            return 0;\n        } else {\n            return MathUtils.percOf(_shares, _getTotalPooledTokens(), currShares);\n        }\n    }\n\n    /**\n     * @notice Transfers `_amount` tokens from the caller's account to the `_recipient` account.\n     * @param _recipient address of the recipient\n     * @param _amount amount of tokens to transfer\n     * @return a boolean value indicating whether the operation succeeded.\n     * @dev Emits a `Transfer` event.\n     * @dev Requirements:\n        - `_recipient` cannot be the zero address.\n        - the caller must have a balance of at least `_amount`.\n     * @dev The `_amount` argument is the amount of tokens, not shares.\n     */\n    function transfer(address _recipient, uint256 _amount) external override returns (bool) {\n        _transfer(msg.sender, _recipient, _amount);\n        return true;\n    }\n\n    /**\n     * @notice Sets `_amount` as the allowance of `_spender` over the caller's tokens.\n     * @param _spender address of the spender allowed to approve tokens from caller\n     * @param _amount amount of tokens to allow '_spender' to spend\n     * @return a boolean value indicating whether the operation succeeded.\n     * @dev Emits an `Approval` event.\n     * @dev Requirements:\n        - `_spender` cannot be the zero address.\n     * @dev The `_amount` argument is the amount of tokens, not shares.\n     */\n    function approve(address _spender, uint256 _amount) external override returns (bool) {\n        _approve(msg.sender, _spender, _amount);\n        return true;\n    }\n\n    /**\n     * @notice Transfers `_amount` tokens from `_sender` to `_recipient` using the\n        allowance mechanism. `_amount` is then deducted from the caller's allowance.\n     * @param _sender address of the account to transfer tokens from\n     * @param _recipient address of the recipient\n     * @return a boolean value indicating whether the operation succeeded.\n     * @dev Emits a `Transfer` event.\n     * @dev Emits an `Approval` event indicating the updated allowance.\n     * @dev Requirements:\n        - `_sender` and `_recipient` cannot be the zero addresses.\n        - `_sender` must have a balance of at least `_amount`.\n        - the caller must have allowance for `_sender`'s tokens of at least `_amount`.\n     * @dev The `_amount` argument is the amount of tokens, not shares.\n     */\n    function transferFrom(\n        address _sender,\n        address _recipient,\n        uint256 _amount\n    ) external override returns (bool) {\n        uint256 currentAllowance = allowances[_sender][msg.sender];\n        require(currentAllowance >= _amount, \"TRANSFER_AMOUNT_EXCEEDS_ALLOWANCE\");\n\n        _transfer(_sender, _recipient, _amount);\n        _approve(_sender, msg.sender, currentAllowance - _amount);\n        return true;\n    }\n\n    /**\n     * @notice Atomically increases the allowance granted to `_spender` by the caller by `_addedValue`.\n     * @param _spender address of the spender allowed to approve tokens from caller\n     * @param _addedValue amount to add to allowance\n     * @dev This is an alternative to `approve` that can be used as a mitigation for problems described in:\n        https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/IERC20.sol#L42\n     * @dev Emits an `Approval` event indicating the updated allowance.\n     * @dev Requirements:\n        - `_spender` cannot be the the zero address.\n     */\n    function increaseAllowance(address _spender, uint256 _addedValue) public returns (bool) {\n        _approve(msg.sender, _spender, allowances[msg.sender][_spender] + _addedValue);\n        return true;\n    }\n\n    /**\n     * @notice Atomically decreases the allowance granted to `_spender` by the caller by `_subtractedValue`.\n     * @param _spender address of the spender allowed to approve tokens from caller\n     * @param _subtractedValue amount to subtract from current allowance\n     * @dev This is an alternative to `approve` that can be used as a mitigation for problems described in:\n        https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/IERC20.sol#L42\n     * @dev Emits an `Approval` event indicating the updated allowance.\n     * @dev Requirements:\n        - `_spender` cannot be the zero address.\n        - `_spender` must have allowance for the caller of at least `_subtractedValue`.\n     */\n    function decreaseAllowance(address _spender, uint256 _subtractedValue) public returns (bool) {\n        uint256 currentAllowance = allowances[msg.sender][_spender];\n        require(currentAllowance >= _subtractedValue, \"DECREASED_ALLOWANCE_BELOW_ZERO\");\n        _approve(msg.sender, _spender, currentAllowance - _subtractedValue);\n        return true;\n    }\n\n    /**\n     * @notice Mints '_amount' of tokens for '_recipient'\n     * @param _recipient address to mint tokens for\n     * @param _amount amount to mint\n     * @return a boolean value indicating whether the operation succeeded.\n     * @dev Only callable by contract owner\n     * @dev Calculates the amount of shares to create based on the specified '_amount'\n        and creates new shares rather than minting actual tokens\n     * @dev '_recipient' should also deposit into Tenderizer\n        atomically to prevent diluation of existing particpants\n     */\n    function mint(address _recipient, uint256 _amount) public onlyOwner returns (bool) {\n        uint256 _totalPooledTokens = _getTotalPooledTokens();\n        if (_totalPooledTokens == 0) {\n            _mintShares(_recipient, _amount);\n        } else {\n            uint256 _sharesToMint = tokensToShares(_amount);\n            _mintShares(_recipient, _sharesToMint);\n        }\n        _setTotalPooledTokens(totalPooledTokens + _amount);\n        return true;\n    }\n\n    /**\n     * @notice Burns '_amount' of tokens from '_recipient'\n     * @param _account address to burn the tokens from\n     * @param _amount amount to burn\n     * @return a boolean value indicating whether the operation succeeded.\n     * @dev Only callable by contract owner\n     * @dev Calculates the amount of shares to destroy based on the specified '_amount'\n        and destroy shares rather than burning tokens\n     * @dev '_recipient' should also withdraw from Tenderizer atomically\n     */\n    function burn(address _account, uint256 _amount) public onlyOwner returns (bool) {\n        uint256 _sharesToburn = tokensToShares(_amount);\n        _burnShares(_account, _sharesToburn);\n        _setTotalPooledTokens(totalPooledTokens - _amount);\n        return true;\n    }\n\n    /**\n     * @notice Sets the total amount of pooled tokens controlled by the Tenderizer\n     * @param _newTotalPooledTokens new amount of total tokens controlled by the Tenderizer\n     * @dev Only callable by contract owner\n     */\n    function setTotalPooledTokens(uint256 _newTotalPooledTokens) public onlyOwner {\n        _setTotalPooledTokens(_newTotalPooledTokens);\n    }\n\n    /**\n     * @return the total amount (in 10e18) of Tokens controlled by the protocol.\n     * @dev This is used for calculating tokens from shares and vice versa.\n     * @dev This function is required to be implemented in a derived contract.\n     */\n    function _getTotalPooledTokens() internal view returns (uint256) {\n        return totalPooledTokens;\n    }\n\n    /**\n     * @dev update the total amount (in 10e18) of Tokens controlled by the protocol.\n     */\n    function _setTotalPooledTokens(uint256 _newTotalPooledTokens) internal {\n        totalPooledTokens = _newTotalPooledTokens;\n    }\n\n    /**\n     * @dev Moves `_amount` tokens from `_sender` to `_recipient`.\n     * @dev Emits a `Transfer` event.\n     */\n    function _transfer(\n        address _sender,\n        address _recipient,\n        uint256 _amount\n    ) internal {\n        uint256 _sharesToTransfer = tokensToShares(_amount);\n        _transferShares(_sender, _recipient, _sharesToTransfer);\n        emit Transfer(_sender, _recipient, _amount);\n    }\n\n    /**\n     * @dev Sets `_amount` as the allowance of `_spender` over the `_owner` s tokens.\n     * @dev Emits an `Approval` event.\n     */\n    function _approve(\n        address _owner,\n        address _spender,\n        uint256 _amount\n    ) internal {\n        require(_owner != address(0), \"APPROVE_FROM_ZERO_ADDRESS\");\n        require(_spender != address(0), \"APPROVE_TO_ZERO_ADDRESS\");\n\n        allowances[_owner][_spender] = _amount;\n        emit Approval(_owner, _spender, _amount);\n    }\n\n    /**\n     * @dev the total amount of shares in existence.\n     */\n    function _getTotalShares() internal view returns (uint256) {\n        return totalShares;\n    }\n\n    /**\n     * @dev the amount of shares owned by `_account`.\n     */\n    function _sharesOf(address _account) internal view returns (uint256) {\n        return shares[_account];\n    }\n\n    /**\n     * @dev Moves `_shares` shares from `_sender` to `_recipient`.\n     * @dev Requirements:\n        - `_sender` cannot be the zero address.\n        - `_recipient` cannot be the zero address.\n        - `_sender` must hold at least `_shares` shares.\n     */\n    function _transferShares(\n        address _sender,\n        address _recipient,\n        uint256 _shares\n    ) internal {\n        require(_sender != address(0), \"TRANSFER_FROM_THE_ZERO_ADDRESS\");\n        require(_recipient != address(0), \"TRANSFER_TO_THE_ZERO_ADDRESS\");\n\n        uint256 currentSenderShares = shares[_sender];\n        require(_shares <= currentSenderShares, \"TRANSFER_AMOUNT_EXCEEDS_BALANCE\");\n\n        shares[_sender] -= _shares;\n        shares[_recipient] += _shares;\n    }\n\n    /**\n     * @dev Creates `_shares` shares and assigns them to `_recipient`, increasing the total amount of shares.\n     * @dev This doesn't increase the token total supply.\n     * @dev Requirements:\n        - `_recipient` cannot be the zero address.\n     */\n    function _mintShares(address _recipient, uint256 _shares) internal returns (uint256 newTotalShares) {\n        require(_recipient != address(0), \"MINT_TO_THE_ZERO_ADDRESS\");\n\n        newTotalShares = totalShares + _shares;\n\n        shares[_recipient] += _shares;\n\n        // Notice: we're not emitting a Transfer event from the zero address here since shares mint\n        // works by taking the amount of tokens corresponding to the minted shares from all other\n        // token holders, proportionally to their share. The total supply of the token doesn't change\n        // as the result. This is equivalent to performing a send from each other token holder's\n        // address to `address`, but we cannot reflect this as it would require sending an unbounded\n        // number of events.\n        totalShares = newTotalShares;\n    }\n\n    /**\n     * @dev Destroys `_shares` shares from `_account`'s holdings, decreasing the total amount of shares.\n     * @dev This doesn't decrease the token total supply.\n     * @dev Requirements:\n        - `_account` cannot be the zero address.\n        - `_account` must hold at least `_shares` shares.\n     */\n    function _burnShares(address _account, uint256 _shares) internal returns (uint256 newTotalShares) {\n        require(_account != address(0), \"BURN_FROM_THE_ZERO_ADDRESS\");\n\n        uint256 accountShares = shares[_account];\n        require(_shares <= accountShares, \"BURN_AMOUNT_EXCEEDS_BALANCE\");\n\n        newTotalShares = totalShares - _shares;\n\n        shares[_account] -= _shares;\n\n        // Notice: we're not emitting a Transfer event to the zero address here since shares burn\n        // works by redistributing the amount of tokens corresponding to the burned shares between\n        // all other token holders. The total supply of the token doesn't change as the result.\n        // This is equivalent to performing a send from `address` to each other token holder address,\n        // but we cannot reflect this as it would require sending an unbounded number of events.\n        totalShares = newTotalShares;\n    }\n}\n"
    },
    "contracts/token/NamedToken.sol": {
      "content": "// // SPDX-FileCopyrightText: 2020 Lido <info@lido.fi>\n\n// // SPDX-License-Identifier: GPL-3.0\n\n// /* See contracts/COMPILERS.md */\npragma solidity 0.8.4;\n\ncontract NamedToken {\n    string _name;\n    string _symbol;\n\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    function name() external view returns (string memory) {\n        return _name;\n    }\n\n    function symbol() external view returns (string memory) {\n        return _symbol;\n    }\n}\n"
    },
    "contracts/Registry.sol": {
      "content": "// // SPDX-FileCopyrightText: 2020 Tenderize <info@tenderize.me>\n\n// // SPDX-License-Identifier: GPL-3.0\n\n// /* See contracts/COMPILERS.md */\npragma solidity 0.8.4;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract Registry is Ownable {\n    struct TenderizerConfig {\n        string name;\n        address controller;\n        address steak;\n        address tenderizer;\n        address tenderToken;\n        address esp;\n        address bpool;\n        address tenderFarm;\n    }\n\n    event TenderizerCreated(TenderizerConfig config);\n\n    function addTenderizer(TenderizerConfig calldata config) public onlyOwner {\n        emit TenderizerCreated(config);\n    }\n}\n"
    },
    "contracts/liquidity/TenderFarm.sol": {
      "content": "// // SPDX-FileCopyrightText: 2020 Tenderize <info@tenderize.me>\n\n// // SPDX-License-Identifier: GPL-3.0\n\n// /* See contracts/COMPILERS.md */\npragma solidity 0.8.4;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport \"../libs/MathUtils.sol\";\nimport \"../token/ITenderToken.sol\";\n\ncontract TenderFarm is Ownable {\n    event Farm(address indexed account, uint256 amount);\n    event Unfarm(address indexed account, uint256 amount);\n    event Harvest(address indexed account, uint256 amount);\n    event RewardsAdded(uint256 amount);\n\n    IERC20 public token; // LP token\n    ITenderToken public rewardToken; // tender token\n\n    uint256 public totalStake; // total amount of LP tokens staked\n    uint256 public nextTotalStake;\n    uint256 public CRF; // cumulative reward factor\n\n    struct Stake {\n        uint256 stake;\n        uint256 lastCRF;\n    }\n\n    mapping(address => Stake) public stakes;\n\n    constructor(IERC20 _stakeToken, ITenderToken _rewardToken) {\n        token = _stakeToken;\n        rewardToken = _rewardToken;\n    }\n\n    /**\n     * @notice stake liquidity pool tokens to receive rewards\n     * @dev '_amount' needs to be approved for the 'TenderFarm' to transfer\n     * @dev harvests current rewards before accounting updates are made\n     * @param _amount amount of liquidity pool tokens to stake\n     */\n    function farm(uint256 _amount) public {\n        _farmFor(msg.sender, _amount);\n    }\n\n    /**\n     * @notice stake liquidity pool tokens for a specific account so that it receives rewards\n     * @dev '_amount' needs to be approved for the 'TenderFarm' to transfer\n     * @dev staked tokens will belong to the account they are staked for\n     * @dev harvests current rewards before accounting updates are made\n     * @param _for account to stake for\n     * @param _amount amount of liquidity pool tokens to stake\n     */\n    function farmFor(address _for, uint256 _amount) public {\n        _farmFor(_for, _amount);\n    }\n\n    /**\n     * @notice unstake liquidity pool tokens\n     * @dev '_amount' needs to be approved for the 'TenderFarm' to transfer\n     * @dev harvests current rewards before accounting updates are made\n     * @param _amount amount of liquidity pool tokens to stake\n     */\n    function unfarm(uint256 _amount) public {\n        _unfarm(msg.sender, _amount);\n    }\n\n    /**\n     * @notice harvest outstanding rewards\n     * @dev reverts when trying to harvest multiple times if no new rewards have been added\n     * @dev emits an event with how many reward tokens have been harvested\n     */\n    function harvest() public {\n        _harvest(msg.sender);\n    }\n\n    /**\n     * @notice add new rewards\n     * @dev will 'start' a new 'epoch'\n     * @dev only callable by owner\n     * @param _amount amount of reward tokens to add\n     */\n    function addRewards(uint256 _amount) public onlyOwner {\n        uint256 _nextStake = nextTotalStake;\n        require(_nextStake > 0, \"NO_STAKE\");\n        totalStake = _nextStake;\n        uint256 shares = rewardToken.tokensToShares(_amount);\n        CRF += MathUtils.percPoints(shares, _nextStake);\n        require(rewardToken.transferFrom(msg.sender, address(this), _amount), \"TRANSFER_FAILED\");\n        emit RewardsAdded(_amount);\n    }\n\n    function availableRewards(address _for) public view returns (uint256) {\n        return rewardToken.sharesToTokens(_availableRewardShares(_for));\n    }\n\n    function stakeOf(address _of) public view returns (uint256) {\n        return _stakeOf(_of);\n    }\n\n    function _farmFor(address _for, uint256 _amount) internal {\n        _harvest(_for);\n\n        stakes[_for].stake += _amount;\n        nextTotalStake += _amount;\n\n        require(token.transferFrom(msg.sender, address(this), _amount), \"TRANSFERFROM_FAIL\");\n\n        emit Farm(_for, _amount);\n    }\n\n    function _unfarm(address _for, uint256 _amount) internal {\n        Stake storage _stake = stakes[_for];\n        require(_amount <= _stake.stake, \"AMOUNT_EXCEEDS_STAKE\");\n\n        _harvest(_for);\n\n        _stake.stake -= _amount;\n        nextTotalStake -= _amount;\n\n        require(token.transfer(_for, _amount), \"TRANSFER_FAIL\");\n        emit Unfarm(_for, _amount);\n    }\n\n    function _harvest(address _for) internal {\n        Stake storage _stake = stakes[_for];\n\n        // Calculate available rewards\n        uint256 rewards = _availableRewardShares(_for);\n\n        // Checkpoint CRF\n        _stake.lastCRF = CRF;\n\n        if (rewards > 0) {\n            uint256 rewardTokens = rewardToken.sharesToTokens(rewards);\n            require(rewardToken.transfer(_for, rewardTokens), \"TRANSFER_FAIL\");\n            emit Harvest(_for, rewardTokens);\n        }\n    }\n\n    function _availableRewardShares(address _for) internal view returns (uint256) {\n        Stake storage _stake = stakes[_for];\n\n        if (CRF == 0) return 0;\n\n        return MathUtils.percOf(_stake.stake, CRF - _stake.lastCRF);\n    }\n\n    function _stakeOf(address _of) internal view returns (uint256) {\n        return stakes[_of].stake;\n    }\n}\n"
    },
    "contracts/tenderizer/integrations/matic/MaticMock.sol": {
      "content": "pragma solidity 0.8.4;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ncontract MaticMock {\n    constructor(IERC20 _matic) {\n        matic = _matic;\n    }\n\n    IERC20 matic;\n\n    function withdrawRewards() public {}\n\n    function unstakeClaimTokens() public {}\n\n    function getLiquidRewards(address user) public view returns (uint256) {}\n\n    function restake() public {}\n\n    function buyVoucher(uint256 _amount, uint256 _minSharesToMint) external {}\n\n    function sellVoucher(uint256 _minClaimAmount) external {}\n\n    function exchangeRate() external view returns (uint256) {}\n\n    function balanceOf(address _from) external view returns (uint256) {}\n\n    struct Delegator {\n        uint256 shares;\n        uint256 withdrawEpoch;\n    }\n\n    function delegators(address) external view returns (Delegator memory) {}\n}\n"
    },
    "contracts/tenderizer/integrations/livepeer/LivepeerMock.sol": {
      "content": "// // SPDX-FileCopyrightText: 2020 Tenderize <info@tenderize.me>\n\n// // SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.4;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ncontract LivepeerMock {\n    constructor(IERC20 _lpt) {\n        lpt = _lpt;\n    }\n\n    IERC20 lpt;\n\n    function bond(uint256 _amount, address _to) external {\n        require(lpt.transferFrom(msg.sender, address(this), _amount));\n    }\n\n    function unbond(uint256 _amount) external {}\n\n    function rebond(uint256 _unbondingLockId) external {}\n\n    function rebondFromUnbonded(address _to, uint256 _unbondingLockId) external {}\n\n    function withdrawStake(uint256 _unbondingLockId) external {}\n\n    function withdrawFees() external {}\n\n    function claimEarnings(uint256 _endRound) external {}\n\n    function pendingFees(address _delegator, uint256 _endRound) external view returns (uint256) {}\n\n    function pendingStake(address _delegator, uint256 _endRound) external view returns (uint256) {}\n\n    function getDelegator(address _delegator)\n        external\n        view\n        returns (\n            uint256 bondedAmount,\n            uint256 fees,\n            address delegateAddress,\n            uint256 delegatedAmount,\n            uint256 startRound,\n            uint256 lastClaimRound,\n            uint256 nextUnbondingLockId\n        )\n    {}\n}\n"
    },
    "contracts/tenderizer/integrations/livepeer/Livepeer.sol": {
      "content": "// // SPDX-FileCopyrightText: 2020 Tenderize <info@tenderize.me>\n\n// // SPDX-License-Identifier: GPL-3.0\n\n// /* See contracts/COMPILERS.md */\npragma solidity 0.8.4;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"../../../libs/MathUtils.sol\";\n\nimport \"../../Tenderizer.sol\";\nimport \"./ILivepeer.sol\";\nimport \"../../../liquidity/IOneInch.sol\";\n\ncontract Livepeer is Tenderizer {\n    uint256 private constant MAX_ROUND = 2**256 - 1;\n\n    IOneInch private oneInch;\n\n    ILivepeer livepeer;\n\n    uint256 private constant ethFees_threshold = 1**17;\n\n    function initialize(\n        IERC20 _steak,\n        ILivepeer _livepeer,\n        address _node\n    ) public {\n        Tenderizer._initialize(_steak, _node, msg.sender);\n        livepeer = _livepeer;\n    }\n\n    function _deposit(address _from, uint256 _amount) internal override {\n        currentPrincipal += _amount;\n\n        emit Deposit(_from, _amount);\n    }\n\n    function _stake(address _node, uint256 _amount) internal override {\n        // if no amount is specified, stake all available tokens\n        uint256 amount = _amount;\n        if (amount == 0) {\n            amount = IERC20(steak).balanceOf(address(this));\n        }\n\n        if (amount == 0) {\n            return;\n            // TODO: revert ?\n        }\n\n        // if no _node is specified, stake towards the default node\n        address node_ = _node;\n        if (node_ == address(0)) {\n            node_ = node;\n        }\n\n        // approve amount to Livepeer protocol\n        steak.approve(address(livepeer), amount);\n\n        // stake tokens\n        livepeer.bond(amount, node_);\n\n        emit Stake(node_, amount);\n    }\n\n    function _unstake(\n        address _account,\n        address _node,\n        uint256 _amount\n    ) internal override returns (uint256 unstakeLockID) {\n        uint256 amount = _amount;\n\n        // Sanity check. Controller already checks user deposits and withdrawals > 0\n        if (_account != controller) require(amount > 0, \"ZERO_AMOUNT\");\n        if (amount == 0) {\n            amount = livepeer.pendingStake(address(this), MAX_ROUND);\n            require(amount > 0, \"ZERO_STAKE\");\n        }\n\n        // if no _node is specified, stake towards the default node\n        address node_ = _node;\n        if (node_ == address(0)) {\n            node_ = node;\n        }\n\n        currentPrincipal -= amount;\n\n        // Unbond tokens\n        livepeer.unbond(amount);\n\n        // Manage Livepeer unbonding locks\n       unstakeLockID = ++lastUnstakeLockID;\n       unstakeLocks[unstakeLockID] = UnstakeLock({ amount: amount, account: _account });\n       \n       emit Unstake(_account, node_, amount, unstakeLockID);\n    }\n\n    function _withdraw(\n        address _account,\n        uint256 _unstakeID\n    ) internal override {\n        UnstakeLock storage lock = unstakeLocks[_unstakeID];\n        address account = lock.account;\n        uint256 amount = lock.amount;\n\n        require(account == _account, \"ACCOUNT_MISTMATCH\");\n        // Check that a withdrawal is pending\n        require(amount > 0, \"ZERO_AMOUNT\");\n\n        // Remove it from the locks\n        delete unstakeLocks[_unstakeID];\n\n        // Withdraw stake, transfers steak tokens to address(this)\n        livepeer.withdrawStake(_unstakeID);\n\n        // Transfer amount from unbondingLock to _account\n        steak.transfer(account, amount);\n\n        emit Withdraw(account, amount, _unstakeID);\n    }\n\n    function _claimRewards() internal override {\n        // Livepeer automatically compounds\n        // The rewards is the difference between\n        // pending stake and the latest cached stake amount\n\n        // TODO: Oh god this is going to be so costly\n        // What if we gulp before this call so we have the updated state in getDelegator ? bond might be more costly\n        // Let's just code this with everything we need and benchmark gas\n\n        // Account for LPT rewards\n        address del = address(this);\n        uint256 stake = livepeer.pendingStake(del, MAX_ROUND);\n        uint256 ethFees = livepeer.pendingFees(del, MAX_ROUND);\n        uint256 currentPrincipal_ = currentPrincipal;\n\n        uint256 rewards;\n        if (stake >= currentPrincipal_) {\n            rewards = stake - currentPrincipal_;\n        }\n\n        // withdraw fees\n        uint256  swappedLPT;\n        if (ethFees >= ethFees_threshold) {\n            livepeer.withdrawFees();\n\n            // swap ETH fees for LPT\n            if (address(oneInch) != address(0)) {\n                uint256 swapAmount = address(this).balance;\n                (uint256 returnAmount, uint256[] memory distribution) = oneInch.getExpectedReturn(\n                    IERC20(address(0)),\n                    steak,\n                    swapAmount,\n                    20,\n                    0\n                );\n                swappedLPT = oneInch.swap(IERC20(address(0)), steak, swapAmount, returnAmount, distribution, 0);\n                // Add swapped LPT to rewards\n                rewards += swappedLPT;\n            }\n        }\n\n        // Substract protocol fee amount and add it to pendingFees\n        uint256 _pendingFees = pendingFees + MathUtils.percOf(rewards, protocolFee);\n        pendingFees = _pendingFees;\n        uint256 _liquidityFees = pendingLiquidityFees + MathUtils.percOf(rewards, liquidityFee);\n        pendingLiquidityFees = _liquidityFees;\n        // Add current pending stake minus fees and set it as current principal\n        uint256 newPrincipal = stake + swappedLPT - _pendingFees - _liquidityFees;\n        currentPrincipal =  newPrincipal;\n\n        emit RewardsClaimed(rewards, newPrincipal, currentPrincipal_);\n    }\n\n    function _totalStakedTokens() internal view override returns (uint256) {\n        return currentPrincipal;\n    }\n\n    function _setStakingContract(address _stakingContract) internal override {\n        livepeer = ILivepeer(_stakingContract);\n\n        emit GovernanceUpdate(\"STAKING_CONTRACT\");\n    }\n\n    function setOneInchContract(address _oneInch) external onlyController {\n        oneInch = IOneInch(_oneInch);\n    }\n}\n"
    },
    "contracts/tenderizer/integrations/livepeer/ILivepeer.sol": {
      "content": "// // SPDX-FileCopyrightText: 2020 Tenderize <info@tenderize.me>\n\n// // SPDX-License-Identifier: GPL-3.0\n\n// /* See contracts/COMPILERS.md */\npragma solidity 0.8.4;\n\ninterface ILivepeer {\n    function bond(uint256 _amount, address _to) external;\n\n    function unbond(uint256 _amount) external;\n\n    function rebond(uint256 _unbondingLockId) external;\n\n    function rebondFromUnbonded(address _to, uint256 _unbondingLockId) external;\n\n    function withdrawStake(uint256 _unbondingLockId) external;\n\n    function withdrawFees() external;\n\n    function claimEarnings(uint256 _endRound) external;\n\n    function pendingFees(address _delegator, uint256 _endRound) external view returns (uint256);\n\n    function pendingStake(address _delegator, uint256 _endRound) external view returns (uint256);\n\n    function getDelegator(address _delegator)\n        external\n        view\n        returns (\n            uint256 bondedAmount,\n            uint256 fees,\n            address delegateAddress,\n            uint256 delegatedAmount,\n            uint256 startRound,\n            uint256 lastClaimRound,\n            uint256 nextUnbondingLockId\n        );\n}\n"
    },
    "contracts/liquidity/IOneInch.sol": {
      "content": "// // SPDX-FileCopyrightText: 2020 Tenderize <info@tenderize.me>\n\n// // SPDX-License-Identifier: GPL-3.0\n\n// /* See contracts/COMPILERS.md */\npragma solidity 0.8.4;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IOneInch {\n    function getExpectedReturn(\n        IERC20 fromToken,\n        IERC20 destToken,\n        uint256 amount,\n        uint256 parts,\n        uint256 flags // See constants in IOneSplit.sol\n    ) external view returns (uint256 returnAmount, uint256[] memory distribution);\n\n    function getExpectedReturnWithGas(\n        IERC20 fromToken,\n        IERC20 destToken,\n        uint256 amount,\n        uint256 parts,\n        uint256 flags, // See constants in IOneSplit.sol\n        uint256 destTokenEthPriceTimesGasPrice\n    )\n        external\n        view\n        returns (\n            uint256 returnAmount,\n            uint256 estimateGasAmount,\n            uint256[] memory distribution\n        );\n\n    function swap(\n        IERC20 fromToken,\n        IERC20 destToken,\n        uint256 amount,\n        uint256 minReturn,\n        uint256[] calldata distribution,\n        uint256 flags\n    ) external payable returns (uint256 returnAmount);\n\n    function getExpectedReturnWithGasMulti(\n        IERC20[] calldata tokens,\n        uint256 amount,\n        uint256[] calldata parts,\n        uint256[] calldata flags,\n        uint256[] calldata destTokenEthPriceTimesGasPrices\n    )\n        external\n        view\n        returns (\n            uint256[] memory returnAmounts,\n            uint256 estimateGasAmount,\n            uint256[] memory distribution\n        );\n\n    function swapMulti(\n        IERC20[] calldata tokens,\n        uint256 amount,\n        uint256 minReturn,\n        uint256[] calldata distribution,\n        uint256[] calldata flags\n    ) external payable returns (uint256 returnAmount);\n}\n"
    },
    "contracts/tenderizer/integrations/graph/GraphMock.sol": {
      "content": "// // SPDX-FileCopyrightText: 2020 Tenderize <info@tenderize.me>\n\n// // SPDX-License-Identifier: GPL-3.0\n\n// /* See contracts/COMPILERS.md */\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\npragma solidity 0.8.4;\n\ncontract GraphMock {\n    constructor(IERC20 _grt) {\n        grt = _grt;\n    }\n\n    IERC20 grt;\n    // -- Delegation Data --\n\n    /**\n     * @dev Delegation pool information. One per indexer.\n     */\n    struct DelegationPool {\n        uint32 cooldownBlocks; // Blocks to wait before updating parameters\n        uint32 indexingRewardCut; // in PPM\n        uint32 queryFeeCut; // in PPM\n        uint256 updatedAtBlock; // Block when the pool was last updated\n        uint256 tokens; // Total tokens as pool reserves\n        uint256 shares; // Total shares minted in the pool\n        // mapping(address => Delegation) delegators; // Mapping of delegator => Delegation\n    }\n\n    /**\n     * @dev Individual delegation data of a delegator in a pool.\n     */\n    struct Delegation {\n        uint256 shares; // Shares owned by a delegator in the pool\n        uint256 tokensLocked; // Tokens locked for undelegation\n        uint256 tokensLockedUntil; // Block when locked tokens can be withdrawn\n    }\n\n    function delegate(address _indexer, uint256 _tokens) external returns (uint256) {}\n\n    function undelegate(address _indexer, uint256 _shares) external returns (uint256) {}\n\n    function withdrawDelegated(address _indexer, address _newIndexer) external returns (uint256) {}\n\n    function getDelegation(address _indexer, address _delegator) external view returns (Delegation memory) {}\n\n    function delegationPools(address _indexer) external view returns (DelegationPool memory) {}\n\n    function getWithdraweableDelegatedTokens(Delegation memory _delegation) external view returns (uint256) {}\n\n    function thawingPeriod() external view returns (uint256) {}\n\n    function delegationTaxPercentage() external view returns (uint32) {}\n}\n"
    },
    "contracts/tenderizer/integrations/graph/Graph.sol": {
      "content": "// // SPDX-FileCopyrightText: 2020 Tenderize <info@tenderize.me>\n\n// // SPDX-License-Identifier: GPL-3.0\n\n// /* See contracts/COMPILERS.md */\npragma solidity 0.8.4;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"../../../libs/MathUtils.sol\";\n\nimport \"../../Tenderizer.sol\";\nimport \"./IGraph.sol\";\n\ncontract Graph is Tenderizer {\n    // 100% in parts per million\n    uint32 private constant MAX_PPM = 1000000;\n\n    IGraph graph;\n\n    // unstake lock ID of governance at the time governance unstakes\n    uint256 governancePendingUnstakeLockID;\n    // Set to governancePendingUnstakeLockID when governance withdrawal for the pending lock happens\n    uint256 governanceLastProcessedUnstakeLockID;\n    // Amount to unstake next by governance to process user withdrawals\n    uint256 pendingUnstakes;\n\n    function initialize(\n        IERC20 _steak,\n        IGraph _graph,\n        address _node\n    ) public {\n        Tenderizer._initialize(_steak, _node, msg.sender);\n        graph = _graph;\n    }\n\n    function _deposit(address _from, uint256 _amount) internal override {\n        currentPrincipal += _amount;\n\n        emit Deposit(_from, _amount);\n    }\n\n    function _stake(address _node, uint256 _amount) internal override {\n        // if no amount is specified, stake all available tokens\n        uint256 amount = _amount;\n        if (amount == 0) {\n            amount = IERC20(steak).balanceOf(address(this));\n        }\n\n        if (amount == 0) {\n            return;\n            // TODO: revert ?\n        }\n\n        // if no _node is specified, stake towards the default node\n        address node_ = _node;\n        if (node_ == ZERO_ADDRESS) {\n            node_ = node;\n        }\n\n        // approve amount to Graph protocol\n        steak.approve(address(graph), amount);\n\n        // stake tokens\n        graph.delegate(node_, amount);\n\n        emit Stake(node_, amount);\n    }\n\n    function _unstake(\n        address _account,\n        address _node,\n        uint256 _amount\n    ) internal override returns (uint256 unstakeLockID) {\n        uint256 amount = _amount;\n        unstakeLockID = ++lastUnstakeLockID;\n\n        // if no _node is specified, stake towards the default node\n        address node_ = _node;\n        if (node_ == ZERO_ADDRESS) {\n            node_ = node;\n        }\n\n        // Unstake from governance\n        if (_account == controller) {\n            // Check that no governance unstake is pending\n            require(governancePendingUnstakeLockID == governanceLastProcessedUnstakeLockID, \"GOV_WITHDRAW_PENDING\");\n            \n            amount = pendingUnstakes;\n            pendingUnstakes = 0;\n            governancePendingUnstakeLockID = unstakeLockID;\n\n            // Calculate the amount of shares to undelegate\n            IGraph.Delegation memory delegation = graph.getDelegation(node, address(this));\n            IGraph.DelegationPool memory delPool = graph.delegationPools(node);\n\n            uint256 delShares = delegation.shares;\n            uint256 totalShares = delPool.shares;\n            uint256 totalTokens = delPool.tokens;\n\n            uint256 stake = MathUtils.percOf(delShares, totalTokens, totalShares);\n            uint256 shares = MathUtils.percOf(delShares, amount, stake);\n\n            // undelegate shares\n            graph.undelegate(node_, shares);\n        } else {\n            require(amount > 0, \"ZERO_AMOUNT\");\n\n            currentPrincipal -= amount;\n            pendingUnstakes += amount;\n        }\n\n        unstakeLocks[unstakeLockID] = UnstakeLock({\n            amount: amount,\n            account: _account\n        });\n\n        emit Unstake(_account, node_, amount, unstakeLockID);\n    }\n\n    function _withdraw(\n        address _account,\n        uint256 _unstakeLockID\n    ) internal override {\n        UnstakeLock storage lock = unstakeLocks[_unstakeLockID];\n        address account = lock.account;\n        uint256 amount = lock.amount;\n\n        delete unstakeLocks[_unstakeLockID];\n\n        // Check that a withdrawal is pending and valid\n        require(account == _account, \"ACCOUNT_MISTMATCH\");\n        require(amount > 0, \"ZERO_AMOUNT\");\n        \n        if (_account == controller) {\n            governanceLastProcessedUnstakeLockID = governancePendingUnstakeLockID;\n            graph.withdrawDelegated(node, ZERO_ADDRESS);\n        } else {\n            // Check that gov withdrawal for that unstake has occured\n            require(_unstakeLockID < governanceLastProcessedUnstakeLockID, \"GOV_WITHDRAW_PENDING\");\n            // Transfer amount from unbondingLock to _account\n            steak.transfer(_account, amount);\n        } \n\n        emit Withdraw(account, amount, _unstakeLockID);\n    }\n\n    function _claimRewards() internal override {\n        // GRT automatically compounds\n        // The rewards is the difference between\n        // pending stake and the latest cached stake amount\n\n        // TODO: Oh god this is going to be so costly\n        // What if we gulp before this call so we have the updated state in getDelegator ? bond might be more costly\n        // Let's just code this with everything we need and benchmark gas\n\n        // Account for LPT rewards\n        address del = address(this);\n        uint256 currentPrincipal_ = currentPrincipal;\n\n        IGraph.Delegation memory delegation = graph.getDelegation(node, del);\n        IGraph.DelegationPool memory delPool = graph.delegationPools(node);\n\n        uint256 delShares = delegation.shares;\n        uint256 totalShares = delPool.shares;\n        uint256 totalTokens = delPool.tokens;\n\n        uint256 stake = MathUtils.percOf(delShares, totalTokens, totalShares);\n\n        uint256 rewards;\n        if (stake >= currentPrincipal_) {\n            rewards = stake - currentPrincipal_;\n        }\n\n        // Substract protocol fee amount and add it to pendingFees\n        uint256 _pendingFees = pendingFees + MathUtils.percOf(rewards, protocolFee);\n        pendingFees = _pendingFees;\n        uint256 _liquidityFees = pendingLiquidityFees + MathUtils.percOf(rewards, liquidityFee);\n        pendingLiquidityFees = _liquidityFees;\n        // Add current pending stake minus fees and set it as current principal\n        uint256 newPrincipal = stake - _pendingFees - _liquidityFees;\n        currentPrincipal = newPrincipal;\n\n        emit RewardsClaimed(rewards, newPrincipal, currentPrincipal_);\n    }\n\n    function _totalStakedTokens() internal view override returns (uint256) {\n        return currentPrincipal;\n    }\n\n    function _setStakingContract(address _stakingContract) internal override {\n        graph = IGraph(_stakingContract);\n\n        emit GovernanceUpdate(\"STAKING_CONTRACT\");\n    }\n}\n"
    },
    "contracts/tenderizer/integrations/graph/IGraph.sol": {
      "content": "// // SPDX-FileCopyrightText: 2020 Tenderize <info@tenderize.me>\n\n// // SPDX-License-Identifier: GPL-3.0\n\n// /* See contracts/COMPILERS.md */\npragma solidity 0.8.4;\n\ninterface IGraph {\n    // -- Delegation Data --\n\n    /**\n     * @dev Delegation pool information. One per indexer.\n     */\n    struct DelegationPool {\n        uint32 cooldownBlocks; // Blocks to wait before updating parameters\n        uint32 indexingRewardCut; // in PPM\n        uint32 queryFeeCut; // in PPM\n        uint256 updatedAtBlock; // Block when the pool was last updated\n        uint256 tokens; // Total tokens as pool reserves\n        uint256 shares; // Total shares minted in the pool\n        // mapping(address => Delegation) delegators; // Mapping of delegator => Delegation\n    }\n\n    /**\n     * @dev Individual delegation data of a delegator in a pool.\n     */\n    struct Delegation {\n        uint256 shares; // Shares owned by a delegator in the pool\n        uint256 tokensLocked; // Tokens locked for undelegation\n        uint256 tokensLockedUntil; // Block when locked tokens can be withdrawn\n    }\n\n    function delegate(address _indexer, uint256 _tokens) external returns (uint256);\n\n    function undelegate(address _indexer, uint256 _shares) external returns (uint256);\n\n    function withdrawDelegated(address _indexer, address _newIndexer) external returns (uint256);\n\n    function getDelegation(address _indexer, address _delegator) external view returns (Delegation memory);\n\n    function delegationPools(address _indexer) external view returns (DelegationPool memory);\n\n    function getWithdraweableDelegatedTokens(Delegation memory _delegation) external view returns (uint256);\n\n    function thawingPeriod() external view returns (uint256);\n\n    function delegationTaxPercentage() external view returns (uint32);\n}\n"
    },
    "contracts/liquidity/OneInchMock.sol": {
      "content": "// // SPDX-FileCopyrightText: 2020 Tenderize <info@tenderize.me>\n\n// // SPDX-License-Identifier: GPL-3.0\n\n// /* See contracts/COMPILERS.md */\npragma solidity 0.8.4;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ncontract OneInchMock {\n    function getExpectedReturn(\n        IERC20 fromToken,\n        IERC20 destToken,\n        uint256 amount,\n        uint256 parts,\n        uint256 flags // See constants in IOneSplit.sol\n    )\n        external\n        view\n        returns(\n            uint256 returnAmount,\n            uint256[] memory distribution\n        ) {}\n\n    function swap(\n        IERC20 fromToken,\n        IERC20 destToken,\n        uint256 amount,\n        uint256 minReturn,\n        uint256[] calldata distribution,\n        uint256 flags\n    )\n        external\n        payable\n        returns(uint256 returnAmount)\n        {}\n\n}"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The defaut value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor (string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\n        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\n        _approve(sender, _msgSender(), currentAllowance - amount);\n\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        uint256 senderBalance = _balances[sender];\n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[sender] = senderBalance - amount;\n        _balances[recipient] += amount;\n\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        _balances[account] = accountBalance - amount;\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be to transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\n}\n"
    },
    "contracts/test/SimpleToken.sol": {
      "content": "// // SPDX-FileCopyrightText: 2020 Tenderize <info@tenderize.me>\n\n// // SPDX-License-Identifier: GPL-3.0\n\n// /* See contracts/COMPILERS.md */\npragma solidity 0.8.4;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\n/**\n * @title SimpleToken\n * @dev Very simple ERC20 Token example, where all tokens are pre-assigned to the creator.\n * Note they can later distribute these tokens as they wish using `transfer` and other\n * `ERC20` functions.\n * Based on https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v2.5.1/contracts/examples/SimpleToken.sol\n */\ncontract SimpleToken is ERC20 {\n    /**\n     * @dev Constructor that gives msg.sender all of existing tokens.\n     */\n    constructor(\n        string memory name,\n        string memory symbol,\n        uint256 initialSupply\n    ) ERC20(name, symbol) {\n        _mint(msg.sender, initialSupply);\n    }\n}\n"
    },
    "contracts/Faucet.sol": {
      "content": "// // SPDX-FileCopyrightText: 2020 Tenderize <info@tenderize.me>\n\n// // SPDX-License-Identifier: GPL-3.0\n\n// /* See contracts/COMPILERS.md */\npragma solidity 0.8.4;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/**\n * @title Faucet for the Tokens\n */\ncontract TokenFaucet is Ownable {\n    // Token\n    ERC20 public token;\n\n    // Amount of token sent to sender for a request\n    uint256 public requestAmount;\n\n    // Amount of time a sender must wait between requests\n    uint256 public requestWait;\n\n    // sender => timestamp at which sender can make another request\n    mapping(address => uint256) public nextValidRequest;\n\n    // Whitelist addresses that can bypass faucet request rate limit\n    mapping(address => bool) public isWhitelisted;\n\n    // Checks if a request is valid (sender is whitelisted or has waited the rate limit time)\n    modifier validRequest() {\n        require(isWhitelisted[msg.sender] || block.timestamp >= nextValidRequest[msg.sender]);\n        _;\n    }\n\n    event Request(address indexed to, uint256 amount);\n\n    /**\n     * @notice Facuet constructor\n     * @param _token Address of Token\n     * @param _requestAmount Amount of token sent to sender for a request\n     * @param _requestWait Amount of time a sender must wait between request (denominated in hours)\n     */\n    constructor(\n        address _token,\n        uint256 _requestAmount,\n        uint256 _requestWait\n    ) public {\n        token = ERC20(_token);\n        requestAmount = _requestAmount;\n        requestWait = _requestWait;\n    }\n\n    /**\n     * @notice Add an address to the whitelist\n     * @param _addr Address to be whitelisted\n     */\n    function addToWhitelist(address _addr) external onlyOwner {\n        isWhitelisted[_addr] = true;\n    }\n\n    /**\n     * @notice Remove an address from the whitelist\n     * @param _addr Address to be removed from whitelist\n     */\n    function removeFromWhitelist(address _addr) external onlyOwner {\n        isWhitelisted[_addr] = false;\n    }\n\n    /**\n     * @notice Request an amount of token to be sent to sender\n     */\n    function request() external validRequest {\n        if (!isWhitelisted[msg.sender]) {\n            nextValidRequest[msg.sender] = block.timestamp + requestWait * 1 hours;\n        }\n\n        token.transfer(msg.sender, requestAmount);\n\n        emit Request(msg.sender, requestAmount);\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}